{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/favicon.jpg","path":"images/favicon.jpg","modified":0,"renderable":0},{"_id":"source/images/fd.jpg","path":"images/fd.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1518245631115},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1518245631116},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1518245631118},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1518245631121},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1518245631122},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1518245631124},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1518245631125},{"_id":"themes/yilia/_config.yml","hash":"14a8138e9a5f4e4eb670edfe4c141bf60e9de514","modified":1518245631127},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1518245631201},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1518245631310},{"_id":"source/_posts/Paint.md","hash":"ef2b2ecf458b40de89ed92a7463e85be5053151a","modified":1518245630929},{"_id":"source/_posts/Paint_shader.md","hash":"6b0278052c496bb78261c282619a1476915de4f0","modified":1518245630930},{"_id":"source/_posts/Path.md","hash":"135b0a46292fc9c6b9a3f36a938acc4eb22983a9","modified":1518245630932},{"_id":"source/_posts/canvas.md","hash":"16d036634366a8cf3ac090b442b35e79c4847d2e","modified":1518245630936},{"_id":"source/_posts/android-touch.md","hash":"ae1e68f1a91ec2730246b674f94273a5a46b4235","modified":1518245630933},{"_id":"source/_posts/canvas_1.md","hash":"1321aad6b65b194c07dadc9e0a73ce65767e7680","modified":1518245630937},{"_id":"source/_posts/fdbook.md","hash":"e069156d3df09a7f8bdec4b0d097e0fdcbd36d49","modified":1518245630939},{"_id":"source/_posts/git.md","hash":"2aa0f03423a38f038cc493ef7991a5ca5c6669d6","modified":1518245630940},{"_id":"source/_posts/hello-world.md","hash":"ff2e40bd0ed8985dbcf66cd1f7df50704585a605","modified":1518245630942},{"_id":"source/_posts/http.md","hash":"74229647a707ae05c613cb9f988c16ffb35d12c8","modified":1518245630944},{"_id":"source/_posts/java-reference.md","hash":"44cba8853fb8a66be222411ed627a6d4a6d47808","modified":1518245630945},{"_id":"source/_posts/lock.md","hash":"c0395e46ea86853d093e920561070a507d3cdc62","modified":1518245630947},{"_id":"source/_posts/matrix.md","hash":"8430dd1de9ea405fd5816c0464b3163068f78fb8","modified":1518245630949},{"_id":"source/_posts/memory-problem.md","hash":"9537a477d1648ba0bbaac7b738763b251cb04b2e","modified":1518250010611},{"_id":"source/_posts/optimization-ui.md","hash":"0874ee9b855c90b49446a8e666879fa495f17f3e","modified":1518245630950},{"_id":"source/_posts/recyclerview.md","hash":"174c20169ae27746beedec7bee9137a5e4be4005","modified":1518245630952},{"_id":"source/_posts/recyclerviewANM.md","hash":"86f308bd1b652a88a17171cc9ed7f155d92c442a","modified":1518245630954},{"_id":"source/_posts/threadPoolExecutor.md","hash":"ed0f22d0ab62e06aa761e554c40c7e524b5d05cd","modified":1518245630955},{"_id":"source/_posts/tip.md","hash":"47114f9c33b2de75ce17062fe32820e20567482c","modified":1518245630957},{"_id":"source/_posts/view-anm.md","hash":"034237e455f21c24f99dbbb4bb57f0691145bb38","modified":1518419650028},{"_id":"source/_posts/view-move.md","hash":"1330f93f6d58d00fbf75e2a26acfb1bdd20fb4af","modified":1518420981598},{"_id":"source/_posts/view.md","hash":"d07b86043c8d3f4594cb77ed487d8482daec8c86","modified":1518419050623},{"_id":"source/_posts/volatitle.md","hash":"961f37c958a3d14fae1d13daee06b4f655ee5536","modified":1518245630960},{"_id":"source/images/favicon.jpg","hash":"e3962f008c1a1fa5ca650d63dc926e15d9dfc484","modified":1518245630962},{"_id":"source/images/fd.jpg","hash":"37d29f858963c0ecb16944a4cf33288cc0d5b953","modified":1518245630964},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1518245631129},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1518245631131},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1518245631132},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1518245631135},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1518245631134},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1518245631138},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1518245631139},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1518245631188},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1518245631191},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1518245631190},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1518245631192},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1518245631194},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1518245631198},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1518245631199},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1518245631203},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1518245631275},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1518245631299},{"_id":"themes/yilia/source/slider.445162.js","hash":"a727717abfd319c5de84b425331f55aa709c9276","modified":1518245631308},{"_id":"themes/yilia/source/main.b3331d.js","hash":"5fcc25cc1650f4ebe5d29ac9744f6d2d3a8be677","modified":1518245631300},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"0873195fea8d34db7233dab3591d41558fb7388b","modified":1518245631306},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"61c95c49baa2c1bfd99cf88c55ba205b44bf3d97","modified":1518245631143},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1518245631144},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1518245631146},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"60351abd878c12b89761a91ff9e194f81443361f","modified":1518245631147},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"59564bb3371cf46a7ebc75383f8d81979c7bbba1","modified":1518245631151},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1518245631158},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"bac65acc10b1c5bae7ea1655e2d7839370c33110","modified":1518245631159},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1518245631162},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1518245631161},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1518245631164},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"e2b3f2b3631ef211a4d98d11f0da2d285340f10e","modified":1518245631165},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1518245631166},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1518245631168},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1518245631185},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1518245631187},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1518245631206},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1518245631207},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1518245631211},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1518245631212},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1518245631214},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1518245631209},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1518245631215},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"2d1c70bb606c0d87e4f68ec2e600e08b27f32b99","modified":1518245631217},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"768e77b775923c53f974a15fe9ab04d0e05198a5","modified":1518245631228},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1518245631237},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1518245631238},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1518245631240},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1518245631242},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1518245631249},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1518245631252},{"_id":"themes/yilia/source-src/css/main.scss","hash":"1bc3240d693f190f86bf5e258cc5846e09be9ec1","modified":1518245631251},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"7c24ea86d95c86b82337177559d78ce56d8912e0","modified":1518245631253},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1518245631257},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1518245631256},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1518245631258},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1518245631257},{"_id":"themes/yilia/source-src/css/social.scss","hash":"7c4c54bcc4cd0bd69162745ae2a2357dcc54f5cd","modified":1518245631258},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1518245631258},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1518245631259},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"6932c642bf8191768d7090982a91c8c1f1c4ed1e","modified":1518245631259},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1518245631261},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1518245631259},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1518245631260},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1518245631261},{"_id":"themes/yilia/source-src/js/fix.js","hash":"0b434b658abad220459b1e3ee962ebfa4f8f88ca","modified":1518245631263},{"_id":"themes/yilia/source-src/js/main.js","hash":"93ca570a646c6087821d7b14cb1646bb2a0274f4","modified":1518245631264},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1518245631268},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1518245631266},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1518245631273},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1518245631269},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1518245631271},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1518245631274},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1518245631279},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1518245631280},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1518245631287},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1518245631289},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1518245631290},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1518245631294},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1518245631292},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1518245631295},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1518245631297},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"eaa2c1cb8165dee6fb10127a0de8dcfcd1799c2e","modified":1518245631184},{"_id":"themes/yilia/layout/_partial/comments/disqus.ejs","hash":"2e5cad68bc59190b4158f4ab1879a222ca49a0d2","modified":1518245631153},{"_id":"themes/yilia/layout/_partial/comments/duoshuo.ejs","hash":"1f9ac8182fe0b867a8f1988888336c40c25894cd","modified":1518245631155},{"_id":"themes/yilia/layout/_partial/comments/youyan.ejs","hash":"0c462bc8920097320812908ef689be3e842287fc","modified":1518245631157},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1518245631170},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"0a3c55e2660a5c4c83a161fae21a4c0b7e6e5f72","modified":1518245631171},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1518245631173},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1518245631174},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1518245631176},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1518245631179},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1518245631177},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1518245631180},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"68d48a415ac4e675e73f660ee27bbaa8a06b1c11","modified":1518245631181},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1518245631219},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1518245631225},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1518245631222},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1518245631226},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1518245631221},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1518245631231},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1518245631233},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1518245631234},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1518245631236},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1518245631244},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1518245631246},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1518245631247},{"_id":"public/content.json","hash":"1561f3c064e54b0e25756a015ae3e29f0c2ebd4d","modified":1518421595049},{"_id":"public/2017/12/12/view-move/index.html","hash":"8d293a000c22cedff6fafadbdf2d212ed758fa7c","modified":1518421595598},{"_id":"public/2017/11/11/view-anm/index.html","hash":"0f42803cbe46026fc7193d4781432239ce394bfe","modified":1518421595598},{"_id":"public/2017/10/10/memory-problem/index.html","hash":"efe47b8d435ab327c7714d824169b8ffdc2bd137","modified":1518421595598},{"_id":"public/2017/09/23/android-touch/index.html","hash":"d4913304bc1bc8a2a374d13f53f9b35bb996ce60","modified":1518421595598},{"_id":"public/2017/09/17/tip/index.html","hash":"f3d0adf3d80487592730531d76198c453d559a12","modified":1518421595598},{"_id":"public/2017/08/27/Path/index.html","hash":"a5a06b2f459299e1a34bcd6288784fd728c3090a","modified":1518421595598},{"_id":"public/2017/08/27/optimization-ui/index.html","hash":"55891083d555c08fa4e6d43818362134e86c534a","modified":1518421595599},{"_id":"public/2017/06/04/recyclerviewANM/index.html","hash":"d8e78e709e27d58b1091cd1ba54d7a4a4385dd37","modified":1518421595599},{"_id":"public/2017/06/03/recyclerview/index.html","hash":"c3dded5346b4507c71fb6d31b2a3a517e07d09e9","modified":1518421595599},{"_id":"public/2017/05/22/canvas_1/index.html","hash":"0073472a1dd3ab1eec544ba4625b0371a9551fb2","modified":1518421595599},{"_id":"public/2017/05/22/Paint_shader/index.html","hash":"9088a7ec4cb787ac00a3379d6553dce0d73495b1","modified":1518421595599},{"_id":"public/2017/05/14/Paint/index.html","hash":"c6210328f566f0b2ccdff766e05d9ee121d49308","modified":1518421595599},{"_id":"public/2017/05/14/canvas/index.html","hash":"74f48bae9826b05e15b29ce2eb0cca2ba0b2930d","modified":1518421595599},{"_id":"public/2017/05/13/matrix/index.html","hash":"2b4af0277339c6d27089d03ad32899580a505dd8","modified":1518421595599},{"_id":"public/2017/05/13/git/index.html","hash":"a4def67b200263b9ed1e4bcba44e697ad649fffa","modified":1518421595599},{"_id":"public/2017/05/10/http/index.html","hash":"2a085b3338da0caaf14adb88add002086a3c9e06","modified":1518421595600},{"_id":"public/2017/05/14/view/index.html","hash":"7746b74c5246c4da75c648b795637ac44a0d46db","modified":1518421595600},{"_id":"public/2017/05/10/threadPoolExecutor/index.html","hash":"5988fc9e203a5ced108057ef6ec3e5a1be769efa","modified":1518421595600},{"_id":"public/2017/05/10/lock/index.html","hash":"5d72cd66beb78f8e5041c56652081d1343f869e1","modified":1518421595600},{"_id":"public/2017/05/09/fdbook/index.html","hash":"52c352072e8b2e8965b033b378c1e65a59570438","modified":1518421595601},{"_id":"public/2017/05/09/java-reference/index.html","hash":"bd9293861bc2862f29015fef84f1002cd32dd96f","modified":1518421595601},{"_id":"public/2017/05/10/volatitle/index.html","hash":"d15bf6d37933fa75d5b3762eafc5cc07cba669fd","modified":1518421595601},{"_id":"public/2017/05/09/hello-world/index.html","hash":"1cf9d13736de57f5c2d35de52a787c6e89858682","modified":1518421595601},{"_id":"public/archives/index.html","hash":"193ee840be781f613a5f702c42d93af3ae57bad0","modified":1518421595601},{"_id":"public/archives/page/2/index.html","hash":"c6644d8268428ff9c82bae913f76e46218e68763","modified":1518421595601},{"_id":"public/archives/page/3/index.html","hash":"5709236af2c087c7a9e50918a5bf9b13fa789ed7","modified":1518421595601},{"_id":"public/archives/page/4/index.html","hash":"1d43986e557e7c7538d308ab38877ee06e8c4e36","modified":1518421595601},{"_id":"public/archives/page/5/index.html","hash":"74541b47635688cf5e977a68e9edcb3b3a2be7d4","modified":1518421595601},{"_id":"public/archives/2017/index.html","hash":"fe9284dced6a3ea61f006aef51e712e45a25404f","modified":1518421595601},{"_id":"public/archives/2017/page/2/index.html","hash":"b56739f6bd0633cb609edc1c68088010ccac29e2","modified":1518421595602},{"_id":"public/archives/2017/page/3/index.html","hash":"41b25dd6926eb9986a97702072d925c57308f58f","modified":1518421595602},{"_id":"public/archives/2017/page/4/index.html","hash":"e23ccd46891c4a2a4b2636190e4e62ff6847005f","modified":1518421595602},{"_id":"public/archives/2017/page/5/index.html","hash":"9b4b46235c491e13ba43d3e84969e6c73675853a","modified":1518421595602},{"_id":"public/archives/2017/05/index.html","hash":"83880e117f22e5a73751b59569398867d5441866","modified":1518421595602},{"_id":"public/archives/2017/05/page/2/index.html","hash":"c094a3c4dd93d319a00b25c9d24bc380f644c7ba","modified":1518421595602},{"_id":"public/archives/2017/05/page/3/index.html","hash":"effd7ecfea9e3187f7256e0d36181a0911569e1b","modified":1518421595602},{"_id":"public/archives/2017/06/index.html","hash":"7a40098cd5c145f159759e35e3caf28d87d9254e","modified":1518421595603},{"_id":"public/archives/2017/08/index.html","hash":"e4fd496f702ebe6174dcbc5b192761b3af66e313","modified":1518421595603},{"_id":"public/archives/2017/09/index.html","hash":"a28659d4ce5f76402f1cc732bc7b34de40cd64ee","modified":1518421595603},{"_id":"public/archives/2017/10/index.html","hash":"e8926d447fbd94894637843af227bbe79125c723","modified":1518421595603},{"_id":"public/archives/2017/11/index.html","hash":"efd87553280810e33afd721e9187c4b8d72172a4","modified":1518421595603},{"_id":"public/archives/2017/12/index.html","hash":"5555c574dd0e44dcfc4fcd9c037ae7276bec39c4","modified":1518421595603},{"_id":"public/tags/自定义view/index.html","hash":"b15f38636fd994136b37e9c3603937cc16aeb5a4","modified":1518421595603},{"_id":"public/tags/自定义view/page/2/index.html","hash":"7519c8c13bd4115d84ac073c996fcc1c5c62fc71","modified":1518421595603},{"_id":"public/tags/paint/index.html","hash":"7859d2f796d8aa4ace57ee2a0efa6ae645fe80de","modified":1518421595603},{"_id":"public/tags/canvas/index.html","hash":"819db4ad00c661ee740c00c2658fcf1c8d083952","modified":1518421595604},{"_id":"public/tags/touch/index.html","hash":"476f797828533a62cbf861b9dcee8401abea0c9a","modified":1518421595604},{"_id":"public/tags/git/index.html","hash":"35896f65df34c5bd37b1763d3d8e28b5706fdde4","modified":1518421595604},{"_id":"public/tags/hexo/index.html","hash":"e3af6caeb7842d8ef1b6d0e520dd2204d0c42a76","modified":1518421595604},{"_id":"public/tags/java/index.html","hash":"1402402dd78897477c6e399e0b719e6df2078e5e","modified":1518421595604},{"_id":"public/tags/优化/index.html","hash":"7fab9c90d79afb7fa9b76763dffc15368157036b","modified":1518421595604},{"_id":"public/tags/matrix/index.html","hash":"96ef3518a493a0e476329cecdfa17e40aff3abcc","modified":1518421595604},{"_id":"public/tags/网络编程/index.html","hash":"90bed5d88772eb005b554d1059fc1c272a165804","modified":1518421595604},{"_id":"public/tags/recyclerview/index.html","hash":"d7b5bf89d9d0979f22d36cbe1ad01a1a46be9dd6","modified":1518421595605},{"_id":"public/tags/内存/index.html","hash":"36e20eadcebc4036441f48c498adffa01ef26fcf","modified":1518421595605},{"_id":"public/tags/多线程/index.html","hash":"a8b84fdcc005a1fb38f9099f5635d643082b6b4b","modified":1518421595605},{"_id":"public/tags/tip/index.html","hash":"0f5d19dba9f64d9d3b6bc4a1d4548aa970d40ccd","modified":1518421595605},{"_id":"public/tags/动画/index.html","hash":"3a4e8f865604d53d3154efea762aabb229a81e46","modified":1518421595605},{"_id":"public/tags/view/index.html","hash":"961afba3ad645974949992c130291313277abc2f","modified":1518421595605},{"_id":"public/index.html","hash":"c85d5f7e612470c3384a4fff6a019ca69c90a3c2","modified":1518421595605},{"_id":"public/page/2/index.html","hash":"c8bc5405f27b47a6a4a6f0a5f7e095b7d8351f03","modified":1518421595605},{"_id":"public/page/3/index.html","hash":"96ba66fee67fbfa3a0774b68df6ee10836805572","modified":1518421595605},{"_id":"public/page/4/index.html","hash":"12af161fb488996eee7c871662c13119af978d2a","modified":1518421595606},{"_id":"public/page/5/index.html","hash":"bc67f2b535ec369a0a047a8a4bf792bdd944d85c","modified":1518421595606},{"_id":"public/categories/android/index.html","hash":"52daa5d2d21ab9751321b8fa5273f34933aad0ec","modified":1518421595606},{"_id":"public/categories/android/page/2/index.html","hash":"22d1e36edd56c825628867e1780367f783f08a66","modified":1518421595606},{"_id":"public/categories/android/page/3/index.html","hash":"cc54bbc44a692035590d77f521a73121aa1ac91d","modified":1518421595606},{"_id":"public/categories/android/page/4/index.html","hash":"fef3c4884746251ca08c9f4fa348627bd918dab2","modified":1518421595607},{"_id":"public/categories/fdbook/index.html","hash":"8ea8fe81e22a33c0d58954a3df59b2f5c4a53818","modified":1518421595607},{"_id":"public/categories/多学/index.html","hash":"39c44a97d553e54ca98325a3ae98df3c06bb272b","modified":1518421595607},{"_id":"public/images/favicon.jpg","hash":"e3962f008c1a1fa5ca650d63dc926e15d9dfc484","modified":1518421595612},{"_id":"public/images/fd.jpg","hash":"37d29f858963c0ecb16944a4cf33288cc0d5b953","modified":1518421595612},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1518421595612},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1518421595612},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1518421595612},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1518421595612},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1518421595612},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1518421595612},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1518421595612},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1518421595612},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1518421595613},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1518421595629},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1518421595629},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1518421595629},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1518421595629}],"Category":[{"name":"android","_id":"cjdjx0ga90002o4l1y1tm8z7e"},{"name":"fdbook","_id":"cjdjx0gb6000jo4l1rnio773b"},{"name":"多学","_id":"cjdjx0gbd000ro4l1bc9csca3"}],"Data":[],"Page":[],"Post":[{"title":"Paint 详解","date":"2017-05-14T07:22:26.000Z","_content":"\n## api合集\n``` bash\nvoid reset();\nvoid set(Paint src);\nvoid setCompatibilityScaling(float factor);\nvoid setBidiFlags(int flags);\nvoid setFlags(int flags);\nvoid setHinting(int mode);\n//是否抗锯齿\nvoid setAntiAlias(boolean aa);\n//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  \nvoid setDither(boolean dither);\n//设置线性文本\nvoid setLinearText(boolean linearText);\n//设置该项为true，将有助于文本在LCD屏幕上的显示效果  \nvoid setSubpixelText(boolean subpixelText);\n//设置下划线\nvoid setUnderlineText(boolean underlineText);\n//设置带有删除线的效果 \nvoid setStrikeThruText(boolean strikeThruText);\n//设置伪粗体文本，设置在小字体上效果会非常差  \nvoid setFakeBoldText(boolean fakeBoldText);\n//如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作\n//加快显示速度，本设置项依赖于dither和xfermode的设置  \nvoid setFilterBitmap(boolean filter);\n//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE\n//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  \nvoid setStyle(Style style);\n //设置颜色值\nvoid setColor(int color);\n//设置透明图0~255，要在setColor后面设置才生效\nvoid setAlpha(int a);   \n//设置RGB及透明度\nvoid setARGB(int a, int r, int g, int b);  \n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  \nvoid setStrokeWidth(float width);\nvoid setStrokeMiter(float miter);\n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式\nvoid setStrokeCap(Cap cap);\n//设置绘制时各图形的结合方式，如平滑效果等  \nvoid setStrokeJoin(Join join);\n//设置图像效果，使用Shader可以绘制出各种渐变效果  \nShader setShader(Shader shader);\n//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 \nColorFilter setColorFilter(ColorFilter filter);\n//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 \nXfermode setXfermode(Xfermode xfermode);\n//设置绘制路径的效果，如点画线等 \nPathEffect setPathEffect(PathEffect effect);\n//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  \nMaskFilter setMaskFilter(MaskFilter maskfilter);\n//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  \nTypeface setTypeface(Typeface typeface);\n//设置光栅化\nRasterizer setRasterizer(Rasterizer rasterizer);\n//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色\n//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\nvoid setShadowLayer(float radius, float dx, float dy, int color);\n//设置文本对齐\nvoid setTextAlign(Align align);\n//设置字体大小\nvoid setTextSize(float textSize);\n//设置文本缩放倍数，1.0f为原始\nvoid setTextScaleX(float scaleX);\n//设置斜体文字，skewX为倾斜弧度  \nvoid setTextSkewX(float skewX);\n//下面几个就是测量字体的长度了\nmeasureText(String text)，measureText(CharSequence text, int start, int end)\n//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高\ngetTextBounds(String text, int start, int end, Rect bounds) \n```\n<!-- more -->\n\n## 挑几个说说\n\nsetStyle()\nPaint.Style.FILL：填充内部\nPaint.Style.FILL_AND_STROKE  ：填充内部和描边\nPaint.Style.STROKE  ：描边\n\nsetStrokeCap()\nPaint.Cap.ROUND :\nPaint.Cap.SQUARE :\nPaint.Cap.BUTT :\n![](http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png)\n\nsetStrokeJoin()\nPaint.Join.ROUND :\nPaint.Join.BEVEL :\nPaint.Join.MITER :\n![](http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png)\n\n### PorterDuffXfermode : Paint.setXfermode(xfermode)\n图片混合模式，十分实用的api\n``` bash\nprivate static final Xfermode[] sModes = {\n    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼\n    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) };   //显示持有图像，重合的会变白\n```\n上个小例子,画一个带有白色边的黄色实心小圆\n``` bash\n\n```\n\n","source":"_posts/Paint.md","raw":"---\ntitle: Paint 详解\ndate: 2017-05-14 15:22:26\ncategories: android\ntags: [自定义view,paint]\n---\n\n## api合集\n``` bash\nvoid reset();\nvoid set(Paint src);\nvoid setCompatibilityScaling(float factor);\nvoid setBidiFlags(int flags);\nvoid setFlags(int flags);\nvoid setHinting(int mode);\n//是否抗锯齿\nvoid setAntiAlias(boolean aa);\n//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  \nvoid setDither(boolean dither);\n//设置线性文本\nvoid setLinearText(boolean linearText);\n//设置该项为true，将有助于文本在LCD屏幕上的显示效果  \nvoid setSubpixelText(boolean subpixelText);\n//设置下划线\nvoid setUnderlineText(boolean underlineText);\n//设置带有删除线的效果 \nvoid setStrikeThruText(boolean strikeThruText);\n//设置伪粗体文本，设置在小字体上效果会非常差  \nvoid setFakeBoldText(boolean fakeBoldText);\n//如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作\n//加快显示速度，本设置项依赖于dither和xfermode的设置  \nvoid setFilterBitmap(boolean filter);\n//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE\n//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  \nvoid setStyle(Style style);\n //设置颜色值\nvoid setColor(int color);\n//设置透明图0~255，要在setColor后面设置才生效\nvoid setAlpha(int a);   \n//设置RGB及透明度\nvoid setARGB(int a, int r, int g, int b);  \n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  \nvoid setStrokeWidth(float width);\nvoid setStrokeMiter(float miter);\n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式\nvoid setStrokeCap(Cap cap);\n//设置绘制时各图形的结合方式，如平滑效果等  \nvoid setStrokeJoin(Join join);\n//设置图像效果，使用Shader可以绘制出各种渐变效果  \nShader setShader(Shader shader);\n//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 \nColorFilter setColorFilter(ColorFilter filter);\n//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 \nXfermode setXfermode(Xfermode xfermode);\n//设置绘制路径的效果，如点画线等 \nPathEffect setPathEffect(PathEffect effect);\n//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  \nMaskFilter setMaskFilter(MaskFilter maskfilter);\n//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  \nTypeface setTypeface(Typeface typeface);\n//设置光栅化\nRasterizer setRasterizer(Rasterizer rasterizer);\n//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色\n//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\nvoid setShadowLayer(float radius, float dx, float dy, int color);\n//设置文本对齐\nvoid setTextAlign(Align align);\n//设置字体大小\nvoid setTextSize(float textSize);\n//设置文本缩放倍数，1.0f为原始\nvoid setTextScaleX(float scaleX);\n//设置斜体文字，skewX为倾斜弧度  \nvoid setTextSkewX(float skewX);\n//下面几个就是测量字体的长度了\nmeasureText(String text)，measureText(CharSequence text, int start, int end)\n//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高\ngetTextBounds(String text, int start, int end, Rect bounds) \n```\n<!-- more -->\n\n## 挑几个说说\n\nsetStyle()\nPaint.Style.FILL：填充内部\nPaint.Style.FILL_AND_STROKE  ：填充内部和描边\nPaint.Style.STROKE  ：描边\n\nsetStrokeCap()\nPaint.Cap.ROUND :\nPaint.Cap.SQUARE :\nPaint.Cap.BUTT :\n![](http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png)\n\nsetStrokeJoin()\nPaint.Join.ROUND :\nPaint.Join.BEVEL :\nPaint.Join.MITER :\n![](http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png)\n\n### PorterDuffXfermode : Paint.setXfermode(xfermode)\n图片混合模式，十分实用的api\n``` bash\nprivate static final Xfermode[] sModes = {\n    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼\n    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) };   //显示持有图像，重合的会变白\n```\n上个小例子,画一个带有白色边的黄色实心小圆\n``` bash\n\n```\n\n","slug":"Paint","published":1,"updated":"2018-02-10T06:53:50.929Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0ga00000o4l1ho6141tz","content":"<h2 id=\"api合集\"><a href=\"#api合集\" class=\"headerlink\" title=\"api合集\"></a>api合集</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">void reset();</div><div class=\"line\">void <span class=\"built_in\">set</span>(Paint src);</div><div class=\"line\">void <span class=\"built_in\">set</span>CompatibilityScaling(<span class=\"built_in\">float</span> factor);</div><div class=\"line\">void <span class=\"built_in\">set</span>BidiFlags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Flags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Hinting(int mode);</div><div class=\"line\">//是否抗锯齿</div><div class=\"line\">void <span class=\"built_in\">set</span>AntiAlias(boolean aa);</div><div class=\"line\">//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  </div><div class=\"line\">void <span class=\"built_in\">set</span>Dither(boolean dither);</div><div class=\"line\">//设置线性文本</div><div class=\"line\">void <span class=\"built_in\">set</span>LinearText(boolean linearText);</div><div class=\"line\">//设置该项为<span class=\"literal\">true</span>，将有助于文本在LCD屏幕上的显示效果  </div><div class=\"line\">void <span class=\"built_in\">set</span>SubpixelText(boolean subpixelText);</div><div class=\"line\">//设置下划线</div><div class=\"line\">void <span class=\"built_in\">set</span>UnderlineText(boolean underlineText);</div><div class=\"line\">//设置带有删除线的效果 </div><div class=\"line\">void <span class=\"built_in\">set</span>StrikeThruText(boolean strikeThruText);</div><div class=\"line\">//设置伪粗体文本，设置在小字体上效果会非常差  </div><div class=\"line\">void <span class=\"built_in\">set</span>FakeBoldText(boolean fakeBoldText);</div><div class=\"line\">//如果该项设置为<span class=\"literal\">true</span>，则图像在动画进行中会滤掉对Bitmap图像的优化操作</div><div class=\"line\">//加快显示速度，本设置项依赖于dither和xfermode的设置  </div><div class=\"line\">void <span class=\"built_in\">set</span>FilterBitmap(boolean filter);</div><div class=\"line\">//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE</div><div class=\"line\">//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  </div><div class=\"line\">void <span class=\"built_in\">set</span>Style(Style style);</div><div class=\"line\"> //设置颜色值</div><div class=\"line\">void <span class=\"built_in\">set</span>Color(int color);</div><div class=\"line\">//设置透明图0~255，要在<span class=\"built_in\">set</span>Color后面设置才生效</div><div class=\"line\">void <span class=\"built_in\">set</span>Alpha(int a);   </div><div class=\"line\">//设置RGB及透明度</div><div class=\"line\">void <span class=\"built_in\">set</span>ARGB(int a, int r, int g, int b);  </div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeWidth(<span class=\"built_in\">float</span> width);</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeMiter(<span class=\"built_in\">float</span> miter);</div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeCap(Cap <span class=\"built_in\">cap</span>);</div><div class=\"line\">//设置绘制时各图形的结合方式，如平滑效果等  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeJoin(Join join);</div><div class=\"line\">//设置图像效果，使用Shader可以绘制出各种渐变效果  </div><div class=\"line\">Shader <span class=\"built_in\">set</span>Shader(Shader shader);</div><div class=\"line\">//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 </div><div class=\"line\">ColorFilter <span class=\"built_in\">set</span>ColorFilter(ColorFilter filter);</div><div class=\"line\">//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 </div><div class=\"line\">Xfermode <span class=\"built_in\">set</span>Xfermode(Xfermode xfermode);</div><div class=\"line\">//设置绘制路径的效果，如点画线等 </div><div class=\"line\">PathEffect <span class=\"built_in\">set</span>PathEffect(PathEffect effect);</div><div class=\"line\">//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  </div><div class=\"line\">MaskFilter <span class=\"built_in\">set</span>MaskFilter(MaskFilter maskfilter);</div><div class=\"line\">//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  </div><div class=\"line\">Typeface <span class=\"built_in\">set</span>Typeface(Typeface typeface);</div><div class=\"line\">//设置光栅化</div><div class=\"line\">Rasterizer <span class=\"built_in\">set</span>Rasterizer(Rasterizer rasterizer);</div><div class=\"line\">//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色</div><div class=\"line\">//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class=\"line\">void <span class=\"built_in\">set</span>ShadowLayer(<span class=\"built_in\">float</span> radius, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy, int color);</div><div class=\"line\">//设置文本对齐</div><div class=\"line\">void <span class=\"built_in\">set</span>TextAlign(Align align);</div><div class=\"line\">//设置字体大小</div><div class=\"line\">void <span class=\"built_in\">set</span>TextSize(<span class=\"built_in\">float</span> textSize);</div><div class=\"line\">//设置文本缩放倍数，1.0f为原始</div><div class=\"line\">void <span class=\"built_in\">set</span>TextScaleX(<span class=\"built_in\">float</span> scaleX);</div><div class=\"line\">//设置斜体文字，skewX为倾斜弧度  </div><div class=\"line\">void <span class=\"built_in\">set</span>TextSkewX(<span class=\"built_in\">float</span> skewX);</div><div class=\"line\">//下面几个就是测量字体的长度了</div><div class=\"line\">measureText(String text)，measureText(CharSequence text, int start, int end)</div><div class=\"line\">//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</div><div class=\"line\">getTextBounds(String text, int start, int end, Rect bounds)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"挑几个说说\"><a href=\"#挑几个说说\" class=\"headerlink\" title=\"挑几个说说\"></a>挑几个说说</h2><p>setStyle()<br>Paint.Style.FILL：填充内部<br>Paint.Style.FILL_AND_STROKE  ：填充内部和描边<br>Paint.Style.STROKE  ：描边</p>\n<p>setStrokeCap()<br>Paint.Cap.ROUND :<br>Paint.Cap.SQUARE :<br>Paint.Cap.BUTT :<br><img src=\"http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png\" alt=\"\"></p>\n<p>setStrokeJoin()<br>Paint.Join.ROUND :<br>Paint.Join.BEVEL :<br>Paint.Join.MITER :<br><img src=\"http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png\" alt=\"\"></p>\n<h3 id=\"PorterDuffXfermode-Paint-setXfermode-xfermode\"><a href=\"#PorterDuffXfermode-Paint-setXfermode-xfermode\" class=\"headerlink\" title=\"PorterDuffXfermode : Paint.setXfermode(xfermode)\"></a>PorterDuffXfermode : Paint.setXfermode(xfermode)</h3><p>图片混合模式，十分实用的api<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final Xfermode[] sModes = &#123;</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) &#125;;   //显示持有图像，重合的会变白</div></pre></td></tr></table></figure></p>\n<p>上个小例子,画一个带有白色边的黄色实心小圆<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"api合集\"><a href=\"#api合集\" class=\"headerlink\" title=\"api合集\"></a>api合集</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">void reset();</div><div class=\"line\">void <span class=\"built_in\">set</span>(Paint src);</div><div class=\"line\">void <span class=\"built_in\">set</span>CompatibilityScaling(<span class=\"built_in\">float</span> factor);</div><div class=\"line\">void <span class=\"built_in\">set</span>BidiFlags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Flags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Hinting(int mode);</div><div class=\"line\">//是否抗锯齿</div><div class=\"line\">void <span class=\"built_in\">set</span>AntiAlias(boolean aa);</div><div class=\"line\">//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  </div><div class=\"line\">void <span class=\"built_in\">set</span>Dither(boolean dither);</div><div class=\"line\">//设置线性文本</div><div class=\"line\">void <span class=\"built_in\">set</span>LinearText(boolean linearText);</div><div class=\"line\">//设置该项为<span class=\"literal\">true</span>，将有助于文本在LCD屏幕上的显示效果  </div><div class=\"line\">void <span class=\"built_in\">set</span>SubpixelText(boolean subpixelText);</div><div class=\"line\">//设置下划线</div><div class=\"line\">void <span class=\"built_in\">set</span>UnderlineText(boolean underlineText);</div><div class=\"line\">//设置带有删除线的效果 </div><div class=\"line\">void <span class=\"built_in\">set</span>StrikeThruText(boolean strikeThruText);</div><div class=\"line\">//设置伪粗体文本，设置在小字体上效果会非常差  </div><div class=\"line\">void <span class=\"built_in\">set</span>FakeBoldText(boolean fakeBoldText);</div><div class=\"line\">//如果该项设置为<span class=\"literal\">true</span>，则图像在动画进行中会滤掉对Bitmap图像的优化操作</div><div class=\"line\">//加快显示速度，本设置项依赖于dither和xfermode的设置  </div><div class=\"line\">void <span class=\"built_in\">set</span>FilterBitmap(boolean filter);</div><div class=\"line\">//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE</div><div class=\"line\">//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  </div><div class=\"line\">void <span class=\"built_in\">set</span>Style(Style style);</div><div class=\"line\"> //设置颜色值</div><div class=\"line\">void <span class=\"built_in\">set</span>Color(int color);</div><div class=\"line\">//设置透明图0~255，要在<span class=\"built_in\">set</span>Color后面设置才生效</div><div class=\"line\">void <span class=\"built_in\">set</span>Alpha(int a);   </div><div class=\"line\">//设置RGB及透明度</div><div class=\"line\">void <span class=\"built_in\">set</span>ARGB(int a, int r, int g, int b);  </div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeWidth(<span class=\"built_in\">float</span> width);</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeMiter(<span class=\"built_in\">float</span> miter);</div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeCap(Cap <span class=\"built_in\">cap</span>);</div><div class=\"line\">//设置绘制时各图形的结合方式，如平滑效果等  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeJoin(Join join);</div><div class=\"line\">//设置图像效果，使用Shader可以绘制出各种渐变效果  </div><div class=\"line\">Shader <span class=\"built_in\">set</span>Shader(Shader shader);</div><div class=\"line\">//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 </div><div class=\"line\">ColorFilter <span class=\"built_in\">set</span>ColorFilter(ColorFilter filter);</div><div class=\"line\">//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 </div><div class=\"line\">Xfermode <span class=\"built_in\">set</span>Xfermode(Xfermode xfermode);</div><div class=\"line\">//设置绘制路径的效果，如点画线等 </div><div class=\"line\">PathEffect <span class=\"built_in\">set</span>PathEffect(PathEffect effect);</div><div class=\"line\">//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  </div><div class=\"line\">MaskFilter <span class=\"built_in\">set</span>MaskFilter(MaskFilter maskfilter);</div><div class=\"line\">//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  </div><div class=\"line\">Typeface <span class=\"built_in\">set</span>Typeface(Typeface typeface);</div><div class=\"line\">//设置光栅化</div><div class=\"line\">Rasterizer <span class=\"built_in\">set</span>Rasterizer(Rasterizer rasterizer);</div><div class=\"line\">//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色</div><div class=\"line\">//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class=\"line\">void <span class=\"built_in\">set</span>ShadowLayer(<span class=\"built_in\">float</span> radius, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy, int color);</div><div class=\"line\">//设置文本对齐</div><div class=\"line\">void <span class=\"built_in\">set</span>TextAlign(Align align);</div><div class=\"line\">//设置字体大小</div><div class=\"line\">void <span class=\"built_in\">set</span>TextSize(<span class=\"built_in\">float</span> textSize);</div><div class=\"line\">//设置文本缩放倍数，1.0f为原始</div><div class=\"line\">void <span class=\"built_in\">set</span>TextScaleX(<span class=\"built_in\">float</span> scaleX);</div><div class=\"line\">//设置斜体文字，skewX为倾斜弧度  </div><div class=\"line\">void <span class=\"built_in\">set</span>TextSkewX(<span class=\"built_in\">float</span> skewX);</div><div class=\"line\">//下面几个就是测量字体的长度了</div><div class=\"line\">measureText(String text)，measureText(CharSequence text, int start, int end)</div><div class=\"line\">//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</div><div class=\"line\">getTextBounds(String text, int start, int end, Rect bounds)</div></pre></td></tr></table></figure>","more":"<h2 id=\"挑几个说说\"><a href=\"#挑几个说说\" class=\"headerlink\" title=\"挑几个说说\"></a>挑几个说说</h2><p>setStyle()<br>Paint.Style.FILL：填充内部<br>Paint.Style.FILL_AND_STROKE  ：填充内部和描边<br>Paint.Style.STROKE  ：描边</p>\n<p>setStrokeCap()<br>Paint.Cap.ROUND :<br>Paint.Cap.SQUARE :<br>Paint.Cap.BUTT :<br><img src=\"http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png\" alt=\"\"></p>\n<p>setStrokeJoin()<br>Paint.Join.ROUND :<br>Paint.Join.BEVEL :<br>Paint.Join.MITER :<br><img src=\"http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png\" alt=\"\"></p>\n<h3 id=\"PorterDuffXfermode-Paint-setXfermode-xfermode\"><a href=\"#PorterDuffXfermode-Paint-setXfermode-xfermode\" class=\"headerlink\" title=\"PorterDuffXfermode : Paint.setXfermode(xfermode)\"></a>PorterDuffXfermode : Paint.setXfermode(xfermode)</h3><p>图片混合模式，十分实用的api<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final Xfermode[] sModes = &#123;</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) &#125;;   //显示持有图像，重合的会变白</div></pre></td></tr></table></figure></p>\n<p>上个小例子,画一个带有白色边的黄色实心小圆<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>"},{"title":"Path","date":"2017-08-27T07:13:51.000Z","_content":"\n## whant is path\n\nPath封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，\n也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)\n\n<!-- more -->\n\n## api\n\n|作用\t\t  \t\t|相关方法\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t| :----: |\n|移动起点\t  \t\t|moveTo\t\t        |移动下一次操作的起点位置\n|设置终点\t  \t\t|setLastPoint\t\t|重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同\n|连接直线\t  \t\t|lineTo\t\t\t\t|添加上一个点到当前点之间的直线到Path\n|闭合路径\t  \t\t|close\t\t\t\t|连接第一个点连接到最后一个点，形成一个闭合区域\n|添加内容\t  \t\t|addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo  |添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)\n|是否为空\t  \t\t|isEmpty\t\t\t|判断Path是否为空\n|是否为矩形\t  \t\t|isRect\t\t\t\t|判断path是否是一个矩形\n|替换路径\t  \t\t|set\t\t\t\t|用新的路径替换到当前路径所有内容\n|偏移路径\t  \t\t|offset\t\t\t\t|对当前路径之前的操作进行偏移(不会影响之后的操作)\n|贝塞尔曲线\t  \t\t|quadTo, cubicTo\t|分别为二次和三次贝塞尔曲线的方法\n|rXxx方法\t  \t\t|rMoveTo, rLineTo, rQuadTo, rCubicTo\t\t\t\t\t\t\t\t|不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)\n|填充模式\t  \t\t|setFillType, getFillType, isInverseFillType, toggleInverseFillType |设置,获取,判断和切换填充模式\n|提示方法\t  \t\t|incReserve\t\t\t|提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)\n|布尔操作(API19)\t|op\t\t\t\t\t|对两个Path进行布尔运算(即取交集、并集等操作)\n|计算边界\t        |computeBounds\t\t|计算Path的边界\n|重置路径\t        |reset, rewind\t\t|清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType\n|矩阵操作\t\t\t|transform\t\t\t|矩阵变换\n\n## moveTo 和 setLastPoint\n\nmoveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点\n\n## addXxx与arcTo\n\n``` bash\n// 第一类(基本形状)\n// 圆形\npublic void addCircle (float x, float y, float radius, Path.Direction dir)\n// 椭圆\npublic void addOval (RectF oval, Path.Direction dir)\n// 矩形\npublic void addRect (float left, float top, float right, float bottom, Path.Direction dir)\npublic void addRect (RectF rect, Path.Direction dir)\n// 圆角矩形\npublic void addRoundRect (RectF rect, float[] radii, Path.Direction dir)\npublic void addRoundRect (RectF rect, float rx, float ry, Path.Direction dir) \n\n// 第二类(Path)\n// path\npublic void addPath (Path src)\npublic void addPath (Path src, float dx, float dy)\npublic void addPath (Path src, Matrix matrix)\n\naddArc\t添加一个圆弧到path\t直接添加一个圆弧到path中\narcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点\n```\n\n## rXxx\n\nrXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。\n比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ， \n使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示\n\n## 贝塞尔曲线\n\n数据点\t确定曲线的起始和结束位置\n控制点\t确定曲线的弯曲程度\n\n一阶曲线其实就是前面讲解过的lineTo\n二阶曲线对应的方法是quadTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835406060)\n三阶曲线对应的方法是cubicTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835375418)\n\n## PathMeasure\n\n### api\n\n| 返回值\t|方法名\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|释义\n| --------  | \t-----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n| void\t\t|setPath(Path path, boolean forceClosed)\t\t\t\t\t\t\t\t\t|关联一个Path\n| boolean\t|isClosed()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|是否闭合\n| float\t\t|getLength()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|获取Path的长度\n| boolean\t|nextContour()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|跳转到下一个轮廓\n| boolean\t|getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)\t|截取片段\n| boolean\t|getPosTan(float distance, float[] pos, float[] tan)\t\t\t\t\t\t|获取指定长度的位置坐标及该点切线值\n| boolean\t|getMatrix(float distance, Matrix matrix, int flags)\t\t\t\t\t\t|获取指定长度的位置坐标及该点Matrix\n\n### 构造函数\n\n``` bash\nPathMeasure ()\nPathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 true,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)\n```\n\n### getSegment\n\n``` bash\nboolean getSegment (float startD, float stopD, Path dst, boolean startWithMoveTo)\n```\n\n|参数\t\t\t\t|作用\t\t\t\t\t\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t\t\t\t\t| :----: |\n|返回值(boolean)\t|判断截取是否成功\t\t\t\t\t|true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容\n|startD\t\t\t\t|开始截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|stopD\t\t\t\t|结束截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|dst\t\t\t\t|截取的 Path 将会添加到 dst 中\t\t|注意: 是添加，而不是替换\n|startWithMoveTo\t|起始点是否使用 moveTo\t\t\t\t|用于保证截取的 Path 第一个点位置不变\n\n### nextContour\n\n我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，\n而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。\n\n## FillType \n\n|模式\t\t\t\t|简介\n| --------  \t\t| :----: |  \t\t\t\t\t\t\n|EVEN_ODD\t\t\t|奇偶规则\n|INVERSE_EVEN_ODD\t|反奇偶规则\n|WINDING\t\t\t|非零环绕数规则\n|INVERSE_WINDING\t|反非零环绕数规则\n\n## 布尔操作\n\n|逻辑名称\t\t\t\t|类比\t\t|说明\t\n| --------  \t\t\t| \t-----:  | :----: |\n|DIFFERENCE\t\t\t\t|差集\t\t|Path1中减去Path2后剩下的部分\t\n|REVERSE_DIFFERENCE\t\t|差集\t\t|Path2中减去Path1后剩下的部分\t\n|INTERSECT\t\t\t\t|交集\t\t|Path1与Path2相交的部分\t\n|UNION\t\t\t\t\t|并集\t\t|包含全部Path1和Path2\t\n|XOR\t\t\t\t\t|异或\t\t|包含Path1与Path2但不包括两者相交的部分\n\t\n``` bash\n 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。\npath1.op(path2, Path.Op.DIFFERENCE);\n\n// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。\npath3.op(path1, path2, Path.Op.DIFFERENCE)\n\n这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：\nvoid computeBounds (RectF bounds, boolean exact)\n```\n\n\n","source":"_posts/Path.md","raw":"---\ntitle: Path\ndate: 2017-08-27 15:13:51\ntags: 自定义view\ncategories: android\n---\n\n## whant is path\n\nPath封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，\n也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)\n\n<!-- more -->\n\n## api\n\n|作用\t\t  \t\t|相关方法\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t| :----: |\n|移动起点\t  \t\t|moveTo\t\t        |移动下一次操作的起点位置\n|设置终点\t  \t\t|setLastPoint\t\t|重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同\n|连接直线\t  \t\t|lineTo\t\t\t\t|添加上一个点到当前点之间的直线到Path\n|闭合路径\t  \t\t|close\t\t\t\t|连接第一个点连接到最后一个点，形成一个闭合区域\n|添加内容\t  \t\t|addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo  |添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)\n|是否为空\t  \t\t|isEmpty\t\t\t|判断Path是否为空\n|是否为矩形\t  \t\t|isRect\t\t\t\t|判断path是否是一个矩形\n|替换路径\t  \t\t|set\t\t\t\t|用新的路径替换到当前路径所有内容\n|偏移路径\t  \t\t|offset\t\t\t\t|对当前路径之前的操作进行偏移(不会影响之后的操作)\n|贝塞尔曲线\t  \t\t|quadTo, cubicTo\t|分别为二次和三次贝塞尔曲线的方法\n|rXxx方法\t  \t\t|rMoveTo, rLineTo, rQuadTo, rCubicTo\t\t\t\t\t\t\t\t|不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)\n|填充模式\t  \t\t|setFillType, getFillType, isInverseFillType, toggleInverseFillType |设置,获取,判断和切换填充模式\n|提示方法\t  \t\t|incReserve\t\t\t|提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)\n|布尔操作(API19)\t|op\t\t\t\t\t|对两个Path进行布尔运算(即取交集、并集等操作)\n|计算边界\t        |computeBounds\t\t|计算Path的边界\n|重置路径\t        |reset, rewind\t\t|清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType\n|矩阵操作\t\t\t|transform\t\t\t|矩阵变换\n\n## moveTo 和 setLastPoint\n\nmoveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点\n\n## addXxx与arcTo\n\n``` bash\n// 第一类(基本形状)\n// 圆形\npublic void addCircle (float x, float y, float radius, Path.Direction dir)\n// 椭圆\npublic void addOval (RectF oval, Path.Direction dir)\n// 矩形\npublic void addRect (float left, float top, float right, float bottom, Path.Direction dir)\npublic void addRect (RectF rect, Path.Direction dir)\n// 圆角矩形\npublic void addRoundRect (RectF rect, float[] radii, Path.Direction dir)\npublic void addRoundRect (RectF rect, float rx, float ry, Path.Direction dir) \n\n// 第二类(Path)\n// path\npublic void addPath (Path src)\npublic void addPath (Path src, float dx, float dy)\npublic void addPath (Path src, Matrix matrix)\n\naddArc\t添加一个圆弧到path\t直接添加一个圆弧到path中\narcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点\n```\n\n## rXxx\n\nrXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。\n比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ， \n使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示\n\n## 贝塞尔曲线\n\n数据点\t确定曲线的起始和结束位置\n控制点\t确定曲线的弯曲程度\n\n一阶曲线其实就是前面讲解过的lineTo\n二阶曲线对应的方法是quadTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835406060)\n三阶曲线对应的方法是cubicTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835375418)\n\n## PathMeasure\n\n### api\n\n| 返回值\t|方法名\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|释义\n| --------  | \t-----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n| void\t\t|setPath(Path path, boolean forceClosed)\t\t\t\t\t\t\t\t\t|关联一个Path\n| boolean\t|isClosed()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|是否闭合\n| float\t\t|getLength()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|获取Path的长度\n| boolean\t|nextContour()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|跳转到下一个轮廓\n| boolean\t|getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)\t|截取片段\n| boolean\t|getPosTan(float distance, float[] pos, float[] tan)\t\t\t\t\t\t|获取指定长度的位置坐标及该点切线值\n| boolean\t|getMatrix(float distance, Matrix matrix, int flags)\t\t\t\t\t\t|获取指定长度的位置坐标及该点Matrix\n\n### 构造函数\n\n``` bash\nPathMeasure ()\nPathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 true,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)\n```\n\n### getSegment\n\n``` bash\nboolean getSegment (float startD, float stopD, Path dst, boolean startWithMoveTo)\n```\n\n|参数\t\t\t\t|作用\t\t\t\t\t\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t\t\t\t\t| :----: |\n|返回值(boolean)\t|判断截取是否成功\t\t\t\t\t|true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容\n|startD\t\t\t\t|开始截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|stopD\t\t\t\t|结束截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|dst\t\t\t\t|截取的 Path 将会添加到 dst 中\t\t|注意: 是添加，而不是替换\n|startWithMoveTo\t|起始点是否使用 moveTo\t\t\t\t|用于保证截取的 Path 第一个点位置不变\n\n### nextContour\n\n我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，\n而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。\n\n## FillType \n\n|模式\t\t\t\t|简介\n| --------  \t\t| :----: |  \t\t\t\t\t\t\n|EVEN_ODD\t\t\t|奇偶规则\n|INVERSE_EVEN_ODD\t|反奇偶规则\n|WINDING\t\t\t|非零环绕数规则\n|INVERSE_WINDING\t|反非零环绕数规则\n\n## 布尔操作\n\n|逻辑名称\t\t\t\t|类比\t\t|说明\t\n| --------  \t\t\t| \t-----:  | :----: |\n|DIFFERENCE\t\t\t\t|差集\t\t|Path1中减去Path2后剩下的部分\t\n|REVERSE_DIFFERENCE\t\t|差集\t\t|Path2中减去Path1后剩下的部分\t\n|INTERSECT\t\t\t\t|交集\t\t|Path1与Path2相交的部分\t\n|UNION\t\t\t\t\t|并集\t\t|包含全部Path1和Path2\t\n|XOR\t\t\t\t\t|异或\t\t|包含Path1与Path2但不包括两者相交的部分\n\t\n``` bash\n 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。\npath1.op(path2, Path.Op.DIFFERENCE);\n\n// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。\npath3.op(path1, path2, Path.Op.DIFFERENCE)\n\n这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：\nvoid computeBounds (RectF bounds, boolean exact)\n```\n\n\n","slug":"Path","published":1,"updated":"2018-02-10T06:53:50.932Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0ga60001o4l1idl16mlg","content":"<h2 id=\"whant-is-path\"><a href=\"#whant-is-path\" class=\"headerlink\" title=\"whant is path\"></a>whant is path</h2><p>Path封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，<br>也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)</p>\n<a id=\"more\"></a>\n<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><table>\n<thead>\n<tr>\n<th>作用</th>\n<th style=\"text-align:right\">相关方法</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移动起点</td>\n<td style=\"text-align:right\">moveTo</td>\n<td style=\"text-align:center\">移动下一次操作的起点位置</td>\n</tr>\n<tr>\n<td>设置终点</td>\n<td style=\"text-align:right\">setLastPoint</td>\n<td style=\"text-align:center\">重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同</td>\n</tr>\n<tr>\n<td>连接直线</td>\n<td style=\"text-align:right\">lineTo</td>\n<td style=\"text-align:center\">添加上一个点到当前点之间的直线到Path</td>\n</tr>\n<tr>\n<td>闭合路径</td>\n<td style=\"text-align:right\">close</td>\n<td style=\"text-align:center\">连接第一个点连接到最后一个点，形成一个闭合区域</td>\n</tr>\n<tr>\n<td>添加内容</td>\n<td style=\"text-align:right\">addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo</td>\n<td style=\"text-align:center\">添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)</td>\n</tr>\n<tr>\n<td>是否为空</td>\n<td style=\"text-align:right\">isEmpty</td>\n<td style=\"text-align:center\">判断Path是否为空</td>\n</tr>\n<tr>\n<td>是否为矩形</td>\n<td style=\"text-align:right\">isRect</td>\n<td style=\"text-align:center\">判断path是否是一个矩形</td>\n</tr>\n<tr>\n<td>替换路径</td>\n<td style=\"text-align:right\">set</td>\n<td style=\"text-align:center\">用新的路径替换到当前路径所有内容</td>\n</tr>\n<tr>\n<td>偏移路径</td>\n<td style=\"text-align:right\">offset</td>\n<td style=\"text-align:center\">对当前路径之前的操作进行偏移(不会影响之后的操作)</td>\n</tr>\n<tr>\n<td>贝塞尔曲线</td>\n<td style=\"text-align:right\">quadTo, cubicTo</td>\n<td style=\"text-align:center\">分别为二次和三次贝塞尔曲线的方法</td>\n</tr>\n<tr>\n<td>rXxx方法</td>\n<td style=\"text-align:right\">rMoveTo, rLineTo, rQuadTo, rCubicTo</td>\n<td style=\"text-align:center\">不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</td>\n</tr>\n<tr>\n<td>填充模式</td>\n<td style=\"text-align:right\">setFillType, getFillType, isInverseFillType, toggleInverseFillType</td>\n<td style=\"text-align:center\">设置,获取,判断和切换填充模式</td>\n</tr>\n<tr>\n<td>提示方法</td>\n<td style=\"text-align:right\">incReserve</td>\n<td style=\"text-align:center\">提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)</td>\n</tr>\n<tr>\n<td>布尔操作(API19)</td>\n<td style=\"text-align:right\">op</td>\n<td style=\"text-align:center\">对两个Path进行布尔运算(即取交集、并集等操作)</td>\n</tr>\n<tr>\n<td>计算边界</td>\n<td style=\"text-align:right\">computeBounds</td>\n<td style=\"text-align:center\">计算Path的边界</td>\n</tr>\n<tr>\n<td>重置路径</td>\n<td style=\"text-align:right\">reset, rewind</td>\n<td style=\"text-align:center\">清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType</td>\n</tr>\n<tr>\n<td>矩阵操作</td>\n<td style=\"text-align:right\">transform</td>\n<td style=\"text-align:center\">矩阵变换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"moveTo-和-setLastPoint\"><a href=\"#moveTo-和-setLastPoint\" class=\"headerlink\" title=\"moveTo 和 setLastPoint\"></a>moveTo 和 setLastPoint</h2><p>moveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点</p>\n<h2 id=\"addXxx与arcTo\"><a href=\"#addXxx与arcTo\" class=\"headerlink\" title=\"addXxx与arcTo\"></a>addXxx与arcTo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一类(基本形状)</div><div class=\"line\">// 圆形</div><div class=\"line\">public void addCircle (<span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, <span class=\"built_in\">float</span> radius, Path.Direction dir)</div><div class=\"line\">// 椭圆</div><div class=\"line\">public void addOval (RectF oval, Path.Direction dir)</div><div class=\"line\">// 矩形</div><div class=\"line\">public void addRect (<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, Path.Direction dir)</div><div class=\"line\">public void addRect (RectF rect, Path.Direction dir)</div><div class=\"line\">// 圆角矩形</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span>[] radii, Path.Direction dir)</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span> rx, <span class=\"built_in\">float</span> ry, Path.Direction dir) </div><div class=\"line\"></div><div class=\"line\">// 第二类(Path)</div><div class=\"line\">// path</div><div class=\"line\">public void addPath (Path src)</div><div class=\"line\">public void addPath (Path src, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy)</div><div class=\"line\">public void addPath (Path src, Matrix matrix)</div><div class=\"line\"></div><div class=\"line\">addArc\t添加一个圆弧到path\t直接添加一个圆弧到path中</div><div class=\"line\">arcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点</div></pre></td></tr></table></figure>\n<h2 id=\"rXxx\"><a href=\"#rXxx\" class=\"headerlink\" title=\"rXxx\"></a>rXxx</h2><p>rXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。<br>比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ，<br>使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示</p>\n<h2 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h2><p>数据点    确定曲线的起始和结束位置<br>控制点    确定曲线的弯曲程度</p>\n<p>一阶曲线其实就是前面讲解过的lineTo<br>二阶曲线对应的方法是quadTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835406060\" alt=\"\"><br>三阶曲线对应的方法是cubicTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835375418\" alt=\"\"></p>\n<h2 id=\"PathMeasure\"><a href=\"#PathMeasure\" class=\"headerlink\" title=\"PathMeasure\"></a>PathMeasure</h2><h3 id=\"api-1\"><a href=\"#api-1\" class=\"headerlink\" title=\"api\"></a>api</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th style=\"text-align:right\">方法名</th>\n<th style=\"text-align:center\">释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void</td>\n<td style=\"text-align:right\">setPath(Path path, boolean forceClosed)</td>\n<td style=\"text-align:center\">关联一个Path</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">isClosed()</td>\n<td style=\"text-align:center\">是否闭合</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:right\">getLength()</td>\n<td style=\"text-align:center\">获取Path的长度</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">nextContour()</td>\n<td style=\"text-align:center\">跳转到下一个轮廓</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</td>\n<td style=\"text-align:center\">截取片段</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getPosTan(float distance, float[] pos, float[] tan)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点切线值</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getMatrix(float distance, Matrix matrix, int flags)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点Matrix</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PathMeasure ()</div><div class=\"line\">PathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 <span class=\"literal\">true</span>,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)</div></pre></td></tr></table></figure>\n<h3 id=\"getSegment\"><a href=\"#getSegment\" class=\"headerlink\" title=\"getSegment\"></a>getSegment</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean getSegment (<span class=\"built_in\">float</span> startD, <span class=\"built_in\">float</span> stopD, Path dst, boolean startWithMoveTo)</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">作用</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>返回值(boolean)</td>\n<td style=\"text-align:right\">判断截取是否成功</td>\n<td style=\"text-align:center\">true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容</td>\n</tr>\n<tr>\n<td>startD</td>\n<td style=\"text-align:right\">开始截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>stopD</td>\n<td style=\"text-align:right\">结束截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>dst</td>\n<td style=\"text-align:right\">截取的 Path 将会添加到 dst 中</td>\n<td style=\"text-align:center\">注意: 是添加，而不是替换</td>\n</tr>\n<tr>\n<td>startWithMoveTo</td>\n<td style=\"text-align:right\">起始点是否使用 moveTo</td>\n<td style=\"text-align:center\">用于保证截取的 Path 第一个点位置不变</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nextContour\"><a href=\"#nextContour\" class=\"headerlink\" title=\"nextContour\"></a>nextContour</h3><p>我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，<br>而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。</p>\n<h2 id=\"FillType\"><a href=\"#FillType\" class=\"headerlink\" title=\"FillType\"></a>FillType</h2><table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EVEN_ODD</td>\n<td style=\"text-align:center\">奇偶规则</td>\n</tr>\n<tr>\n<td>INVERSE_EVEN_ODD</td>\n<td style=\"text-align:center\">反奇偶规则</td>\n</tr>\n<tr>\n<td>WINDING</td>\n<td style=\"text-align:center\">非零环绕数规则</td>\n</tr>\n<tr>\n<td>INVERSE_WINDING</td>\n<td style=\"text-align:center\">反非零环绕数规则</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"布尔操作\"><a href=\"#布尔操作\" class=\"headerlink\" title=\"布尔操作\"></a>布尔操作</h2><table>\n<thead>\n<tr>\n<th>逻辑名称</th>\n<th style=\"text-align:right\">类比</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path1中减去Path2后剩下的部分    </td>\n</tr>\n<tr>\n<td>REVERSE_DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path2中减去Path1后剩下的部分    </td>\n</tr>\n<tr>\n<td>INTERSECT</td>\n<td style=\"text-align:right\">交集</td>\n<td style=\"text-align:center\">Path1与Path2相交的部分    </td>\n</tr>\n<tr>\n<td>UNION</td>\n<td style=\"text-align:right\">并集</td>\n<td style=\"text-align:center\">包含全部Path1和Path2    </td>\n</tr>\n<tr>\n<td>XOR</td>\n<td style=\"text-align:right\">异或</td>\n<td style=\"text-align:center\">包含Path1与Path2但不包括两者相交的部分</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。</div><div class=\"line\">path1.op(path2, Path.Op.DIFFERENCE);</div><div class=\"line\"></div><div class=\"line\">// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。</div><div class=\"line\">path3.op(path1, path2, Path.Op.DIFFERENCE)</div><div class=\"line\"></div><div class=\"line\">这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：</div><div class=\"line\">void computeBounds (RectF bounds, boolean exact)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"whant-is-path\"><a href=\"#whant-is-path\" class=\"headerlink\" title=\"whant is path\"></a>whant is path</h2><p>Path封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，<br>也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)</p>","more":"<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><table>\n<thead>\n<tr>\n<th>作用</th>\n<th style=\"text-align:right\">相关方法</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移动起点</td>\n<td style=\"text-align:right\">moveTo</td>\n<td style=\"text-align:center\">移动下一次操作的起点位置</td>\n</tr>\n<tr>\n<td>设置终点</td>\n<td style=\"text-align:right\">setLastPoint</td>\n<td style=\"text-align:center\">重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同</td>\n</tr>\n<tr>\n<td>连接直线</td>\n<td style=\"text-align:right\">lineTo</td>\n<td style=\"text-align:center\">添加上一个点到当前点之间的直线到Path</td>\n</tr>\n<tr>\n<td>闭合路径</td>\n<td style=\"text-align:right\">close</td>\n<td style=\"text-align:center\">连接第一个点连接到最后一个点，形成一个闭合区域</td>\n</tr>\n<tr>\n<td>添加内容</td>\n<td style=\"text-align:right\">addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo</td>\n<td style=\"text-align:center\">添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)</td>\n</tr>\n<tr>\n<td>是否为空</td>\n<td style=\"text-align:right\">isEmpty</td>\n<td style=\"text-align:center\">判断Path是否为空</td>\n</tr>\n<tr>\n<td>是否为矩形</td>\n<td style=\"text-align:right\">isRect</td>\n<td style=\"text-align:center\">判断path是否是一个矩形</td>\n</tr>\n<tr>\n<td>替换路径</td>\n<td style=\"text-align:right\">set</td>\n<td style=\"text-align:center\">用新的路径替换到当前路径所有内容</td>\n</tr>\n<tr>\n<td>偏移路径</td>\n<td style=\"text-align:right\">offset</td>\n<td style=\"text-align:center\">对当前路径之前的操作进行偏移(不会影响之后的操作)</td>\n</tr>\n<tr>\n<td>贝塞尔曲线</td>\n<td style=\"text-align:right\">quadTo, cubicTo</td>\n<td style=\"text-align:center\">分别为二次和三次贝塞尔曲线的方法</td>\n</tr>\n<tr>\n<td>rXxx方法</td>\n<td style=\"text-align:right\">rMoveTo, rLineTo, rQuadTo, rCubicTo</td>\n<td style=\"text-align:center\">不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</td>\n</tr>\n<tr>\n<td>填充模式</td>\n<td style=\"text-align:right\">setFillType, getFillType, isInverseFillType, toggleInverseFillType</td>\n<td style=\"text-align:center\">设置,获取,判断和切换填充模式</td>\n</tr>\n<tr>\n<td>提示方法</td>\n<td style=\"text-align:right\">incReserve</td>\n<td style=\"text-align:center\">提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)</td>\n</tr>\n<tr>\n<td>布尔操作(API19)</td>\n<td style=\"text-align:right\">op</td>\n<td style=\"text-align:center\">对两个Path进行布尔运算(即取交集、并集等操作)</td>\n</tr>\n<tr>\n<td>计算边界</td>\n<td style=\"text-align:right\">computeBounds</td>\n<td style=\"text-align:center\">计算Path的边界</td>\n</tr>\n<tr>\n<td>重置路径</td>\n<td style=\"text-align:right\">reset, rewind</td>\n<td style=\"text-align:center\">清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType</td>\n</tr>\n<tr>\n<td>矩阵操作</td>\n<td style=\"text-align:right\">transform</td>\n<td style=\"text-align:center\">矩阵变换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"moveTo-和-setLastPoint\"><a href=\"#moveTo-和-setLastPoint\" class=\"headerlink\" title=\"moveTo 和 setLastPoint\"></a>moveTo 和 setLastPoint</h2><p>moveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点</p>\n<h2 id=\"addXxx与arcTo\"><a href=\"#addXxx与arcTo\" class=\"headerlink\" title=\"addXxx与arcTo\"></a>addXxx与arcTo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一类(基本形状)</div><div class=\"line\">// 圆形</div><div class=\"line\">public void addCircle (<span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, <span class=\"built_in\">float</span> radius, Path.Direction dir)</div><div class=\"line\">// 椭圆</div><div class=\"line\">public void addOval (RectF oval, Path.Direction dir)</div><div class=\"line\">// 矩形</div><div class=\"line\">public void addRect (<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, Path.Direction dir)</div><div class=\"line\">public void addRect (RectF rect, Path.Direction dir)</div><div class=\"line\">// 圆角矩形</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span>[] radii, Path.Direction dir)</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span> rx, <span class=\"built_in\">float</span> ry, Path.Direction dir) </div><div class=\"line\"></div><div class=\"line\">// 第二类(Path)</div><div class=\"line\">// path</div><div class=\"line\">public void addPath (Path src)</div><div class=\"line\">public void addPath (Path src, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy)</div><div class=\"line\">public void addPath (Path src, Matrix matrix)</div><div class=\"line\"></div><div class=\"line\">addArc\t添加一个圆弧到path\t直接添加一个圆弧到path中</div><div class=\"line\">arcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点</div></pre></td></tr></table></figure>\n<h2 id=\"rXxx\"><a href=\"#rXxx\" class=\"headerlink\" title=\"rXxx\"></a>rXxx</h2><p>rXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。<br>比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ，<br>使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示</p>\n<h2 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h2><p>数据点    确定曲线的起始和结束位置<br>控制点    确定曲线的弯曲程度</p>\n<p>一阶曲线其实就是前面讲解过的lineTo<br>二阶曲线对应的方法是quadTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835406060\" alt=\"\"><br>三阶曲线对应的方法是cubicTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835375418\" alt=\"\"></p>\n<h2 id=\"PathMeasure\"><a href=\"#PathMeasure\" class=\"headerlink\" title=\"PathMeasure\"></a>PathMeasure</h2><h3 id=\"api-1\"><a href=\"#api-1\" class=\"headerlink\" title=\"api\"></a>api</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th style=\"text-align:right\">方法名</th>\n<th style=\"text-align:center\">释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void</td>\n<td style=\"text-align:right\">setPath(Path path, boolean forceClosed)</td>\n<td style=\"text-align:center\">关联一个Path</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">isClosed()</td>\n<td style=\"text-align:center\">是否闭合</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:right\">getLength()</td>\n<td style=\"text-align:center\">获取Path的长度</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">nextContour()</td>\n<td style=\"text-align:center\">跳转到下一个轮廓</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</td>\n<td style=\"text-align:center\">截取片段</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getPosTan(float distance, float[] pos, float[] tan)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点切线值</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getMatrix(float distance, Matrix matrix, int flags)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点Matrix</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PathMeasure ()</div><div class=\"line\">PathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 <span class=\"literal\">true</span>,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)</div></pre></td></tr></table></figure>\n<h3 id=\"getSegment\"><a href=\"#getSegment\" class=\"headerlink\" title=\"getSegment\"></a>getSegment</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean getSegment (<span class=\"built_in\">float</span> startD, <span class=\"built_in\">float</span> stopD, Path dst, boolean startWithMoveTo)</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">作用</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>返回值(boolean)</td>\n<td style=\"text-align:right\">判断截取是否成功</td>\n<td style=\"text-align:center\">true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容</td>\n</tr>\n<tr>\n<td>startD</td>\n<td style=\"text-align:right\">开始截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>stopD</td>\n<td style=\"text-align:right\">结束截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>dst</td>\n<td style=\"text-align:right\">截取的 Path 将会添加到 dst 中</td>\n<td style=\"text-align:center\">注意: 是添加，而不是替换</td>\n</tr>\n<tr>\n<td>startWithMoveTo</td>\n<td style=\"text-align:right\">起始点是否使用 moveTo</td>\n<td style=\"text-align:center\">用于保证截取的 Path 第一个点位置不变</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nextContour\"><a href=\"#nextContour\" class=\"headerlink\" title=\"nextContour\"></a>nextContour</h3><p>我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，<br>而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。</p>\n<h2 id=\"FillType\"><a href=\"#FillType\" class=\"headerlink\" title=\"FillType\"></a>FillType</h2><table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EVEN_ODD</td>\n<td style=\"text-align:center\">奇偶规则</td>\n</tr>\n<tr>\n<td>INVERSE_EVEN_ODD</td>\n<td style=\"text-align:center\">反奇偶规则</td>\n</tr>\n<tr>\n<td>WINDING</td>\n<td style=\"text-align:center\">非零环绕数规则</td>\n</tr>\n<tr>\n<td>INVERSE_WINDING</td>\n<td style=\"text-align:center\">反非零环绕数规则</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"布尔操作\"><a href=\"#布尔操作\" class=\"headerlink\" title=\"布尔操作\"></a>布尔操作</h2><table>\n<thead>\n<tr>\n<th>逻辑名称</th>\n<th style=\"text-align:right\">类比</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path1中减去Path2后剩下的部分    </td>\n</tr>\n<tr>\n<td>REVERSE_DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path2中减去Path1后剩下的部分    </td>\n</tr>\n<tr>\n<td>INTERSECT</td>\n<td style=\"text-align:right\">交集</td>\n<td style=\"text-align:center\">Path1与Path2相交的部分    </td>\n</tr>\n<tr>\n<td>UNION</td>\n<td style=\"text-align:right\">并集</td>\n<td style=\"text-align:center\">包含全部Path1和Path2    </td>\n</tr>\n<tr>\n<td>XOR</td>\n<td style=\"text-align:right\">异或</td>\n<td style=\"text-align:center\">包含Path1与Path2但不包括两者相交的部分</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。</div><div class=\"line\">path1.op(path2, Path.Op.DIFFERENCE);</div><div class=\"line\"></div><div class=\"line\">// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。</div><div class=\"line\">path3.op(path1, path2, Path.Op.DIFFERENCE)</div><div class=\"line\"></div><div class=\"line\">这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：</div><div class=\"line\">void computeBounds (RectF bounds, boolean exact)</div></pre></td></tr></table></figure>"},{"title":"Paint shader","date":"2017-05-22T13:49:00.000Z","_content":"\n## BitmapShader\n``` bash\n// 3种模式\nShader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充\nShader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺\nShader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺\n```\n<!-- more -->\n\n直接上例子,画一个简单的圆形bitmap\n``` bash\nprivate void init() {\n    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);\n    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式\n\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap\n    mPaint.setShader(shader);\n}\n\n@Override\nprotected void onDraw(Canvas canvas) {\n    super.onDraw(canvas);\n    float x = getWidth() / 2;\n    float y = getHeight() / 2;\n    float radius = Math.min(getWidth(), getHeight()) / 2;\n    canvas.drawCircle(x, y, radius,mPaint); \n}\n```\n![](http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分\n\n##  LinearGradient 线性渐变\n``` bash\n/*\nx0 绘制x轴起始点\ny0 绘制y轴起始点\nx1 绘制x轴结束点\ny1 绘制y轴结束点\ncolor0 起始颜色\ncolor1 结束颜色\ntile 模式\n*/\nLinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);\nmPaint.setShader(shader);\n\n\n/*\ncolors 颜色int值数组\npostions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关\n*/\nfinal int [] colors =  new int [] {Color.MAGENTA,Color.CYAN,Color.RED};\nfinal float [] positions = new float[]{0f,0.50f,1f};\nfinal LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);\n```\n\n## RadialGradient 光束渐变\n``` bash\n/*\ncenterX 渐变中心点的X轴坐标\ncenterY 渐变中心点的Y轴坐标\nradius 渐变区域的半径\n*/\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);\n\nfinal int[] colors = new int[]{Color.YELLOW,Color.BLUE ,Color.RED};\nfinal float[] positions = new float[]{0f, 0.5f ,1f};\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);\n// colors中的元素个数要和positions中的元素个数相等\n```\n\n## SweepGradient 梯度渐变\n``` bash\nSweepGradient(float cx, float cy, int color0, int color1) \nSweepGradient(float cx, float cy, int colors[], float positions[])\n//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转\n```\n\n## 6. ComposeShader 混合渐变\n``` bash\n// 需要关闭硬件加速\nComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)\nComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)\n\n构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode\n前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果\n```","source":"_posts/Paint_shader.md","raw":"---\ntitle: Paint shader\ndate: 2017-05-22 21:49:00\ncategories: android\ntags: [自定义view,paint]\n---\n\n## BitmapShader\n``` bash\n// 3种模式\nShader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充\nShader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺\nShader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺\n```\n<!-- more -->\n\n直接上例子,画一个简单的圆形bitmap\n``` bash\nprivate void init() {\n    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);\n    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式\n\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap\n    mPaint.setShader(shader);\n}\n\n@Override\nprotected void onDraw(Canvas canvas) {\n    super.onDraw(canvas);\n    float x = getWidth() / 2;\n    float y = getHeight() / 2;\n    float radius = Math.min(getWidth(), getHeight()) / 2;\n    canvas.drawCircle(x, y, radius,mPaint); \n}\n```\n![](http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分\n\n##  LinearGradient 线性渐变\n``` bash\n/*\nx0 绘制x轴起始点\ny0 绘制y轴起始点\nx1 绘制x轴结束点\ny1 绘制y轴结束点\ncolor0 起始颜色\ncolor1 结束颜色\ntile 模式\n*/\nLinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);\nmPaint.setShader(shader);\n\n\n/*\ncolors 颜色int值数组\npostions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关\n*/\nfinal int [] colors =  new int [] {Color.MAGENTA,Color.CYAN,Color.RED};\nfinal float [] positions = new float[]{0f,0.50f,1f};\nfinal LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);\n```\n\n## RadialGradient 光束渐变\n``` bash\n/*\ncenterX 渐变中心点的X轴坐标\ncenterY 渐变中心点的Y轴坐标\nradius 渐变区域的半径\n*/\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);\n\nfinal int[] colors = new int[]{Color.YELLOW,Color.BLUE ,Color.RED};\nfinal float[] positions = new float[]{0f, 0.5f ,1f};\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);\n// colors中的元素个数要和positions中的元素个数相等\n```\n\n## SweepGradient 梯度渐变\n``` bash\nSweepGradient(float cx, float cy, int color0, int color1) \nSweepGradient(float cx, float cy, int colors[], float positions[])\n//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转\n```\n\n## 6. ComposeShader 混合渐变\n``` bash\n// 需要关闭硬件加速\nComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)\nComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)\n\n构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode\n前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果\n```","slug":"Paint_shader","published":1,"updated":"2018-02-10T06:53:50.930Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gad0004o4l1s9fyzw6j","content":"<h2 id=\"BitmapShader\"><a href=\"#BitmapShader\" class=\"headerlink\" title=\"BitmapShader\"></a>BitmapShader</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 3种模式</div><div class=\"line\">Shader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充</div><div class=\"line\">Shader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺</div><div class=\"line\">Shader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>直接上例子,画一个简单的圆形bitmap<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</div><div class=\"line\">    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class=\"line\">    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);</div><div class=\"line\">    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式</div><div class=\"line\">\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap</div><div class=\"line\">    mPaint.setShader(shader);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    super.onDraw(canvas);</div><div class=\"line\">    <span class=\"built_in\">float</span> x = getWidth() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> y = getHeight() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> radius = Math.min(getWidth(), getHeight()) / 2;</div><div class=\"line\">    canvas.drawCircle(x, y, radius,mPaint); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分</p>\n<h2 id=\"LinearGradient-线性渐变\"><a href=\"#LinearGradient-线性渐变\" class=\"headerlink\" title=\"LinearGradient 线性渐变\"></a>LinearGradient 线性渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">x0 绘制x轴起始点</div><div class=\"line\">y0 绘制y轴起始点</div><div class=\"line\">x1 绘制x轴结束点</div><div class=\"line\">y1 绘制y轴结束点</div><div class=\"line\">color0 起始颜色</div><div class=\"line\">color1 结束颜色</div><div class=\"line\">tile 模式</div><div class=\"line\">*/</div><div class=\"line\">LinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);</div><div class=\"line\">mPaint.setShader(shader);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">colors 颜色int值数组</div><div class=\"line\">postions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关</div><div class=\"line\">*/</div><div class=\"line\">final int [] colors =  new int [] &#123;Color.MAGENTA,Color.CYAN,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span> [] positions = new <span class=\"built_in\">float</span>[]&#123;0f,0.50f,1f&#125;;</div><div class=\"line\">final LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);</div></pre></td></tr></table></figure>\n<h2 id=\"RadialGradient-光束渐变\"><a href=\"#RadialGradient-光束渐变\" class=\"headerlink\" title=\"RadialGradient 光束渐变\"></a>RadialGradient 光束渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">centerX 渐变中心点的X轴坐标</div><div class=\"line\">centerY 渐变中心点的Y轴坐标</div><div class=\"line\">radius 渐变区域的半径</div><div class=\"line\">*/</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);</div><div class=\"line\"></div><div class=\"line\">final int[] colors = new int[]&#123;Color.YELLOW,Color.BLUE ,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span>[] positions = new <span class=\"built_in\">float</span>[]&#123;0f, 0.5f ,1f&#125;;</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);</div><div class=\"line\">// colors中的元素个数要和positions中的元素个数相等</div></pre></td></tr></table></figure>\n<h2 id=\"SweepGradient-梯度渐变\"><a href=\"#SweepGradient-梯度渐变\" class=\"headerlink\" title=\"SweepGradient 梯度渐变\"></a>SweepGradient 梯度渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int color0, int color1) </div><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int colors[], <span class=\"built_in\">float</span> positions[])</div><div class=\"line\">//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转</div></pre></td></tr></table></figure>\n<h2 id=\"6-ComposeShader-混合渐变\"><a href=\"#6-ComposeShader-混合渐变\" class=\"headerlink\" title=\"6. ComposeShader 混合渐变\"></a>6. ComposeShader 混合渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 需要关闭硬件加速</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)</div><div class=\"line\"></div><div class=\"line\">构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode</div><div class=\"line\">前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"BitmapShader\"><a href=\"#BitmapShader\" class=\"headerlink\" title=\"BitmapShader\"></a>BitmapShader</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 3种模式</div><div class=\"line\">Shader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充</div><div class=\"line\">Shader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺</div><div class=\"line\">Shader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺</div></pre></td></tr></table></figure>","more":"<p>直接上例子,画一个简单的圆形bitmap<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</div><div class=\"line\">    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class=\"line\">    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);</div><div class=\"line\">    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式</div><div class=\"line\">\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap</div><div class=\"line\">    mPaint.setShader(shader);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    super.onDraw(canvas);</div><div class=\"line\">    <span class=\"built_in\">float</span> x = getWidth() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> y = getHeight() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> radius = Math.min(getWidth(), getHeight()) / 2;</div><div class=\"line\">    canvas.drawCircle(x, y, radius,mPaint); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分</p>\n<h2 id=\"LinearGradient-线性渐变\"><a href=\"#LinearGradient-线性渐变\" class=\"headerlink\" title=\"LinearGradient 线性渐变\"></a>LinearGradient 线性渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">x0 绘制x轴起始点</div><div class=\"line\">y0 绘制y轴起始点</div><div class=\"line\">x1 绘制x轴结束点</div><div class=\"line\">y1 绘制y轴结束点</div><div class=\"line\">color0 起始颜色</div><div class=\"line\">color1 结束颜色</div><div class=\"line\">tile 模式</div><div class=\"line\">*/</div><div class=\"line\">LinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);</div><div class=\"line\">mPaint.setShader(shader);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">colors 颜色int值数组</div><div class=\"line\">postions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关</div><div class=\"line\">*/</div><div class=\"line\">final int [] colors =  new int [] &#123;Color.MAGENTA,Color.CYAN,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span> [] positions = new <span class=\"built_in\">float</span>[]&#123;0f,0.50f,1f&#125;;</div><div class=\"line\">final LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);</div></pre></td></tr></table></figure>\n<h2 id=\"RadialGradient-光束渐变\"><a href=\"#RadialGradient-光束渐变\" class=\"headerlink\" title=\"RadialGradient 光束渐变\"></a>RadialGradient 光束渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">centerX 渐变中心点的X轴坐标</div><div class=\"line\">centerY 渐变中心点的Y轴坐标</div><div class=\"line\">radius 渐变区域的半径</div><div class=\"line\">*/</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);</div><div class=\"line\"></div><div class=\"line\">final int[] colors = new int[]&#123;Color.YELLOW,Color.BLUE ,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span>[] positions = new <span class=\"built_in\">float</span>[]&#123;0f, 0.5f ,1f&#125;;</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);</div><div class=\"line\">// colors中的元素个数要和positions中的元素个数相等</div></pre></td></tr></table></figure>\n<h2 id=\"SweepGradient-梯度渐变\"><a href=\"#SweepGradient-梯度渐变\" class=\"headerlink\" title=\"SweepGradient 梯度渐变\"></a>SweepGradient 梯度渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int color0, int color1) </div><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int colors[], <span class=\"built_in\">float</span> positions[])</div><div class=\"line\">//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转</div></pre></td></tr></table></figure>\n<h2 id=\"6-ComposeShader-混合渐变\"><a href=\"#6-ComposeShader-混合渐变\" class=\"headerlink\" title=\"6. ComposeShader 混合渐变\"></a>6. ComposeShader 混合渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 需要关闭硬件加速</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)</div><div class=\"line\"></div><div class=\"line\">构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode</div><div class=\"line\">前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果</div></pre></td></tr></table></figure>"},{"title":"canvas 启动","date":"2017-05-14T06:57:55.000Z","_content":"\n## 基本api\n|操作类型\t \t\t|相关API\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|备注\n| -----------   \t| -----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n|绘制颜色\t \t\t|drawColor, drawRGB, drawARGB\t|使用单一颜色填充整个画布\n|绘制基本形状\t\t|drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc\t|依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n|绘制图片\t\t\t|drawBitmap, drawPicture\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制位图和图片\n|绘制文本\t\t\t|drawText, drawPosText, drawTextOnPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n|绘制路径\t\t\t|drawPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制路径，绘制贝塞尔曲线时也需要用到该函数\n|顶点操作\t\t\t|drawVertices, drawBitmapMesh\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n|画布剪裁\t\t\t|clipPath, clipRect\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|设置画布的显示区域\n|画布快照\t\t\t|save, restore, saveLayerXxx, restoreToCount, getSaveCount\t\t\t\t\t\t\t\t\t\t\t|依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n|画布变换\t\t\t|translate, scale, rotate, skew\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 位移、缩放、 旋转、错切\n|Matrix(矩阵)\t\t|getMatrix, setMatrix, concat\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n\n<!-- more -->\n\n## save and restore\n\nsave方法用于临时保存画布坐标系统的状态\nrestore方法可以用来恢复save之后设置的状态\n可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，\n但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。\n\n## translate, scale, rotate\n通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,-400,400,0);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.scale(-0.5f,-0.5f);              // 画布缩放  图1\n// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  <-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2\n\n//canvas.rotate(180);                     // 旋转180度 <-- 默认旋转中心为原点 图3\n// canvas.rotate(180,200,0);            // 旋转180度 <-- 旋转中心向右偏移200个单位 图4\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![图1](http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg)\n\n![图2](http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg)\n\n![图3](http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg)\n\n## skew \nskew这里翻译为错切，错切是特殊类型的线性变换。\n\n错切只提供了一种方法：\n\npublic void skew (float sx, float sy)\n参数含义：\nfloat sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，\nfloat sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,0,200,200);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.skew(1,0);                       // 水平错切 <- 45度\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![](https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf)\n\n\n","source":"_posts/canvas.md","raw":"---\ntitle: canvas 启动\ndate: 2017-05-14 14:57:55\ncategories: android\ntags: [自定义view,canvas]\n---\n\n## 基本api\n|操作类型\t \t\t|相关API\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|备注\n| -----------   \t| -----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n|绘制颜色\t \t\t|drawColor, drawRGB, drawARGB\t|使用单一颜色填充整个画布\n|绘制基本形状\t\t|drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc\t|依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n|绘制图片\t\t\t|drawBitmap, drawPicture\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制位图和图片\n|绘制文本\t\t\t|drawText, drawPosText, drawTextOnPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n|绘制路径\t\t\t|drawPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制路径，绘制贝塞尔曲线时也需要用到该函数\n|顶点操作\t\t\t|drawVertices, drawBitmapMesh\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n|画布剪裁\t\t\t|clipPath, clipRect\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|设置画布的显示区域\n|画布快照\t\t\t|save, restore, saveLayerXxx, restoreToCount, getSaveCount\t\t\t\t\t\t\t\t\t\t\t|依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n|画布变换\t\t\t|translate, scale, rotate, skew\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 位移、缩放、 旋转、错切\n|Matrix(矩阵)\t\t|getMatrix, setMatrix, concat\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n\n<!-- more -->\n\n## save and restore\n\nsave方法用于临时保存画布坐标系统的状态\nrestore方法可以用来恢复save之后设置的状态\n可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，\n但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。\n\n## translate, scale, rotate\n通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,-400,400,0);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.scale(-0.5f,-0.5f);              // 画布缩放  图1\n// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  <-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2\n\n//canvas.rotate(180);                     // 旋转180度 <-- 默认旋转中心为原点 图3\n// canvas.rotate(180,200,0);            // 旋转180度 <-- 旋转中心向右偏移200个单位 图4\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![图1](http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg)\n\n![图2](http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg)\n\n![图3](http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg)\n\n## skew \nskew这里翻译为错切，错切是特殊类型的线性变换。\n\n错切只提供了一种方法：\n\npublic void skew (float sx, float sy)\n参数含义：\nfloat sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，\nfloat sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,0,200,200);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.skew(1,0);                       // 水平错切 <- 45度\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![](https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf)\n\n\n","slug":"canvas","published":1,"updated":"2018-02-10T06:53:50.936Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gae0005o4l14wtmqayn","content":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>操作类型</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>绘制颜色</td>\n<td style=\"text-align:right\">drawColor, drawRGB, drawARGB</td>\n<td style=\"text-align:center\">使用单一颜色填充整个画布</td>\n</tr>\n<tr>\n<td>绘制基本形状</td>\n<td style=\"text-align:right\">drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td>\n<td style=\"text-align:center\">依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧</td>\n</tr>\n<tr>\n<td>绘制图片</td>\n<td style=\"text-align:right\">drawBitmap, drawPicture</td>\n<td style=\"text-align:center\">绘制位图和图片</td>\n</tr>\n<tr>\n<td>绘制文本</td>\n<td style=\"text-align:right\">drawText, drawPosText, drawTextOnPath</td>\n<td style=\"text-align:center\">依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字</td>\n</tr>\n<tr>\n<td>绘制路径</td>\n<td style=\"text-align:right\">drawPath</td>\n<td style=\"text-align:center\">绘制路径，绘制贝塞尔曲线时也需要用到该函数</td>\n</tr>\n<tr>\n<td>顶点操作</td>\n<td style=\"text-align:right\">drawVertices, drawBitmapMesh</td>\n<td style=\"text-align:center\">通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用</td>\n</tr>\n<tr>\n<td>画布剪裁</td>\n<td style=\"text-align:right\">clipPath, clipRect</td>\n<td style=\"text-align:center\">设置画布的显示区域</td>\n</tr>\n<tr>\n<td>画布快照</td>\n<td style=\"text-align:right\">save, restore, saveLayerXxx, restoreToCount, getSaveCount</td>\n<td style=\"text-align:center\">依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数</td>\n</tr>\n<tr>\n<td>画布变换</td>\n<td style=\"text-align:right\">translate, scale, rotate, skew</td>\n<td style=\"text-align:center\">依次为 位移、缩放、 旋转、错切</td>\n</tr>\n<tr>\n<td>Matrix(矩阵)</td>\n<td style=\"text-align:right\">getMatrix, setMatrix, concat</td>\n<td style=\"text-align:center\">实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"save-and-restore\"><a href=\"#save-and-restore\" class=\"headerlink\" title=\"save and restore\"></a>save and restore</h2><p>save方法用于临时保存画布坐标系统的状态<br>restore方法可以用来恢复save之后设置的状态<br>可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，<br>但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。</p>\n<h2 id=\"translate-scale-rotate\"><a href=\"#translate-scale-rotate\" class=\"headerlink\" title=\"translate, scale, rotate\"></a>translate, scale, rotate</h2><p>通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,-400,400,0);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.scale(-0.5f,-0.5f);              // 画布缩放  图1</div><div class=\"line\">// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  &lt;-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2</div><div class=\"line\"></div><div class=\"line\">//canvas.rotate(180);                     // 旋转180度 &lt;-- 默认旋转中心为原点 图3</div><div class=\"line\">// canvas.rotate(180,200,0);            // 旋转180度 &lt;-- 旋转中心向右偏移200个单位 图4</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg\" alt=\"图1\"></p>\n<p><img src=\"http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg\" alt=\"图2\"></p>\n<p><img src=\"http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg\" alt=\"图3\"></p>\n<h2 id=\"skew\"><a href=\"#skew\" class=\"headerlink\" title=\"skew\"></a>skew</h2><p>skew这里翻译为错切，错切是特殊类型的线性变换。</p>\n<p>错切只提供了一种方法：</p>\n<p>public void skew (float sx, float sy)<br>参数含义：<br>float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，<br>float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,0,200,200);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.skew(1,0);                       // 水平错切 &lt;- 45度</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>操作类型</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>绘制颜色</td>\n<td style=\"text-align:right\">drawColor, drawRGB, drawARGB</td>\n<td style=\"text-align:center\">使用单一颜色填充整个画布</td>\n</tr>\n<tr>\n<td>绘制基本形状</td>\n<td style=\"text-align:right\">drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td>\n<td style=\"text-align:center\">依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧</td>\n</tr>\n<tr>\n<td>绘制图片</td>\n<td style=\"text-align:right\">drawBitmap, drawPicture</td>\n<td style=\"text-align:center\">绘制位图和图片</td>\n</tr>\n<tr>\n<td>绘制文本</td>\n<td style=\"text-align:right\">drawText, drawPosText, drawTextOnPath</td>\n<td style=\"text-align:center\">依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字</td>\n</tr>\n<tr>\n<td>绘制路径</td>\n<td style=\"text-align:right\">drawPath</td>\n<td style=\"text-align:center\">绘制路径，绘制贝塞尔曲线时也需要用到该函数</td>\n</tr>\n<tr>\n<td>顶点操作</td>\n<td style=\"text-align:right\">drawVertices, drawBitmapMesh</td>\n<td style=\"text-align:center\">通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用</td>\n</tr>\n<tr>\n<td>画布剪裁</td>\n<td style=\"text-align:right\">clipPath, clipRect</td>\n<td style=\"text-align:center\">设置画布的显示区域</td>\n</tr>\n<tr>\n<td>画布快照</td>\n<td style=\"text-align:right\">save, restore, saveLayerXxx, restoreToCount, getSaveCount</td>\n<td style=\"text-align:center\">依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数</td>\n</tr>\n<tr>\n<td>画布变换</td>\n<td style=\"text-align:right\">translate, scale, rotate, skew</td>\n<td style=\"text-align:center\">依次为 位移、缩放、 旋转、错切</td>\n</tr>\n<tr>\n<td>Matrix(矩阵)</td>\n<td style=\"text-align:right\">getMatrix, setMatrix, concat</td>\n<td style=\"text-align:center\">实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。</td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"save-and-restore\"><a href=\"#save-and-restore\" class=\"headerlink\" title=\"save and restore\"></a>save and restore</h2><p>save方法用于临时保存画布坐标系统的状态<br>restore方法可以用来恢复save之后设置的状态<br>可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，<br>但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。</p>\n<h2 id=\"translate-scale-rotate\"><a href=\"#translate-scale-rotate\" class=\"headerlink\" title=\"translate, scale, rotate\"></a>translate, scale, rotate</h2><p>通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,-400,400,0);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.scale(-0.5f,-0.5f);              // 画布缩放  图1</div><div class=\"line\">// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  &lt;-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2</div><div class=\"line\"></div><div class=\"line\">//canvas.rotate(180);                     // 旋转180度 &lt;-- 默认旋转中心为原点 图3</div><div class=\"line\">// canvas.rotate(180,200,0);            // 旋转180度 &lt;-- 旋转中心向右偏移200个单位 图4</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg\" alt=\"图1\"></p>\n<p><img src=\"http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg\" alt=\"图2\"></p>\n<p><img src=\"http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg\" alt=\"图3\"></p>\n<h2 id=\"skew\"><a href=\"#skew\" class=\"headerlink\" title=\"skew\"></a>skew</h2><p>skew这里翻译为错切，错切是特殊类型的线性变换。</p>\n<p>错切只提供了一种方法：</p>\n<p>public void skew (float sx, float sy)<br>参数含义：<br>float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，<br>float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,0,200,200);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.skew(1,0);                       // 水平错切 &lt;- 45度</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf\" alt=\"\"></p>"},{"title":"android_touch","date":"2017-09-23T07:22:41.000Z","_content":"\n# android 事件机制全解\n\n一个点击事件产生后，传递顺序是：Activity（Window） -> ViewGroup -> View\n\n默认情况下（没有自己重写派发拦截）从Activity A—->ViewGroup B—>View C，从上往下调用dispatchTouchEvent()\n再由View C—>ViewGroup B —>Activity A，从下往上调用onTouchEvent()\n\n<!-- more -->\n\n![](http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 事件传递方法 （执行顺序如下）\n\n### 事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\n\n当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用\n\n返回值\nsuper：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）\n\n|对象\t\t\t|返回方法\t\t\t\t\t\t|说明\t\n| --------  \t| \t-----:   \t\t\t\t\t| :----: |\n|Activity\t\t|super.dispatchTouchEvent()\t\t|即调用父类ViewGroup的dispatchTouchEvent()\t\n|ViewGroup\t\t|onIntercepTouchEvent()\t\t\t|即调用自身的onIntercepTouchEvent()\t\n|View\t\t\t|onTouchEvent（）\t\t\t\t|即调用自身的onTouchEvent（）\t\n\t\ntrue：消费事件，即事件不继续往下传递\nfalse：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理\n\n### 事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\n\n调用时刻 在ViewGroup的dispatchTouchEvent()内部调用\n\n返回值\nture ：调用自身的onTouchEvent（）\nsuper | false : 调用子类的dispatchTouchEvent()\n\n### 事件处理 onTouchEvent()\n\n| 事件  \t\t\t\t| 简介\t | \n| --------  \t\t\t| :----: |\n|ACTION_DOWN\t\t\t|手指 初次接触到屏幕 时触发。\n|ACTION_MOVE    \t\t|\t手指 在屏幕上滑动 时触发，会多次触发。\n|ACTION_UP      \t\t|\t手指 离开屏幕 时触发。\n|ACTION_CANCEL\t\t\t|事件 被上层拦截 时触发。\n|ACTION_OUTSIDE\t\t\t|手指 不在控件区域 时触发。\n|ACTION_POINTER_DOWN\t|有非主要的手指按下(即按下之前已经有手指在屏幕上)。\n|ACTION_POINTER_UP\t\t|有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。\n|getAction()\t\t\t|获取事件类型。\n|getX()\t\t\t\t\t|获得触摸点在当前 View 的 X 轴坐标。\n|getY()\t\t\t\t\t|获得触摸点在当前 View 的 Y 轴坐标。\n|getRawX()\t\t\t\t|获得触摸点在整个屏幕的 X 轴坐标。\n|getRawY()\t\t\t\t|获得触摸点在整个屏幕的 Y 轴坐标。\n\n#### 多点触控\n\n多点触控获取事件类型请使用 getActionMasked() 。\n追踪事件流请使用 PointId。\n\n##### index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\n\nindex\n1、从 0 开始，自动增长。\n2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。\n3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。\n4、对 move 事件无效\n\npointId\n1. 从 0 开始，自动增长。\n2. 落下手指时优先填补空缺(填补之前抬起手指的编号)。\n\n\n","source":"_posts/android-touch.md","raw":"---\ntitle: android_touch\ndate: 2017-09-23 15:22:41\ncategories: android\ntags: touch\n---\n\n# android 事件机制全解\n\n一个点击事件产生后，传递顺序是：Activity（Window） -> ViewGroup -> View\n\n默认情况下（没有自己重写派发拦截）从Activity A—->ViewGroup B—>View C，从上往下调用dispatchTouchEvent()\n再由View C—>ViewGroup B —>Activity A，从下往上调用onTouchEvent()\n\n<!-- more -->\n\n![](http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 事件传递方法 （执行顺序如下）\n\n### 事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\n\n当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用\n\n返回值\nsuper：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）\n\n|对象\t\t\t|返回方法\t\t\t\t\t\t|说明\t\n| --------  \t| \t-----:   \t\t\t\t\t| :----: |\n|Activity\t\t|super.dispatchTouchEvent()\t\t|即调用父类ViewGroup的dispatchTouchEvent()\t\n|ViewGroup\t\t|onIntercepTouchEvent()\t\t\t|即调用自身的onIntercepTouchEvent()\t\n|View\t\t\t|onTouchEvent（）\t\t\t\t|即调用自身的onTouchEvent（）\t\n\t\ntrue：消费事件，即事件不继续往下传递\nfalse：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理\n\n### 事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\n\n调用时刻 在ViewGroup的dispatchTouchEvent()内部调用\n\n返回值\nture ：调用自身的onTouchEvent（）\nsuper | false : 调用子类的dispatchTouchEvent()\n\n### 事件处理 onTouchEvent()\n\n| 事件  \t\t\t\t| 简介\t | \n| --------  \t\t\t| :----: |\n|ACTION_DOWN\t\t\t|手指 初次接触到屏幕 时触发。\n|ACTION_MOVE    \t\t|\t手指 在屏幕上滑动 时触发，会多次触发。\n|ACTION_UP      \t\t|\t手指 离开屏幕 时触发。\n|ACTION_CANCEL\t\t\t|事件 被上层拦截 时触发。\n|ACTION_OUTSIDE\t\t\t|手指 不在控件区域 时触发。\n|ACTION_POINTER_DOWN\t|有非主要的手指按下(即按下之前已经有手指在屏幕上)。\n|ACTION_POINTER_UP\t\t|有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。\n|getAction()\t\t\t|获取事件类型。\n|getX()\t\t\t\t\t|获得触摸点在当前 View 的 X 轴坐标。\n|getY()\t\t\t\t\t|获得触摸点在当前 View 的 Y 轴坐标。\n|getRawX()\t\t\t\t|获得触摸点在整个屏幕的 X 轴坐标。\n|getRawY()\t\t\t\t|获得触摸点在整个屏幕的 Y 轴坐标。\n\n#### 多点触控\n\n多点触控获取事件类型请使用 getActionMasked() 。\n追踪事件流请使用 PointId。\n\n##### index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\n\nindex\n1、从 0 开始，自动增长。\n2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。\n3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。\n4、对 move 事件无效\n\npointId\n1. 从 0 开始，自动增长。\n2. 落下手指时优先填补空缺(填补之前抬起手指的编号)。\n\n\n","slug":"android-touch","published":1,"updated":"2018-02-10T06:53:50.933Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gah0006o4l14ts9oi29","content":"<h1 id=\"android-事件机制全解\"><a href=\"#android-事件机制全解\" class=\"headerlink\" title=\"android 事件机制全解\"></a>android 事件机制全解</h1><p>一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; View</p>\n<p>默认情况下（没有自己重写派发拦截）从Activity A—-&gt;ViewGroup B—&gt;View C，从上往下调用dispatchTouchEvent()<br>再由View C—&gt;ViewGroup B —&gt;Activity A，从下往上调用onTouchEvent()</p>\n<a id=\"more\"></a>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"事件传递方法-（执行顺序如下）\"><a href=\"#事件传递方法-（执行顺序如下）\" class=\"headerlink\" title=\"事件传递方法 （执行顺序如下）\"></a>事件传递方法 （执行顺序如下）</h2><h3 id=\"事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\"><a href=\"#事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\" class=\"headerlink\" title=\"事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\"></a>事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View</h3><p>当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用</p>\n<p>返回值<br>super：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th style=\"text-align:right\">返回方法</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Activity</td>\n<td style=\"text-align:right\">super.dispatchTouchEvent()</td>\n<td style=\"text-align:center\">即调用父类ViewGroup的dispatchTouchEvent()    </td>\n</tr>\n<tr>\n<td>ViewGroup</td>\n<td style=\"text-align:right\">onIntercepTouchEvent()</td>\n<td style=\"text-align:center\">即调用自身的onIntercepTouchEvent()    </td>\n</tr>\n<tr>\n<td>View</td>\n<td style=\"text-align:right\">onTouchEvent（）</td>\n<td style=\"text-align:center\">即调用自身的onTouchEvent（）    </td>\n</tr>\n</tbody>\n</table>\n<p>true：消费事件，即事件不继续往下传递<br>false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理</p>\n<h3 id=\"事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\"><a href=\"#事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\" class=\"headerlink\" title=\"事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\"></a>事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）</h3><p>调用时刻 在ViewGroup的dispatchTouchEvent()内部调用</p>\n<p>返回值<br>ture ：调用自身的onTouchEvent（）<br>super | false : 调用子类的dispatchTouchEvent()</p>\n<h3 id=\"事件处理-onTouchEvent\"><a href=\"#事件处理-onTouchEvent\" class=\"headerlink\" title=\"事件处理 onTouchEvent()\"></a>事件处理 onTouchEvent()</h3><table>\n<thead>\n<tr>\n<th>事件</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACTION_DOWN</td>\n<td style=\"text-align:center\">手指 初次接触到屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_MOVE</td>\n<td style=\"text-align:center\">手指 在屏幕上滑动 时触发，会多次触发。</td>\n</tr>\n<tr>\n<td>ACTION_UP</td>\n<td style=\"text-align:center\">手指 离开屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_CANCEL</td>\n<td style=\"text-align:center\">事件 被上层拦截 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_OUTSIDE</td>\n<td style=\"text-align:center\">手指 不在控件区域 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_DOWN</td>\n<td style=\"text-align:center\">有非主要的手指按下(即按下之前已经有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_UP</td>\n<td style=\"text-align:center\">有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>getAction()</td>\n<td style=\"text-align:center\">获取事件类型。</td>\n</tr>\n<tr>\n<td>getX()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getY()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 Y 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawX()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawY()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 Y 轴坐标。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"多点触控\"><a href=\"#多点触控\" class=\"headerlink\" title=\"多点触控\"></a>多点触控</h4><p>多点触控获取事件类型请使用 getActionMasked() 。<br>追踪事件流请使用 PointId。</p>\n<h5 id=\"index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\"><a href=\"#index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\" class=\"headerlink\" title=\"index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\"></a>index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)</h5><p>index<br>1、从 0 开始，自动增长。<br>2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。<br>3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。<br>4、对 move 事件无效</p>\n<p>pointId</p>\n<ol>\n<li>从 0 开始，自动增长。</li>\n<li>落下手指时优先填补空缺(填补之前抬起手指的编号)。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"android-事件机制全解\"><a href=\"#android-事件机制全解\" class=\"headerlink\" title=\"android 事件机制全解\"></a>android 事件机制全解</h1><p>一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; View</p>\n<p>默认情况下（没有自己重写派发拦截）从Activity A—-&gt;ViewGroup B—&gt;View C，从上往下调用dispatchTouchEvent()<br>再由View C—&gt;ViewGroup B —&gt;Activity A，从下往上调用onTouchEvent()</p>","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"事件传递方法-（执行顺序如下）\"><a href=\"#事件传递方法-（执行顺序如下）\" class=\"headerlink\" title=\"事件传递方法 （执行顺序如下）\"></a>事件传递方法 （执行顺序如下）</h2><h3 id=\"事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\"><a href=\"#事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\" class=\"headerlink\" title=\"事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\"></a>事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View</h3><p>当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用</p>\n<p>返回值<br>super：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th style=\"text-align:right\">返回方法</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Activity</td>\n<td style=\"text-align:right\">super.dispatchTouchEvent()</td>\n<td style=\"text-align:center\">即调用父类ViewGroup的dispatchTouchEvent()    </td>\n</tr>\n<tr>\n<td>ViewGroup</td>\n<td style=\"text-align:right\">onIntercepTouchEvent()</td>\n<td style=\"text-align:center\">即调用自身的onIntercepTouchEvent()    </td>\n</tr>\n<tr>\n<td>View</td>\n<td style=\"text-align:right\">onTouchEvent（）</td>\n<td style=\"text-align:center\">即调用自身的onTouchEvent（）    </td>\n</tr>\n</tbody>\n</table>\n<p>true：消费事件，即事件不继续往下传递<br>false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理</p>\n<h3 id=\"事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\"><a href=\"#事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\" class=\"headerlink\" title=\"事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\"></a>事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）</h3><p>调用时刻 在ViewGroup的dispatchTouchEvent()内部调用</p>\n<p>返回值<br>ture ：调用自身的onTouchEvent（）<br>super | false : 调用子类的dispatchTouchEvent()</p>\n<h3 id=\"事件处理-onTouchEvent\"><a href=\"#事件处理-onTouchEvent\" class=\"headerlink\" title=\"事件处理 onTouchEvent()\"></a>事件处理 onTouchEvent()</h3><table>\n<thead>\n<tr>\n<th>事件</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACTION_DOWN</td>\n<td style=\"text-align:center\">手指 初次接触到屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_MOVE</td>\n<td style=\"text-align:center\">手指 在屏幕上滑动 时触发，会多次触发。</td>\n</tr>\n<tr>\n<td>ACTION_UP</td>\n<td style=\"text-align:center\">手指 离开屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_CANCEL</td>\n<td style=\"text-align:center\">事件 被上层拦截 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_OUTSIDE</td>\n<td style=\"text-align:center\">手指 不在控件区域 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_DOWN</td>\n<td style=\"text-align:center\">有非主要的手指按下(即按下之前已经有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_UP</td>\n<td style=\"text-align:center\">有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>getAction()</td>\n<td style=\"text-align:center\">获取事件类型。</td>\n</tr>\n<tr>\n<td>getX()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getY()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 Y 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawX()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawY()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 Y 轴坐标。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"多点触控\"><a href=\"#多点触控\" class=\"headerlink\" title=\"多点触控\"></a>多点触控</h4><p>多点触控获取事件类型请使用 getActionMasked() 。<br>追踪事件流请使用 PointId。</p>\n<h5 id=\"index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\"><a href=\"#index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\" class=\"headerlink\" title=\"index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\"></a>index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)</h5><p>index<br>1、从 0 开始，自动增长。<br>2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。<br>3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。<br>4、对 move 事件无效</p>\n<p>pointId</p>\n<ol>\n<li>从 0 开始，自动增长。</li>\n<li>落下手指时优先填补空缺(填补之前抬起手指的编号)。</li>\n</ol>"},{"title":"hellow world","date":"2017-05-09T09:04:24.000Z","_content":"``` bash\n    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么\n可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说\n错了是我，没有们，没有听众依然飞舞着 my paint）\n```","source":"_posts/fdbook.md","raw":"---\ntitle: hellow world\ndate: 2017-05-09 17:04:24\ncategories: fdbook\ntags:\n---\n``` bash\n    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么\n可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说\n错了是我，没有们，没有听众依然飞舞着 my paint）\n```","slug":"fdbook","published":1,"updated":"2018-02-10T06:53:50.939Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gam0009o4l1pb1m2lde","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么</div><div class=\"line\">可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说</div><div class=\"line\">错了是我，没有们，没有听众依然飞舞着 my paint）</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么</div><div class=\"line\">可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说</div><div class=\"line\">错了是我，没有们，没有听众依然飞舞着 my paint）</div></pre></td></tr></table></figure>"},{"title":"git","date":"2017-05-13T06:47:06.000Z","_content":"\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n<!-- more -->\n\n3.生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088@qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n4.初始化git,创建本地仓库\n``` bash\n$ git init\n```\n5.将文件加入暂存区\n``` bash\n$ git add . //将目录下所有文件加入暂存区，可以是文件名\n$ git add my_file,other_file //将目录下所有文件加入暂存区\n```\n6.提交本地仓库\n``` bash\n$ git commit -am \"初次提交\"\n```\n7.推送到远程仓库\n``` bash\n$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin \n$ git push origin master  // 客户端首次提交 ，以后直接 git push\n```\n8.实用命令\n``` bash\n$ git clone git@github..com:用户名/项目名.git // 克隆github的代码\n$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址\n$ git remote rm 远程仓库名 //  删除远程仓库\n$ git remote -v // 查看当前远程仓库地址\n$ git fetch origin master  // 取回origin的master分支\n$ git merge origin master // 将origin merge 到 master 上\n$ git push  // 相当于 fetch 加上 merge\n& git status  // 查看状态\n```\n","source":"_posts/git.md","raw":"---\ntitle: git\ndate: 2017-05-13 14:47:06\ncategories: 多学\ntags: git\n---\n\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n<!-- more -->\n\n3.生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088@qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n4.初始化git,创建本地仓库\n``` bash\n$ git init\n```\n5.将文件加入暂存区\n``` bash\n$ git add . //将目录下所有文件加入暂存区，可以是文件名\n$ git add my_file,other_file //将目录下所有文件加入暂存区\n```\n6.提交本地仓库\n``` bash\n$ git commit -am \"初次提交\"\n```\n7.推送到远程仓库\n``` bash\n$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin \n$ git push origin master  // 客户端首次提交 ，以后直接 git push\n```\n8.实用命令\n``` bash\n$ git clone git@github..com:用户名/项目名.git // 克隆github的代码\n$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址\n$ git remote rm 远程仓库名 //  删除远程仓库\n$ git remote -v // 查看当前远程仓库地址\n$ git fetch origin master  // 取回origin的master分支\n$ git merge origin master // 将origin merge 到 master 上\n$ git push  // 相当于 fetch 加上 merge\n& git status  // 查看状态\n```\n","slug":"git","published":1,"updated":"2018-02-10T06:53:50.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gap000bo4l1zbzznrna","content":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>3.生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088@qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>4.初始化git,创建本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git init</div></pre></td></tr></table></figure></p>\n<p>5.将文件加入暂存区<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add . //将目录下所有文件加入暂存区，可以是文件名</div><div class=\"line\">$ git add my_file,other_file //将目录下所有文件加入暂存区</div></pre></td></tr></table></figure></p>\n<p>6.提交本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git commit -am <span class=\"string\">\"初次提交\"</span></div></pre></td></tr></table></figure></p>\n<p>7.推送到远程仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin </div><div class=\"line\">$ git push origin master  // 客户端首次提交 ，以后直接 git push</div></pre></td></tr></table></figure></p>\n<p>8.实用命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git <span class=\"built_in\">clone</span> git@github..com:用户名/项目名.git // 克隆github的代码</div><div class=\"line\">$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址</div><div class=\"line\">$ git remote rm 远程仓库名 //  删除远程仓库</div><div class=\"line\">$ git remote -v // 查看当前远程仓库地址</div><div class=\"line\">$ git fetch origin master  // 取回origin的master分支</div><div class=\"line\">$ git merge origin master // 将origin merge 到 master 上</div><div class=\"line\">$ git push  // 相当于 fetch 加上 merge</div><div class=\"line\">&amp; git status  // 查看状态</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>","more":"<p>3.生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088@qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>4.初始化git,创建本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git init</div></pre></td></tr></table></figure></p>\n<p>5.将文件加入暂存区<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add . //将目录下所有文件加入暂存区，可以是文件名</div><div class=\"line\">$ git add my_file,other_file //将目录下所有文件加入暂存区</div></pre></td></tr></table></figure></p>\n<p>6.提交本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git commit -am <span class=\"string\">\"初次提交\"</span></div></pre></td></tr></table></figure></p>\n<p>7.推送到远程仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin </div><div class=\"line\">$ git push origin master  // 客户端首次提交 ，以后直接 git push</div></pre></td></tr></table></figure></p>\n<p>8.实用命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git <span class=\"built_in\">clone</span> git@github..com:用户名/项目名.git // 克隆github的代码</div><div class=\"line\">$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址</div><div class=\"line\">$ git remote rm 远程仓库名 //  删除远程仓库</div><div class=\"line\">$ git remote -v // 查看当前远程仓库地址</div><div class=\"line\">$ git fetch origin master  // 取回origin的master分支</div><div class=\"line\">$ git merge origin master // 将origin merge 到 master 上</div><div class=\"line\">$ git push  // 相当于 fetch 加上 merge</div><div class=\"line\">&amp; git status  // 查看状态</div></pre></td></tr></table></figure></p>"},{"title":"canvas 基本绘制","date":"2017-05-22T15:26:00.000Z","_content":"\n## drawText\n``` bash\n/** \n* text:要绘制的文字 \n* x：绘制原点x坐标 \n* y：绘制原点y坐标 \n* paint:用来做画的画笔 \n*/  \npublic void drawText(String text, float x, float y, Paint paint)\n```\n<!-- more -->\n\n值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！\n![](http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg)\n还有就是x的位置会被Paint影响,x是相对位置\n paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT\n 比如设置CENTER\n![](http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png)\n\n``` bash\n//计算各线在位置  \nPaint.FontMetrics fm = paint.getFontMetrics();  \nfloat ascent = baseLineY + fm.ascent;  \nfloat descent = baseLineY + fm.descent;  \nfloat top = baseLineY + fm.top;  \nfloat bottom = baseLineY + fm.bottom; \n```\n\n## drawRoundRect\n``` bash\n// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRoundRect(rectF,30,30,mPaint);\n// 第二种\ncanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n\n多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图\n```\n![](http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png)\n\n## drawArc 绘制圆弧\n``` bash\n// 第一种\npublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint){}\n    \n// 第二种\npublic void drawArc(float left, float top, float right, float bottom, float startAngle,\n            float sweepAngle, boolean useCenter, @NonNull Paint paint) {}\n\n// 开始角度 startAngle\n// 扫过角度 sweepAngle\n// 是否使用中心 useCenter\n```\n用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下\n``` bash\nRectF rectF = new RectF(100,100,800,400);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF,0,90,false,mPaint);\n\n//-------------------------------------\n\nRectF rectF2 = new RectF(100,600,800,900);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF2,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF2,0,90,true,mPaint);\n```\n![](http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg)\n\n## drawPicture\nPicture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容\n\n``` bash \n// 1.创建Picture\nprivate Picture mPicture = new Picture();\n\n---------------------------------------------------------------\n\n// 2.录制内容方法\nprivate void recording() {\n    // 开始录制 (接收返回值Canvas)\n    Canvas canvas = mPicture.beginRecording(500, 500);\n    // 创建一个画笔\n    Paint paint = new Paint();\n    paint.setColor(Color.BLUE);\n    paint.setStyle(Paint.Style.FILL);\n\n    // 在Canvas中具体操作\n    // 位移\n    canvas.translate(250,250);\n    // 绘制一个圆\n    canvas.drawCircle(0,0,100,paint);\n\n    mPicture.endRecording();\n}\n\n---------------------------------------------------------------\n\n// 3.在使用前调用(我在构造函数中调用了)\n  public Canvas3(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    \n    recording();    // 调用录制\n}\n```\n\n具体使用:\n\n``` bash\n1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);\n2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));\n3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制\n// 包装成为Drawable\nPictureDrawable drawable = new PictureDrawable(mPicture);\n// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\ndrawable.setBounds(0,0,250,mPicture.getHeight());\n// 绘制\ndrawable.draw(canvas);\n```\n\n","source":"_posts/canvas_1.md","raw":"---\ntitle: canvas 基本绘制\ndate: 2017-05-22 23:26:00\ncategories: android\ntags: [自定义view,canvas]\n---\n\n## drawText\n``` bash\n/** \n* text:要绘制的文字 \n* x：绘制原点x坐标 \n* y：绘制原点y坐标 \n* paint:用来做画的画笔 \n*/  \npublic void drawText(String text, float x, float y, Paint paint)\n```\n<!-- more -->\n\n值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！\n![](http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg)\n还有就是x的位置会被Paint影响,x是相对位置\n paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT\n 比如设置CENTER\n![](http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png)\n\n``` bash\n//计算各线在位置  \nPaint.FontMetrics fm = paint.getFontMetrics();  \nfloat ascent = baseLineY + fm.ascent;  \nfloat descent = baseLineY + fm.descent;  \nfloat top = baseLineY + fm.top;  \nfloat bottom = baseLineY + fm.bottom; \n```\n\n## drawRoundRect\n``` bash\n// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRoundRect(rectF,30,30,mPaint);\n// 第二种\ncanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n\n多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图\n```\n![](http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png)\n\n## drawArc 绘制圆弧\n``` bash\n// 第一种\npublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint){}\n    \n// 第二种\npublic void drawArc(float left, float top, float right, float bottom, float startAngle,\n            float sweepAngle, boolean useCenter, @NonNull Paint paint) {}\n\n// 开始角度 startAngle\n// 扫过角度 sweepAngle\n// 是否使用中心 useCenter\n```\n用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下\n``` bash\nRectF rectF = new RectF(100,100,800,400);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF,0,90,false,mPaint);\n\n//-------------------------------------\n\nRectF rectF2 = new RectF(100,600,800,900);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF2,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF2,0,90,true,mPaint);\n```\n![](http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg)\n\n## drawPicture\nPicture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容\n\n``` bash \n// 1.创建Picture\nprivate Picture mPicture = new Picture();\n\n---------------------------------------------------------------\n\n// 2.录制内容方法\nprivate void recording() {\n    // 开始录制 (接收返回值Canvas)\n    Canvas canvas = mPicture.beginRecording(500, 500);\n    // 创建一个画笔\n    Paint paint = new Paint();\n    paint.setColor(Color.BLUE);\n    paint.setStyle(Paint.Style.FILL);\n\n    // 在Canvas中具体操作\n    // 位移\n    canvas.translate(250,250);\n    // 绘制一个圆\n    canvas.drawCircle(0,0,100,paint);\n\n    mPicture.endRecording();\n}\n\n---------------------------------------------------------------\n\n// 3.在使用前调用(我在构造函数中调用了)\n  public Canvas3(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    \n    recording();    // 调用录制\n}\n```\n\n具体使用:\n\n``` bash\n1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);\n2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));\n3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制\n// 包装成为Drawable\nPictureDrawable drawable = new PictureDrawable(mPicture);\n// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\ndrawable.setBounds(0,0,250,mPicture.getHeight());\n// 绘制\ndrawable.draw(canvas);\n```\n\n","slug":"canvas_1","published":1,"updated":"2018-02-10T06:53:50.937Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gat000fo4l1guy76gex","content":"<h2 id=\"drawText\"><a href=\"#drawText\" class=\"headerlink\" title=\"drawText\"></a>drawText</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\">* text:要绘制的文字 </div><div class=\"line\">* x：绘制原点x坐标 </div><div class=\"line\">* y：绘制原点y坐标 </div><div class=\"line\">* paint:用来做画的画笔 </div><div class=\"line\">*/  </div><div class=\"line\">public void drawText(String text, <span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, Paint paint)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！<br><img src=\"http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg\" alt=\"\"><br>还有就是x的位置会被Paint影响,x是相对位置<br> paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT<br> 比如设置CENTER<br><img src=\"http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png\" alt=\"\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//计算各线在位置  </div><div class=\"line\">Paint.FontMetrics fm = paint.getFontMetrics();  </div><div class=\"line\"><span class=\"built_in\">float</span> ascent = baseLineY + fm.ascent;  </div><div class=\"line\"><span class=\"built_in\">float</span> descent = baseLineY + fm.descent;  </div><div class=\"line\"><span class=\"built_in\">float</span> top = baseLineY + fm.top;  </div><div class=\"line\"><span class=\"built_in\">float</span> bottom = baseLineY + fm.bottom;</div></pre></td></tr></table></figure>\n<h2 id=\"drawRoundRect\"><a href=\"#drawRoundRect\" class=\"headerlink\" title=\"drawRoundRect\"></a>drawRoundRect</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">canvas.drawRoundRect(rectF,30,30,mPaint);</div><div class=\"line\">// 第二种</div><div class=\"line\">canvas.drawRoundRect(100,100,800,400,30,30,mPaint);</div><div class=\"line\"></div><div class=\"line\">多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图</div></pre></td></tr></table></figure>\n<p><img src=\"http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png\" alt=\"\"></p>\n<h2 id=\"drawArc-绘制圆弧\"><a href=\"#drawArc-绘制圆弧\" class=\"headerlink\" title=\"drawArc 绘制圆弧\"></a>drawArc 绘制圆弧</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">public void drawArc(@NonNull RectF oval, <span class=\"built_in\">float</span> startAngle, <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint)&#123;&#125;</div><div class=\"line\">    </div><div class=\"line\">// 第二种</div><div class=\"line\">public void drawArc(<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, <span class=\"built_in\">float</span> startAngle,</div><div class=\"line\">            <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">// 开始角度 startAngle</div><div class=\"line\">// 扫过角度 sweepAngle</div><div class=\"line\">// 是否使用中心 useCenter</div></pre></td></tr></table></figure>\n<p>用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF,0,90,<span class=\"literal\">false</span>,mPaint);</div><div class=\"line\"></div><div class=\"line\">//-------------------------------------</div><div class=\"line\"></div><div class=\"line\">RectF rectF2 = new RectF(100,600,800,900);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF2,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF2,0,90,<span class=\"literal\">true</span>,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg\" alt=\"\"></p>\n<h2 id=\"drawPicture\"><a href=\"#drawPicture\" class=\"headerlink\" title=\"drawPicture\"></a>drawPicture</h2><p>Picture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建Picture</div><div class=\"line\">private Picture mPicture = new Picture();</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 2.录制内容方法</div><div class=\"line\">private void <span class=\"function\"><span class=\"title\">recording</span></span>() &#123;</div><div class=\"line\">    // 开始录制 (接收返回值Canvas)</div><div class=\"line\">    Canvas canvas = mPicture.beginRecording(500, 500);</div><div class=\"line\">    // 创建一个画笔</div><div class=\"line\">    Paint paint = new Paint();</div><div class=\"line\">    paint.setColor(Color.BLUE);</div><div class=\"line\">    paint.setStyle(Paint.Style.FILL);</div><div class=\"line\"></div><div class=\"line\">    // 在Canvas中具体操作</div><div class=\"line\">    // 位移</div><div class=\"line\">    canvas.translate(250,250);</div><div class=\"line\">    // 绘制一个圆</div><div class=\"line\">    canvas.drawCircle(0,0,100,paint);</div><div class=\"line\"></div><div class=\"line\">    mPicture.endRecording();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 3.在使用前调用(我在构造函数中调用了)</div><div class=\"line\">  public Canvas3(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    super(context, attrs);</div><div class=\"line\">    </div><div class=\"line\">    recording();    // 调用录制</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体使用:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);</div><div class=\"line\">2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));</div><div class=\"line\">3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制</div><div class=\"line\">// 包装成为Drawable</div><div class=\"line\">PictureDrawable drawable = new PictureDrawable(mPicture);</div><div class=\"line\">// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放</div><div class=\"line\">drawable.setBounds(0,0,250,mPicture.getHeight());</div><div class=\"line\">// 绘制</div><div class=\"line\">drawable.draw(canvas);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"drawText\"><a href=\"#drawText\" class=\"headerlink\" title=\"drawText\"></a>drawText</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\">* text:要绘制的文字 </div><div class=\"line\">* x：绘制原点x坐标 </div><div class=\"line\">* y：绘制原点y坐标 </div><div class=\"line\">* paint:用来做画的画笔 </div><div class=\"line\">*/  </div><div class=\"line\">public void drawText(String text, <span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, Paint paint)</div></pre></td></tr></table></figure>","more":"<p>值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！<br><img src=\"http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg\" alt=\"\"><br>还有就是x的位置会被Paint影响,x是相对位置<br> paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT<br> 比如设置CENTER<br><img src=\"http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png\" alt=\"\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//计算各线在位置  </div><div class=\"line\">Paint.FontMetrics fm = paint.getFontMetrics();  </div><div class=\"line\"><span class=\"built_in\">float</span> ascent = baseLineY + fm.ascent;  </div><div class=\"line\"><span class=\"built_in\">float</span> descent = baseLineY + fm.descent;  </div><div class=\"line\"><span class=\"built_in\">float</span> top = baseLineY + fm.top;  </div><div class=\"line\"><span class=\"built_in\">float</span> bottom = baseLineY + fm.bottom;</div></pre></td></tr></table></figure>\n<h2 id=\"drawRoundRect\"><a href=\"#drawRoundRect\" class=\"headerlink\" title=\"drawRoundRect\"></a>drawRoundRect</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">canvas.drawRoundRect(rectF,30,30,mPaint);</div><div class=\"line\">// 第二种</div><div class=\"line\">canvas.drawRoundRect(100,100,800,400,30,30,mPaint);</div><div class=\"line\"></div><div class=\"line\">多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图</div></pre></td></tr></table></figure>\n<p><img src=\"http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png\" alt=\"\"></p>\n<h2 id=\"drawArc-绘制圆弧\"><a href=\"#drawArc-绘制圆弧\" class=\"headerlink\" title=\"drawArc 绘制圆弧\"></a>drawArc 绘制圆弧</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">public void drawArc(@NonNull RectF oval, <span class=\"built_in\">float</span> startAngle, <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint)&#123;&#125;</div><div class=\"line\">    </div><div class=\"line\">// 第二种</div><div class=\"line\">public void drawArc(<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, <span class=\"built_in\">float</span> startAngle,</div><div class=\"line\">            <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">// 开始角度 startAngle</div><div class=\"line\">// 扫过角度 sweepAngle</div><div class=\"line\">// 是否使用中心 useCenter</div></pre></td></tr></table></figure>\n<p>用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF,0,90,<span class=\"literal\">false</span>,mPaint);</div><div class=\"line\"></div><div class=\"line\">//-------------------------------------</div><div class=\"line\"></div><div class=\"line\">RectF rectF2 = new RectF(100,600,800,900);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF2,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF2,0,90,<span class=\"literal\">true</span>,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg\" alt=\"\"></p>\n<h2 id=\"drawPicture\"><a href=\"#drawPicture\" class=\"headerlink\" title=\"drawPicture\"></a>drawPicture</h2><p>Picture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建Picture</div><div class=\"line\">private Picture mPicture = new Picture();</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 2.录制内容方法</div><div class=\"line\">private void <span class=\"function\"><span class=\"title\">recording</span></span>() &#123;</div><div class=\"line\">    // 开始录制 (接收返回值Canvas)</div><div class=\"line\">    Canvas canvas = mPicture.beginRecording(500, 500);</div><div class=\"line\">    // 创建一个画笔</div><div class=\"line\">    Paint paint = new Paint();</div><div class=\"line\">    paint.setColor(Color.BLUE);</div><div class=\"line\">    paint.setStyle(Paint.Style.FILL);</div><div class=\"line\"></div><div class=\"line\">    // 在Canvas中具体操作</div><div class=\"line\">    // 位移</div><div class=\"line\">    canvas.translate(250,250);</div><div class=\"line\">    // 绘制一个圆</div><div class=\"line\">    canvas.drawCircle(0,0,100,paint);</div><div class=\"line\"></div><div class=\"line\">    mPicture.endRecording();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 3.在使用前调用(我在构造函数中调用了)</div><div class=\"line\">  public Canvas3(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    super(context, attrs);</div><div class=\"line\">    </div><div class=\"line\">    recording();    // 调用录制</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体使用:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);</div><div class=\"line\">2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));</div><div class=\"line\">3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制</div><div class=\"line\">// 包装成为Drawable</div><div class=\"line\">PictureDrawable drawable = new PictureDrawable(mPicture);</div><div class=\"line\">// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放</div><div class=\"line\">drawable.setBounds(0,0,250,mPicture.getHeight());</div><div class=\"line\">// 绘制</div><div class=\"line\">drawable.draw(canvas);</div></pre></td></tr></table></figure>"},{"title":"Hello Hexo","date":"2017-05-08T16:00:00.000Z","_content":"\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.下载安装[Node.js](https://nodejs.org/en/)（一路next）\n3.下载hexo： 命令行 输入\n``` bash\n$ npm install -g hexo-cli\n```\n<!-- more -->\n\n4.验证软件是否成功安装\n``` bash\n$ git --version\n$ node -v\n$ npm -v\n$ hexo –v\n```\n5.新建GitHub版本库 \n注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名\n\n6.配置ssh\n（1）设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n（2）生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n7.初始化hexo\n（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开\ngit bash，输入\n``` bash\n$ hexo init\n```\n安装生成器 ：\n``` bash\n$ npm install\n```\n然后就可以新建文章了\n``` bash\n$ hexo new name\n```\n8.运行和部署hexo\n（1）本地查看 ：\n``` bash\n$ hexo g && hexo s –p 5000\n```\n浏览器输入localhost:5000,就可以在本地看到你的个人博客了 \n（2）上传git：\n下载插件：\n``` bash\n$ npm install hexo-deployer-git --save\n```\n修改工程目录下的_config.yml文件\n#发布设置\ndeploy: \n \t\ttype: git\n  \t\trepository: git@github.com:chenbaowu/chenbaowu.github.io.git\n  \t\tbranch: master\n运行 ：\n``` bash\n$ hexo g && hexo d\n```\n浏览器输入 http://chenbaowu.github.io/  就可以访问了\n\n9.主题更换\n（1）在工程目录下载主题 $ git clone https://github.com/litten/hexo-theme-yilia.git    themes/yilia\n（2）修改工程目录下的_config.yml文件 ：      theme:   yilia\n\n10.添加分类和标签\nmd文章头直接加就可以了\ncategories: fdbook\ntags: fdbook\n\n11.如何显示图片\n``` bash\n（1）本地：在工程目录下的source下新建文件夹images，使用例子： ![](/images/fd.jpg) \n（2）网络：![图片描叙](网路地址)\n```\n\n12.修改网站小图标\n在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg\n\n13.截取文章显示\n（1）在主题目录下修改_config.yml文件 ：excerpt_link: more\n（2）在文章需要截取的地方加上 \n``` bash\n <!-- more -->\n```\n14.加访客统计和文章统计\n\n[参考链接](https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/)\n\n15.评论功能\n!index 表示非主页中才显示\n\n[参考链接](http://moxfive.xyz/2016/01/02/hexo-comments/)\n\n    \n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello Hexo\ndate: 2017-05-09 00:00:00\ncategories: 多学\ntags: hexo\n---\n\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.下载安装[Node.js](https://nodejs.org/en/)（一路next）\n3.下载hexo： 命令行 输入\n``` bash\n$ npm install -g hexo-cli\n```\n<!-- more -->\n\n4.验证软件是否成功安装\n``` bash\n$ git --version\n$ node -v\n$ npm -v\n$ hexo –v\n```\n5.新建GitHub版本库 \n注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名\n\n6.配置ssh\n（1）设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n（2）生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n7.初始化hexo\n（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开\ngit bash，输入\n``` bash\n$ hexo init\n```\n安装生成器 ：\n``` bash\n$ npm install\n```\n然后就可以新建文章了\n``` bash\n$ hexo new name\n```\n8.运行和部署hexo\n（1）本地查看 ：\n``` bash\n$ hexo g && hexo s –p 5000\n```\n浏览器输入localhost:5000,就可以在本地看到你的个人博客了 \n（2）上传git：\n下载插件：\n``` bash\n$ npm install hexo-deployer-git --save\n```\n修改工程目录下的_config.yml文件\n#发布设置\ndeploy: \n \t\ttype: git\n  \t\trepository: git@github.com:chenbaowu/chenbaowu.github.io.git\n  \t\tbranch: master\n运行 ：\n``` bash\n$ hexo g && hexo d\n```\n浏览器输入 http://chenbaowu.github.io/  就可以访问了\n\n9.主题更换\n（1）在工程目录下载主题 $ git clone https://github.com/litten/hexo-theme-yilia.git    themes/yilia\n（2）修改工程目录下的_config.yml文件 ：      theme:   yilia\n\n10.添加分类和标签\nmd文章头直接加就可以了\ncategories: fdbook\ntags: fdbook\n\n11.如何显示图片\n``` bash\n（1）本地：在工程目录下的source下新建文件夹images，使用例子： ![](/images/fd.jpg) \n（2）网络：![图片描叙](网路地址)\n```\n\n12.修改网站小图标\n在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg\n\n13.截取文章显示\n（1）在主题目录下修改_config.yml文件 ：excerpt_link: more\n（2）在文章需要截取的地方加上 \n``` bash\n <!-- more -->\n```\n14.加访客统计和文章统计\n\n[参考链接](https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/)\n\n15.评论功能\n!index 表示非主页中才显示\n\n[参考链接](http://moxfive.xyz/2016/01/02/hexo-comments/)\n\n    \n","slug":"hello-world","published":1,"updated":"2018-02-10T06:53:50.942Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gb5000io4l1hixx78bt","content":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.下载安装<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js</a>（一路next）<br>3.下载hexo： 命令行 输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>4.验证软件是否成功安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git --version</div><div class=\"line\">$ node -v</div><div class=\"line\">$ npm -v</div><div class=\"line\">$ hexo –v</div></pre></td></tr></table></figure></p>\n<p>5.新建GitHub版本库<br>注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名</p>\n<p>6.配置ssh<br>（1）设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>\n<p>（2）生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>7.初始化hexo<br>（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开<br>git bash，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init</div></pre></td></tr></table></figure></p>\n<p>安装生成器 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>然后就可以新建文章了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new name</div></pre></td></tr></table></figure></p>\n<p>8.运行和部署hexo<br>（1）本地查看 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo s –p 5000</div></pre></td></tr></table></figure></p>\n<p>浏览器输入localhost:5000,就可以在本地看到你的个人博客了<br>（2）上传git：<br>下载插件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>修改工程目录下的_config.yml文件</p>\n<p>#发布设置<br>deploy:<br>         type: git<br>          repository: git@github.com:chenbaowu/chenbaowu.github.io.git<br>          branch: master<br>运行 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo d</div></pre></td></tr></table></figure></p>\n<p>浏览器输入 <a href=\"http://chenbaowu.github.io/\" target=\"_blank\" rel=\"external\">http://chenbaowu.github.io/</a>  就可以访问了</p>\n<p>9.主题更换<br>（1）在工程目录下载主题 $ git clone <a href=\"https://github.com/litten/hexo-theme-yilia.git\" target=\"_blank\" rel=\"external\">https://github.com/litten/hexo-theme-yilia.git</a>    themes/yilia<br>（2）修改工程目录下的_config.yml文件 ：      theme:   yilia</p>\n<p>10.添加分类和标签<br>md文章头直接加就可以了<br>categories: fdbook<br>tags: fdbook</p>\n<p>11.如何显示图片<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）本地：在工程目录下的<span class=\"built_in\">source</span>下新建文件夹images，使用例子： ![](/images/fd.jpg) </div><div class=\"line\">（2）网络：![图片描叙](网路地址)</div></pre></td></tr></table></figure></p>\n<p>12.修改网站小图标<br>在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg</p>\n<p>13.截取文章显示<br>（1）在主题目录下修改_config.yml文件 ：excerpt_link: more<br>（2）在文章需要截取的地方加上<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- more --&gt;</div></pre></td></tr></table></figure></p>\n<p>14.加访客统计和文章统计</p>\n<p><a href=\"https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n<p>15.评论功能<br>!index 表示非主页中才显示</p>\n<p><a href=\"http://moxfive.xyz/2016/01/02/hexo-comments/\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n","site":{"data":{}},"excerpt":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.下载安装<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js</a>（一路next）<br>3.下载hexo： 命令行 输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>","more":"<p>4.验证软件是否成功安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git --version</div><div class=\"line\">$ node -v</div><div class=\"line\">$ npm -v</div><div class=\"line\">$ hexo –v</div></pre></td></tr></table></figure></p>\n<p>5.新建GitHub版本库<br>注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名</p>\n<p>6.配置ssh<br>（1）设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>\n<p>（2）生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>7.初始化hexo<br>（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开<br>git bash，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init</div></pre></td></tr></table></figure></p>\n<p>安装生成器 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>然后就可以新建文章了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new name</div></pre></td></tr></table></figure></p>\n<p>8.运行和部署hexo<br>（1）本地查看 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo s –p 5000</div></pre></td></tr></table></figure></p>\n<p>浏览器输入localhost:5000,就可以在本地看到你的个人博客了<br>（2）上传git：<br>下载插件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>修改工程目录下的_config.yml文件</p>\n<p>#发布设置<br>deploy:<br>         type: git<br>          repository: git@github.com:chenbaowu/chenbaowu.github.io.git<br>          branch: master<br>运行 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo d</div></pre></td></tr></table></figure></p>\n<p>浏览器输入 <a href=\"http://chenbaowu.github.io/\" target=\"_blank\" rel=\"external\">http://chenbaowu.github.io/</a>  就可以访问了</p>\n<p>9.主题更换<br>（1）在工程目录下载主题 $ git clone <a href=\"https://github.com/litten/hexo-theme-yilia.git\" target=\"_blank\" rel=\"external\">https://github.com/litten/hexo-theme-yilia.git</a>    themes/yilia<br>（2）修改工程目录下的_config.yml文件 ：      theme:   yilia</p>\n<p>10.添加分类和标签<br>md文章头直接加就可以了<br>categories: fdbook<br>tags: fdbook</p>\n<p>11.如何显示图片<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）本地：在工程目录下的<span class=\"built_in\">source</span>下新建文件夹images，使用例子： ![](/images/fd.jpg) </div><div class=\"line\">（2）网络：![图片描叙](网路地址)</div></pre></td></tr></table></figure></p>\n<p>12.修改网站小图标<br>在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg</p>\n<p>13.截取文章显示<br>（1）在主题目录下修改_config.yml文件 ：excerpt_link: more<br>（2）在文章需要截取的地方加上<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- more --&gt;</div></pre></td></tr></table></figure></p>\n<p>14.加访客统计和文章统计</p>\n<p><a href=\"https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n<p>15.评论功能<br>!index 表示非主页中才显示</p>\n<p><a href=\"http://moxfive.xyz/2016/01/02/hexo-comments/\" target=\"_blank\" rel=\"external\">参考链接</a></p>"},{"title":"java_reference","date":"2017-05-09T07:35:10.000Z","_content":"\n## Java四种基本引用\n\n1．强引用\n本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n2．软引用（SoftReference）\n\n如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n3．弱引用（WeakReference）\n如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n4．虚引用（PhantomReference）\n\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。\n当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n","source":"_posts/java-reference.md","raw":"---\ntitle: java_reference\ndate: 2017-05-9 15:35:10\ncategories: android\ntags: java\n---\n\n## Java四种基本引用\n\n1．强引用\n本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n2．软引用（SoftReference）\n\n如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n3．弱引用（WeakReference）\n如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n4．虚引用（PhantomReference）\n\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。\n当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n","slug":"java-reference","published":1,"updated":"2018-02-10T06:53:50.945Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gb9000no4l1aqwut7z4","content":"<h2 id=\"Java四种基本引用\"><a href=\"#Java四种基本引用\" class=\"headerlink\" title=\"Java四种基本引用\"></a>Java四种基本引用</h2><p>1．强引用<br>本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n<p>2．软引用（SoftReference）</p>\n<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3．弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>4．虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。<br>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java四种基本引用\"><a href=\"#Java四种基本引用\" class=\"headerlink\" title=\"Java四种基本引用\"></a>Java四种基本引用</h2><p>1．强引用<br>本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n<p>2．软引用（SoftReference）</p>\n<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3．弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>4．虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。<br>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n"},{"title":"optimization_ui","date":"2017-08-27T06:33:03.000Z","_content":"\n## android ui 优化\n\nAndroid UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。\n\nandroid每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。\n\n<!-- more -->\n\n渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。\n\nAndroid的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。\n\n绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。\n\n在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。\n\n在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。\n\n硬件加速的3个缺陷：\n1. 兼容新，部分绘制方式不支持或者不完全支持硬件方式；\n2. 内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。\n3. 电量消耗，GPU耗电较多。\n\n显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。\n\n引发掉帧的原因：\n1）大量的重绘\n2）过度绘制，在在绘制用户看不到的对象上花太多时间\n3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源\n4）频繁地触发垃圾回收\n5）ViewGroup树太深\n所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。\n\n界面开发优化的Advice：\n1. 优化布局的结构\n1）避免复杂的View层次\n2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout\n3）布局层级一样的情况下，用LinearLayout代替RelativeLayout\n4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级\n5）不使用AbsoluteLayout\n6）尽量比曼使用LayoutWeight\n7）合理的布局应该是宽而浅，而非窄而深\n2. 优化处理逻辑\n1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载\n2）避免在UI线程中进行耗时操作\n3. 使用Android自带的性能测试工具进行优化\n\nRelativeLayout与LinearLayout性能比较\n1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）\n2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin\n3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout\n4） 在复杂布局下，用RelativeLayout减少布局层级","source":"_posts/optimization-ui.md","raw":"---\ntitle: optimization_ui\ndate: 2017-08-27 14:33:03\ntags: 优化\n---\n\n## android ui 优化\n\nAndroid UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。\n\nandroid每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。\n\n<!-- more -->\n\n渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。\n\nAndroid的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。\n\n绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。\n\n在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。\n\n在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。\n\n硬件加速的3个缺陷：\n1. 兼容新，部分绘制方式不支持或者不完全支持硬件方式；\n2. 内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。\n3. 电量消耗，GPU耗电较多。\n\n显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。\n\n引发掉帧的原因：\n1）大量的重绘\n2）过度绘制，在在绘制用户看不到的对象上花太多时间\n3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源\n4）频繁地触发垃圾回收\n5）ViewGroup树太深\n所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。\n\n界面开发优化的Advice：\n1. 优化布局的结构\n1）避免复杂的View层次\n2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout\n3）布局层级一样的情况下，用LinearLayout代替RelativeLayout\n4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级\n5）不使用AbsoluteLayout\n6）尽量比曼使用LayoutWeight\n7）合理的布局应该是宽而浅，而非窄而深\n2. 优化处理逻辑\n1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载\n2）避免在UI线程中进行耗时操作\n3. 使用Android自带的性能测试工具进行优化\n\nRelativeLayout与LinearLayout性能比较\n1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）\n2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin\n3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout\n4） 在复杂布局下，用RelativeLayout减少布局层级","slug":"optimization-ui","published":1,"updated":"2018-02-10T06:53:50.950Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbc000qo4l13by1t2go","content":"<h2 id=\"android-ui-优化\"><a href=\"#android-ui-优化\" class=\"headerlink\" title=\"android ui 优化\"></a>android ui 优化</h2><p>Android UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。</p>\n<p>android每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。</p>\n<a id=\"more\"></a>\n<p>渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。</p>\n<p>Android的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。</p>\n<p>绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。</p>\n<p>在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。</p>\n<p>在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。</p>\n<p>硬件加速的3个缺陷：</p>\n<ol>\n<li>兼容新，部分绘制方式不支持或者不完全支持硬件方式；</li>\n<li>内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。</li>\n<li>电量消耗，GPU耗电较多。</li>\n</ol>\n<p>显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。</p>\n<p>引发掉帧的原因：<br>1）大量的重绘<br>2）过度绘制，在在绘制用户看不到的对象上花太多时间<br>3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源<br>4）频繁地触发垃圾回收<br>5）ViewGroup树太深<br>所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。</p>\n<p>界面开发优化的Advice：</p>\n<ol>\n<li>优化布局的结构<br>1）避免复杂的View层次<br>2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout<br>3）布局层级一样的情况下，用LinearLayout代替RelativeLayout<br>4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级<br>5）不使用AbsoluteLayout<br>6）尽量比曼使用LayoutWeight<br>7）合理的布局应该是宽而浅，而非窄而深</li>\n<li>优化处理逻辑<br>1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载<br>2）避免在UI线程中进行耗时操作</li>\n<li>使用Android自带的性能测试工具进行优化</li>\n</ol>\n<p>RelativeLayout与LinearLayout性能比较<br>1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）<br>2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin<br>3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout<br>4） 在复杂布局下，用RelativeLayout减少布局层级</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"android-ui-优化\"><a href=\"#android-ui-优化\" class=\"headerlink\" title=\"android ui 优化\"></a>android ui 优化</h2><p>Android UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。</p>\n<p>android每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。</p>","more":"<p>渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。</p>\n<p>Android的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。</p>\n<p>绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。</p>\n<p>在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。</p>\n<p>在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。</p>\n<p>硬件加速的3个缺陷：</p>\n<ol>\n<li>兼容新，部分绘制方式不支持或者不完全支持硬件方式；</li>\n<li>内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。</li>\n<li>电量消耗，GPU耗电较多。</li>\n</ol>\n<p>显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。</p>\n<p>引发掉帧的原因：<br>1）大量的重绘<br>2）过度绘制，在在绘制用户看不到的对象上花太多时间<br>3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源<br>4）频繁地触发垃圾回收<br>5）ViewGroup树太深<br>所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。</p>\n<p>界面开发优化的Advice：</p>\n<ol>\n<li>优化布局的结构<br>1）避免复杂的View层次<br>2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout<br>3）布局层级一样的情况下，用LinearLayout代替RelativeLayout<br>4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级<br>5）不使用AbsoluteLayout<br>6）尽量比曼使用LayoutWeight<br>7）合理的布局应该是宽而浅，而非窄而深</li>\n<li>优化处理逻辑<br>1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载<br>2）避免在UI线程中进行耗时操作</li>\n<li>使用Android自带的性能测试工具进行优化</li>\n</ol>\n<p>RelativeLayout与LinearLayout性能比较<br>1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）<br>2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin<br>3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout<br>4） 在复杂布局下，用RelativeLayout减少布局层级</p>"},{"title":"浅谈matrix","date":"2017-05-13T08:18:48.000Z","_content":"\n## 基本api\n\n| 方法类别  | \t\t\t\t相关API\t    \t\t\t\t\t\t\t|  摘要  |\n| --------  | \t\t\t\t-----:   \t\t\t\t\t\t\t\t| :----: |\n|基本方法\t|equals hashCode toString toShortString\t\t\t\t\t|比较、 获取哈希值、 转换为字符串\n|数值操作\t|set reset setValues getValues\t\t\t\t\t\t\t|设置、 重置、 设置数值、 获取数值\n|数值计算\t|mapPoints mapRadius mapRect mapVectors\t\t\t\t\t|计算变换后的数值\n|设置(set)\t|setConcat setRotate setScale setSkew setTranslate\t\t|设置变换\n|前乘(pre)\t|preConcat preRotate preScale preSkew preTranslate\t\t|前乘变换\n|后乘(post)\t|postConcat postRotate postScale postSkew postTranslate\t|后乘变换\n|特殊方法\t|setPolyToPoly setRectToRect rectStaysRect setSinCos\t|一些特殊操作\n|矩阵相关\t|invert isAffine(API21) isIdentity\t\t\t\t\t\t|求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵\n\n<!-- more -->\n\n## what is matrix\n\nMatrix是一个矩阵，主要功能是坐标映射，数值转换。\n\n![](http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg)\n\n![](http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg)\n1.缩放(Scale)\n\nx = k1 * x0\ny = k2 * y0\n\n用矩阵表示:\n[x]\t  [k1 0  0] [x0]\n[y] = [0  k2 0] [y0]\n[1]\t  [0  0  1] [1]\n\n2.错切(Skew)\n![](http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png)\n\n3.旋转(Rotate)\n![](http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png)\n\n4.平移(Translate)\n![](http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png)\n\n5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意\n\n## Matrix 常用api\n\n1.setValues getValues\n``` bash\nvoid setValues (float[] values)\nsetValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。\n\nvoid getValues (float[] values) \n```\n2.mapPoints\n``` bash\nvoid mapPoints (float[] pts)\n\nvoid mapPoints (float[] dst, float[] src)\n\nvoid mapPoints (float[] dst, int dstIndex,float[] src, int srcIndex, int pointCount)\n\n计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的float数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)\n```\n3.mapRadius\n``` bash\nfloat mapRadius (float radius)\n测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径\n```\n4.mapRect : 测量矩形变换后位置\n``` bash\nboolean mapRect (RectF rect)\n\nboolean mapRect (RectF dst, RectF src)\n```\n5.4.mapVectors : 测量向量\n``` bash\nvoid mapVectors (float[] vecs)\n\nvoid mapVectors (float[] dst, float[] src)\n\nvoid mapVectors (float[] dst, int dstIndex, float[] src, int srcIndex, int vectorCount)\n\n//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律\n\nfloat[] src = new float[]{1000, 800};\nfloat[] dst = new float[2];\n\n// 构造一个matrix\nMatrix matrix = new Matrix();\nmatrix.setScale(0.5f, 1f);\nmatrix.postTranslate(100,100);\n\n// 计算向量, 不受位移影响\nmatrix.mapVectors(dst, src);\nLog.i(TAG, \"mapVectors: \"+Arrays.toString(dst));\n\n// 计算点\nmatrix.mapPoints(dst, src);\nLog.i(TAG, \"mapPoints: \"+Arrays.toString(dst));\n\n//结果:\nmapVectors: [500.0, 800.0]\nmapPoints: [600.0, 900.0]\n```\n\n## Matrix 特殊使用\n\n1.invert\n求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍\n\n2.isAffine\n判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。\n\n3.isIdentity ：判断是否为单位矩阵\n\n4. 获取View在屏幕上的绝对位置\n``` bash\n@Override\nprotected void onDraw(Canvas canvas) {\n    float[] values = new float[9];\n    int[] location1 = new int[2];\n\n    Matrix matrix = canvas.getMatrix();\n    matrix.getValues(values);\n\n    location1[0] = (int) values[2];\n    location1[1] = (int) values[5];\n    Log.i(TAG, \"location1 = \" + Arrays.toString(location1));\n\n    int[] location2 = new int[2];\n    this.getLocationOnScreen(location2);\n    Log.i(TAG, \"location2 = \" + Arrays.toString(location2));\n}\n```\n5.setRectToRect\n``` bash\nboolean setRectToRect (RectF src,           // 源区域\n                RectF dst,                  // 目标区域\n                Matrix.ScaleToFit stf)      // 缩放适配模式\n简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定\n```\nScaleToFit 是一个枚举类型，共包含了四种模式:\n\n| 方法类别  |  摘要  |\n| --------  | :----: |\n|CENTER\t| 居中，对src等比例缩放，将其居中放置在dst中\n|START\t| 顶部，对src等比例缩放，将其放置在dst的左上角。\n|END\t| 底部，对src等比例缩放，将其放置在dst的右下角。\n|FILL\t| 充满，拉伸src的宽和高，使其完全填充满dst。\n\n6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。\n``` bash\nboolean setPolyToPoly (\n        float[] src,    // 原始数组 src [x,y]，存储内容为一组点\n        int srcIndex,   // 原始数组开始位置\n        float[] dst,    // 目标数组 dst [x,y]，存储内容为一组点\n        int dstIndex,   // 目标数组开始位置\n        int pointCount) // 测控点的数量 取值范围是: 0到4\n```\n\n从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。\n\n| pointCount  | 摘要 |\n| --------  | :----: |\n|\t  0\t    | 相当于reset\n|     1\t\t| 相当于translate\t\t\t\t\n|     2\t\t| 可以进行 缩放、旋转、平移 变换\n|     3\t\t| 可以进行 缩放、旋转、平移、错切 变换 \n|     4\t\t| 可以进行 缩放、旋转、平移、错切以及任何形变 \n``` bash\npublic class MatrixSetPolyToPolyTest extends View {\n\n    private Bitmap mBitmap;             // 要绘制的图片\n    private Matrix mPolyMatrix;         // 测试setPolyToPoly用的Matrix\n\n    public MatrixSetPolyToPolyTest(Context context) {\n        super(context);\n\n        initBitmapAndMatrix();\n    }\n\n    private void initBitmapAndMatrix() {\n        mBitmap = BitmapFactory.decodeResource(getResources(),\n                R.drawable.poly_test);\n\n        mPolyMatrix = new Matrix();\n\n\n        float[] src = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 0,                          // 右上\n                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        float[] dst = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 400,                        // 右上\n                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        // 核心要点\n        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length >> 1); // src.length >> 1 为位移运算 相当于处以2\n\n        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)\n        mPolyMatrix.postScale(0.26f, 0.26f);\n        mPolyMatrix.postTranslate(0,200);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        // 根据Matrix绘制一个变换后的图片\n        canvas.drawBitmap(mBitmap, mPolyMatrix, null);\n    }\n}\n```\n\n","source":"_posts/matrix.md","raw":"---\ntitle: 浅谈matrix\ndate: 2017-05-13 16:18:48\ncategories: android\ntags: matrix\n---\n\n## 基本api\n\n| 方法类别  | \t\t\t\t相关API\t    \t\t\t\t\t\t\t|  摘要  |\n| --------  | \t\t\t\t-----:   \t\t\t\t\t\t\t\t| :----: |\n|基本方法\t|equals hashCode toString toShortString\t\t\t\t\t|比较、 获取哈希值、 转换为字符串\n|数值操作\t|set reset setValues getValues\t\t\t\t\t\t\t|设置、 重置、 设置数值、 获取数值\n|数值计算\t|mapPoints mapRadius mapRect mapVectors\t\t\t\t\t|计算变换后的数值\n|设置(set)\t|setConcat setRotate setScale setSkew setTranslate\t\t|设置变换\n|前乘(pre)\t|preConcat preRotate preScale preSkew preTranslate\t\t|前乘变换\n|后乘(post)\t|postConcat postRotate postScale postSkew postTranslate\t|后乘变换\n|特殊方法\t|setPolyToPoly setRectToRect rectStaysRect setSinCos\t|一些特殊操作\n|矩阵相关\t|invert isAffine(API21) isIdentity\t\t\t\t\t\t|求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵\n\n<!-- more -->\n\n## what is matrix\n\nMatrix是一个矩阵，主要功能是坐标映射，数值转换。\n\n![](http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg)\n\n![](http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg)\n1.缩放(Scale)\n\nx = k1 * x0\ny = k2 * y0\n\n用矩阵表示:\n[x]\t  [k1 0  0] [x0]\n[y] = [0  k2 0] [y0]\n[1]\t  [0  0  1] [1]\n\n2.错切(Skew)\n![](http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png)\n\n3.旋转(Rotate)\n![](http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png)\n\n4.平移(Translate)\n![](http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png)\n\n5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意\n\n## Matrix 常用api\n\n1.setValues getValues\n``` bash\nvoid setValues (float[] values)\nsetValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。\n\nvoid getValues (float[] values) \n```\n2.mapPoints\n``` bash\nvoid mapPoints (float[] pts)\n\nvoid mapPoints (float[] dst, float[] src)\n\nvoid mapPoints (float[] dst, int dstIndex,float[] src, int srcIndex, int pointCount)\n\n计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的float数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)\n```\n3.mapRadius\n``` bash\nfloat mapRadius (float radius)\n测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径\n```\n4.mapRect : 测量矩形变换后位置\n``` bash\nboolean mapRect (RectF rect)\n\nboolean mapRect (RectF dst, RectF src)\n```\n5.4.mapVectors : 测量向量\n``` bash\nvoid mapVectors (float[] vecs)\n\nvoid mapVectors (float[] dst, float[] src)\n\nvoid mapVectors (float[] dst, int dstIndex, float[] src, int srcIndex, int vectorCount)\n\n//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律\n\nfloat[] src = new float[]{1000, 800};\nfloat[] dst = new float[2];\n\n// 构造一个matrix\nMatrix matrix = new Matrix();\nmatrix.setScale(0.5f, 1f);\nmatrix.postTranslate(100,100);\n\n// 计算向量, 不受位移影响\nmatrix.mapVectors(dst, src);\nLog.i(TAG, \"mapVectors: \"+Arrays.toString(dst));\n\n// 计算点\nmatrix.mapPoints(dst, src);\nLog.i(TAG, \"mapPoints: \"+Arrays.toString(dst));\n\n//结果:\nmapVectors: [500.0, 800.0]\nmapPoints: [600.0, 900.0]\n```\n\n## Matrix 特殊使用\n\n1.invert\n求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍\n\n2.isAffine\n判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。\n\n3.isIdentity ：判断是否为单位矩阵\n\n4. 获取View在屏幕上的绝对位置\n``` bash\n@Override\nprotected void onDraw(Canvas canvas) {\n    float[] values = new float[9];\n    int[] location1 = new int[2];\n\n    Matrix matrix = canvas.getMatrix();\n    matrix.getValues(values);\n\n    location1[0] = (int) values[2];\n    location1[1] = (int) values[5];\n    Log.i(TAG, \"location1 = \" + Arrays.toString(location1));\n\n    int[] location2 = new int[2];\n    this.getLocationOnScreen(location2);\n    Log.i(TAG, \"location2 = \" + Arrays.toString(location2));\n}\n```\n5.setRectToRect\n``` bash\nboolean setRectToRect (RectF src,           // 源区域\n                RectF dst,                  // 目标区域\n                Matrix.ScaleToFit stf)      // 缩放适配模式\n简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定\n```\nScaleToFit 是一个枚举类型，共包含了四种模式:\n\n| 方法类别  |  摘要  |\n| --------  | :----: |\n|CENTER\t| 居中，对src等比例缩放，将其居中放置在dst中\n|START\t| 顶部，对src等比例缩放，将其放置在dst的左上角。\n|END\t| 底部，对src等比例缩放，将其放置在dst的右下角。\n|FILL\t| 充满，拉伸src的宽和高，使其完全填充满dst。\n\n6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。\n``` bash\nboolean setPolyToPoly (\n        float[] src,    // 原始数组 src [x,y]，存储内容为一组点\n        int srcIndex,   // 原始数组开始位置\n        float[] dst,    // 目标数组 dst [x,y]，存储内容为一组点\n        int dstIndex,   // 目标数组开始位置\n        int pointCount) // 测控点的数量 取值范围是: 0到4\n```\n\n从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。\n\n| pointCount  | 摘要 |\n| --------  | :----: |\n|\t  0\t    | 相当于reset\n|     1\t\t| 相当于translate\t\t\t\t\n|     2\t\t| 可以进行 缩放、旋转、平移 变换\n|     3\t\t| 可以进行 缩放、旋转、平移、错切 变换 \n|     4\t\t| 可以进行 缩放、旋转、平移、错切以及任何形变 \n``` bash\npublic class MatrixSetPolyToPolyTest extends View {\n\n    private Bitmap mBitmap;             // 要绘制的图片\n    private Matrix mPolyMatrix;         // 测试setPolyToPoly用的Matrix\n\n    public MatrixSetPolyToPolyTest(Context context) {\n        super(context);\n\n        initBitmapAndMatrix();\n    }\n\n    private void initBitmapAndMatrix() {\n        mBitmap = BitmapFactory.decodeResource(getResources(),\n                R.drawable.poly_test);\n\n        mPolyMatrix = new Matrix();\n\n\n        float[] src = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 0,                          // 右上\n                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        float[] dst = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 400,                        // 右上\n                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        // 核心要点\n        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length >> 1); // src.length >> 1 为位移运算 相当于处以2\n\n        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)\n        mPolyMatrix.postScale(0.26f, 0.26f);\n        mPolyMatrix.postTranslate(0,200);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        // 根据Matrix绘制一个变换后的图片\n        canvas.drawBitmap(mBitmap, mPolyMatrix, null);\n    }\n}\n```\n\n","slug":"matrix","published":1,"updated":"2018-02-10T06:53:50.949Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbf000uo4l1rus690io","content":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本方法</td>\n<td style=\"text-align:right\">equals hashCode toString toShortString</td>\n<td style=\"text-align:center\">比较、 获取哈希值、 转换为字符串</td>\n</tr>\n<tr>\n<td>数值操作</td>\n<td style=\"text-align:right\">set reset setValues getValues</td>\n<td style=\"text-align:center\">设置、 重置、 设置数值、 获取数值</td>\n</tr>\n<tr>\n<td>数值计算</td>\n<td style=\"text-align:right\">mapPoints mapRadius mapRect mapVectors</td>\n<td style=\"text-align:center\">计算变换后的数值</td>\n</tr>\n<tr>\n<td>设置(set)</td>\n<td style=\"text-align:right\">setConcat setRotate setScale setSkew setTranslate</td>\n<td style=\"text-align:center\">设置变换</td>\n</tr>\n<tr>\n<td>前乘(pre)</td>\n<td style=\"text-align:right\">preConcat preRotate preScale preSkew preTranslate</td>\n<td style=\"text-align:center\">前乘变换</td>\n</tr>\n<tr>\n<td>后乘(post)</td>\n<td style=\"text-align:right\">postConcat postRotate postScale postSkew postTranslate</td>\n<td style=\"text-align:center\">后乘变换</td>\n</tr>\n<tr>\n<td>特殊方法</td>\n<td style=\"text-align:right\">setPolyToPoly setRectToRect rectStaysRect setSinCos</td>\n<td style=\"text-align:center\">一些特殊操作</td>\n</tr>\n<tr>\n<td>矩阵相关</td>\n<td style=\"text-align:right\">invert isAffine(API21) isIdentity</td>\n<td style=\"text-align:center\">求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"what-is-matrix\"><a href=\"#what-is-matrix\" class=\"headerlink\" title=\"what is matrix\"></a>what is matrix</h2><p>Matrix是一个矩阵，主要功能是坐标映射，数值转换。</p>\n<p><img src=\"http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg\" alt=\"\"><br>1.缩放(Scale)</p>\n<p>x = k1 <em> x0<br>y = k2 </em> y0</p>\n<p>用矩阵表示:<br>[x]      [k1 0  0] [x0]<br>[y] = [0  k2 0] [y0]<br>[1]      [0  0  1] [1]</p>\n<p>2.错切(Skew)<br><img src=\"http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png\" alt=\"\"></p>\n<p>3.旋转(Rotate)<br><img src=\"http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png\" alt=\"\"></p>\n<p>4.平移(Translate)<br><img src=\"http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png\" alt=\"\"></p>\n<p>5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意</p>\n<h2 id=\"Matrix-常用api\"><a href=\"#Matrix-常用api\" class=\"headerlink\" title=\"Matrix 常用api\"></a>Matrix 常用api</h2><p>1.setValues getValues<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void <span class=\"built_in\">set</span>Values (<span class=\"built_in\">float</span>[] values)</div><div class=\"line\"><span class=\"built_in\">set</span>Values的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</div><div class=\"line\"></div><div class=\"line\">void getValues (<span class=\"built_in\">float</span>[] values)</div></pre></td></tr></table></figure></p>\n<p>2.mapPoints<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] pts)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, int dstIndex,<span class=\"built_in\">float</span>[] src, int srcIndex, int pointCount)</div><div class=\"line\"></div><div class=\"line\">计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的<span class=\"built_in\">float</span>数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)</div></pre></td></tr></table></figure></p>\n<p>3.mapRadius<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">float</span> mapRadius (<span class=\"built_in\">float</span> radius)</div><div class=\"line\">测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径</div></pre></td></tr></table></figure></p>\n<p>4.mapRect : 测量矩形变换后位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean mapRect (RectF rect)</div><div class=\"line\"></div><div class=\"line\">boolean mapRect (RectF dst, RectF src)</div></pre></td></tr></table></figure></p>\n<p>5.4.mapVectors : 测量向量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] vecs)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, int dstIndex, <span class=\"built_in\">float</span>[] src, int srcIndex, int vectorCount)</div><div class=\"line\"></div><div class=\"line\">//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">float</span>[] src = new <span class=\"built_in\">float</span>[]&#123;1000, 800&#125;;</div><div class=\"line\"><span class=\"built_in\">float</span>[] dst = new <span class=\"built_in\">float</span>[2];</div><div class=\"line\"></div><div class=\"line\">// 构造一个matrix</div><div class=\"line\">Matrix matrix = new Matrix();</div><div class=\"line\">matrix.setScale(0.5f, 1f);</div><div class=\"line\">matrix.postTranslate(100,100);</div><div class=\"line\"></div><div class=\"line\">// 计算向量, 不受位移影响</div><div class=\"line\">matrix.mapVectors(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapVectors: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">// 计算点</div><div class=\"line\">matrix.mapPoints(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapPoints: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">//结果:</div><div class=\"line\">mapVectors: [500.0, 800.0]</div><div class=\"line\">mapPoints: [600.0, 900.0]</div></pre></td></tr></table></figure></p>\n<h2 id=\"Matrix-特殊使用\"><a href=\"#Matrix-特殊使用\" class=\"headerlink\" title=\"Matrix 特殊使用\"></a>Matrix 特殊使用</h2><p>1.invert<br>求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍</p>\n<p>2.isAffine<br>判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。</p>\n<p>3.isIdentity ：判断是否为单位矩阵</p>\n<ol>\n<li>获取View在屏幕上的绝对位置<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    <span class=\"built_in\">float</span>[] values = new <span class=\"built_in\">float</span>[9];</div><div class=\"line\">    int[] location1 = new int[2];</div><div class=\"line\"></div><div class=\"line\">    Matrix matrix = canvas.getMatrix();</div><div class=\"line\">    matrix.getValues(values);</div><div class=\"line\"></div><div class=\"line\">    location1[0] = (int) values[2];</div><div class=\"line\">    location1[1] = (int) values[5];</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location1 = \"</span> + Arrays.toString(location1));</div><div class=\"line\"></div><div class=\"line\">    int[] location2 = new int[2];</div><div class=\"line\">    this.getLocationOnScreen(location2);</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location2 = \"</span> + Arrays.toString(location2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>5.setRectToRect<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>RectToRect (RectF src,           // 源区域</div><div class=\"line\">                RectF dst,                  // 目标区域</div><div class=\"line\">                Matrix.ScaleToFit stf)      // 缩放适配模式</div><div class=\"line\">简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定</div></pre></td></tr></table></figure></p>\n<p>ScaleToFit 是一个枚举类型，共包含了四种模式:</p>\n<table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CENTER</td>\n<td style=\"text-align:center\">居中，对src等比例缩放，将其居中放置在dst中</td>\n</tr>\n<tr>\n<td>START</td>\n<td style=\"text-align:center\">顶部，对src等比例缩放，将其放置在dst的左上角。</td>\n</tr>\n<tr>\n<td>END</td>\n<td style=\"text-align:center\">底部，对src等比例缩放，将其放置在dst的右下角。</td>\n</tr>\n<tr>\n<td>FILL</td>\n<td style=\"text-align:center\">充满，拉伸src的宽和高，使其完全填充满dst。</td>\n</tr>\n</tbody>\n</table>\n<p>6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>PolyToPoly (</div><div class=\"line\">        <span class=\"built_in\">float</span>[] src,    // 原始数组 src [x,y]，存储内容为一组点</div><div class=\"line\">        int srcIndex,   // 原始数组开始位置</div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst,    // 目标数组 dst [x,y]，存储内容为一组点</div><div class=\"line\">        int dstIndex,   // 目标数组开始位置</div><div class=\"line\">        int pointCount) // 测控点的数量 取值范围是: 0到4</div></pre></td></tr></table></figure></p>\n<p>从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。</p>\n<table>\n<thead>\n<tr>\n<th>pointCount</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">相当于reset</td>\n</tr>\n<tr>\n<td>1</td>\n<td style=\"text-align:center\">相当于translate                </td>\n</tr>\n<tr>\n<td>2</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移 变换</td>\n</tr>\n<tr>\n<td>3</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切 变换 </td>\n</tr>\n<tr>\n<td>4</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切以及任何形变 </td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MatrixSetPolyToPolyTest extends View &#123;</div><div class=\"line\"></div><div class=\"line\">    private Bitmap mBitmap;             // 要绘制的图片</div><div class=\"line\">    private Matrix mPolyMatrix;         // 测试<span class=\"built_in\">set</span>PolyToPoly用的Matrix</div><div class=\"line\"></div><div class=\"line\">    public MatrixSetPolyToPolyTest(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\"></div><div class=\"line\">        initBitmapAndMatrix();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void <span class=\"function\"><span class=\"title\">initBitmapAndMatrix</span></span>() &#123;</div><div class=\"line\">        mBitmap = BitmapFactory.decodeResource(getResources(),</div><div class=\"line\">                R.drawable.poly_test);</div><div class=\"line\"></div><div class=\"line\">        mPolyMatrix = new Matrix();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] src = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 0,                          // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 400,                        // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        // 核心要点</div><div class=\"line\">        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); // src.length &gt;&gt; 1 为位移运算 相当于处以2</div><div class=\"line\"></div><div class=\"line\">        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)</div><div class=\"line\">        mPolyMatrix.postScale(0.26f, 0.26f);</div><div class=\"line\">        mPolyMatrix.postTranslate(0,200);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">        super.onDraw(canvas);</div><div class=\"line\"></div><div class=\"line\">        // 根据Matrix绘制一个变换后的图片</div><div class=\"line\">        canvas.drawBitmap(mBitmap, mPolyMatrix, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本方法</td>\n<td style=\"text-align:right\">equals hashCode toString toShortString</td>\n<td style=\"text-align:center\">比较、 获取哈希值、 转换为字符串</td>\n</tr>\n<tr>\n<td>数值操作</td>\n<td style=\"text-align:right\">set reset setValues getValues</td>\n<td style=\"text-align:center\">设置、 重置、 设置数值、 获取数值</td>\n</tr>\n<tr>\n<td>数值计算</td>\n<td style=\"text-align:right\">mapPoints mapRadius mapRect mapVectors</td>\n<td style=\"text-align:center\">计算变换后的数值</td>\n</tr>\n<tr>\n<td>设置(set)</td>\n<td style=\"text-align:right\">setConcat setRotate setScale setSkew setTranslate</td>\n<td style=\"text-align:center\">设置变换</td>\n</tr>\n<tr>\n<td>前乘(pre)</td>\n<td style=\"text-align:right\">preConcat preRotate preScale preSkew preTranslate</td>\n<td style=\"text-align:center\">前乘变换</td>\n</tr>\n<tr>\n<td>后乘(post)</td>\n<td style=\"text-align:right\">postConcat postRotate postScale postSkew postTranslate</td>\n<td style=\"text-align:center\">后乘变换</td>\n</tr>\n<tr>\n<td>特殊方法</td>\n<td style=\"text-align:right\">setPolyToPoly setRectToRect rectStaysRect setSinCos</td>\n<td style=\"text-align:center\">一些特殊操作</td>\n</tr>\n<tr>\n<td>矩阵相关</td>\n<td style=\"text-align:right\">invert isAffine(API21) isIdentity</td>\n<td style=\"text-align:center\">求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵</td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"what-is-matrix\"><a href=\"#what-is-matrix\" class=\"headerlink\" title=\"what is matrix\"></a>what is matrix</h2><p>Matrix是一个矩阵，主要功能是坐标映射，数值转换。</p>\n<p><img src=\"http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg\" alt=\"\"><br>1.缩放(Scale)</p>\n<p>x = k1 <em> x0<br>y = k2 </em> y0</p>\n<p>用矩阵表示:<br>[x]      [k1 0  0] [x0]<br>[y] = [0  k2 0] [y0]<br>[1]      [0  0  1] [1]</p>\n<p>2.错切(Skew)<br><img src=\"http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png\" alt=\"\"></p>\n<p>3.旋转(Rotate)<br><img src=\"http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png\" alt=\"\"></p>\n<p>4.平移(Translate)<br><img src=\"http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png\" alt=\"\"></p>\n<p>5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意</p>\n<h2 id=\"Matrix-常用api\"><a href=\"#Matrix-常用api\" class=\"headerlink\" title=\"Matrix 常用api\"></a>Matrix 常用api</h2><p>1.setValues getValues<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void <span class=\"built_in\">set</span>Values (<span class=\"built_in\">float</span>[] values)</div><div class=\"line\"><span class=\"built_in\">set</span>Values的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</div><div class=\"line\"></div><div class=\"line\">void getValues (<span class=\"built_in\">float</span>[] values)</div></pre></td></tr></table></figure></p>\n<p>2.mapPoints<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] pts)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, int dstIndex,<span class=\"built_in\">float</span>[] src, int srcIndex, int pointCount)</div><div class=\"line\"></div><div class=\"line\">计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的<span class=\"built_in\">float</span>数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)</div></pre></td></tr></table></figure></p>\n<p>3.mapRadius<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">float</span> mapRadius (<span class=\"built_in\">float</span> radius)</div><div class=\"line\">测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径</div></pre></td></tr></table></figure></p>\n<p>4.mapRect : 测量矩形变换后位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean mapRect (RectF rect)</div><div class=\"line\"></div><div class=\"line\">boolean mapRect (RectF dst, RectF src)</div></pre></td></tr></table></figure></p>\n<p>5.4.mapVectors : 测量向量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] vecs)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, int dstIndex, <span class=\"built_in\">float</span>[] src, int srcIndex, int vectorCount)</div><div class=\"line\"></div><div class=\"line\">//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">float</span>[] src = new <span class=\"built_in\">float</span>[]&#123;1000, 800&#125;;</div><div class=\"line\"><span class=\"built_in\">float</span>[] dst = new <span class=\"built_in\">float</span>[2];</div><div class=\"line\"></div><div class=\"line\">// 构造一个matrix</div><div class=\"line\">Matrix matrix = new Matrix();</div><div class=\"line\">matrix.setScale(0.5f, 1f);</div><div class=\"line\">matrix.postTranslate(100,100);</div><div class=\"line\"></div><div class=\"line\">// 计算向量, 不受位移影响</div><div class=\"line\">matrix.mapVectors(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapVectors: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">// 计算点</div><div class=\"line\">matrix.mapPoints(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapPoints: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">//结果:</div><div class=\"line\">mapVectors: [500.0, 800.0]</div><div class=\"line\">mapPoints: [600.0, 900.0]</div></pre></td></tr></table></figure></p>\n<h2 id=\"Matrix-特殊使用\"><a href=\"#Matrix-特殊使用\" class=\"headerlink\" title=\"Matrix 特殊使用\"></a>Matrix 特殊使用</h2><p>1.invert<br>求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍</p>\n<p>2.isAffine<br>判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。</p>\n<p>3.isIdentity ：判断是否为单位矩阵</p>\n<ol>\n<li>获取View在屏幕上的绝对位置<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    <span class=\"built_in\">float</span>[] values = new <span class=\"built_in\">float</span>[9];</div><div class=\"line\">    int[] location1 = new int[2];</div><div class=\"line\"></div><div class=\"line\">    Matrix matrix = canvas.getMatrix();</div><div class=\"line\">    matrix.getValues(values);</div><div class=\"line\"></div><div class=\"line\">    location1[0] = (int) values[2];</div><div class=\"line\">    location1[1] = (int) values[5];</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location1 = \"</span> + Arrays.toString(location1));</div><div class=\"line\"></div><div class=\"line\">    int[] location2 = new int[2];</div><div class=\"line\">    this.getLocationOnScreen(location2);</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location2 = \"</span> + Arrays.toString(location2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>5.setRectToRect<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>RectToRect (RectF src,           // 源区域</div><div class=\"line\">                RectF dst,                  // 目标区域</div><div class=\"line\">                Matrix.ScaleToFit stf)      // 缩放适配模式</div><div class=\"line\">简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定</div></pre></td></tr></table></figure></p>\n<p>ScaleToFit 是一个枚举类型，共包含了四种模式:</p>\n<table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CENTER</td>\n<td style=\"text-align:center\">居中，对src等比例缩放，将其居中放置在dst中</td>\n</tr>\n<tr>\n<td>START</td>\n<td style=\"text-align:center\">顶部，对src等比例缩放，将其放置在dst的左上角。</td>\n</tr>\n<tr>\n<td>END</td>\n<td style=\"text-align:center\">底部，对src等比例缩放，将其放置在dst的右下角。</td>\n</tr>\n<tr>\n<td>FILL</td>\n<td style=\"text-align:center\">充满，拉伸src的宽和高，使其完全填充满dst。</td>\n</tr>\n</tbody>\n</table>\n<p>6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>PolyToPoly (</div><div class=\"line\">        <span class=\"built_in\">float</span>[] src,    // 原始数组 src [x,y]，存储内容为一组点</div><div class=\"line\">        int srcIndex,   // 原始数组开始位置</div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst,    // 目标数组 dst [x,y]，存储内容为一组点</div><div class=\"line\">        int dstIndex,   // 目标数组开始位置</div><div class=\"line\">        int pointCount) // 测控点的数量 取值范围是: 0到4</div></pre></td></tr></table></figure></p>\n<p>从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。</p>\n<table>\n<thead>\n<tr>\n<th>pointCount</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">相当于reset</td>\n</tr>\n<tr>\n<td>1</td>\n<td style=\"text-align:center\">相当于translate                </td>\n</tr>\n<tr>\n<td>2</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移 变换</td>\n</tr>\n<tr>\n<td>3</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切 变换 </td>\n</tr>\n<tr>\n<td>4</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切以及任何形变 </td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MatrixSetPolyToPolyTest extends View &#123;</div><div class=\"line\"></div><div class=\"line\">    private Bitmap mBitmap;             // 要绘制的图片</div><div class=\"line\">    private Matrix mPolyMatrix;         // 测试<span class=\"built_in\">set</span>PolyToPoly用的Matrix</div><div class=\"line\"></div><div class=\"line\">    public MatrixSetPolyToPolyTest(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\"></div><div class=\"line\">        initBitmapAndMatrix();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void <span class=\"function\"><span class=\"title\">initBitmapAndMatrix</span></span>() &#123;</div><div class=\"line\">        mBitmap = BitmapFactory.decodeResource(getResources(),</div><div class=\"line\">                R.drawable.poly_test);</div><div class=\"line\"></div><div class=\"line\">        mPolyMatrix = new Matrix();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] src = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 0,                          // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 400,                        // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        // 核心要点</div><div class=\"line\">        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); // src.length &gt;&gt; 1 为位移运算 相当于处以2</div><div class=\"line\"></div><div class=\"line\">        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)</div><div class=\"line\">        mPolyMatrix.postScale(0.26f, 0.26f);</div><div class=\"line\">        mPolyMatrix.postTranslate(0,200);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">        super.onDraw(canvas);</div><div class=\"line\"></div><div class=\"line\">        // 根据Matrix绘制一个变换后的图片</div><div class=\"line\">        canvas.drawBitmap(mBitmap, mPolyMatrix, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"android网络编程(httpurlconnect接口,httpclient接口,与socket接口)","date":"2017-05-10T09:20:11.000Z","_content":"\n## 前言\nAndroid中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。\nHttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。\n另外，在使用POST方式进行传输时，需要进行字符编码。\nManifest文件中权限的设定：Xml代码 \n< uses-permission android:name=\"android.permission.INTERNET\" /> \n\n<!-- more -->\n\n## 1.HttpURLConnection接口\n首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。\nHttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：\n``` bash\nURL url = new URL(\"http://www.51cto.com/index.jsp?par=123456\");    \nHttpURLConnection urlConn=(HttpURLConnection)url.openConnection();\n\n//设置输入和输出流    \nurlConn.setDoOutput(true);    \nurlConn.setDoInput(true);    \n//设置请求方式为POST    \nurlConn.setRequestMethod(\"POST\");    \n//POST请求不能使用缓存    \nurlConn.setUseCaches(false);   \n//关闭连接    \nurlConn.disConnection();  \n```\n具体调用\n``` bash\n//以Get方式上传参数  \npublic class Activity03 extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity03\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);    \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //得到读取的内容(流)  \n                InputStreamReader in = new InputStreamReader(urlConn.getInputStream());  \n                // 为输出创建BufferedReader  \n                BufferedReader buffer = new BufferedReader(in);  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = buffer.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                //关闭InputStreamReader  \n                in.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n}\n\n//以post方式上传参数  \npublic class Activity04  extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity04\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n          \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //因为这个是post请求,设立需要设置为true  \n                urlConn.setDoOutput(true);  \n                urlConn.setDoInput(true);  \n                // 设置以POST方式  \n                urlConn.setRequestMethod(\"POST\");  \n                // Post 请求不能使用缓存  \n                urlConn.setUseCaches(false);  \n                urlConn.setInstanceFollowRedirects(true);  \n                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  \n                urlConn.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded\");  \n                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  \n                // 要注意的是connection.getOutputStream会隐含的进行connect。  \n                urlConn.connect();  \n                //DataOutputStream流  \n                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  \n                //要上传的参数  \n                String content = \"par=\" + URLEncoder.encode(\"ABCDEFG\", \"gb2312\");  \n                //将要上传的内容写入流中  \n                out.writeBytes(content);   \n                //刷新、关闭  \n                out.flush();  \n                out.close();   \n                //获取数据  \n                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = reader.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                reader.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n    }  \n}  \n```\n##  2.HttpClient接口\n使用Apache提供的HttpClient接口同样可以进行HTTP操作。\n对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：\n``` bash\npublic class Activity02 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\";  \n        //HttpGet连接对象  \n        HttpGet httpRequest = new HttpGet(httpUrl);  \n        try  \n        {  \n            //取得HttpClient对象  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //请求HttpClient，取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //请求成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n      \n            }  \n}  \n```\n使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：\n``` bash\npublic class Activity03 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //HttpPost连接对象  \n        HttpPost httpRequest = new HttpPost(httpUrl);  \n        //使用NameValuePair来保存要传递的Post参数  \n        List<NameValuePair> params = new ArrayList<NameValuePair>();  \n        //添加要传递的参数  \n        params.add(new BasicNameValuePair(\"par\", \"HttpClient_android_Post\"));  \n        try  \n        {  \n            //设置字符集  \n            HttpEntity httpentity = new UrlEncodedFormEntity(params, \"gb2312\");  \n            //请求httpRequest  \n            httpRequest.setEntity(httpentity);  \n            //取得默认的HttpClient  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //HttpStatus.SC_OK表示连接成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n    }  \n}  \n````\n## 3 Socket编程实例：\n创建一个java 类作为服务器，android 应用程序作为客户端\n服务器端代码：\n``` bash\npackage com.server;  \n  \nimport java.io.IOException;  \nimport java.io.OutputStream;  \nimport java.net.ServerSocket;  \nimport java.net.Socket;  \nimport java.text.SimpleDateFormat;  \n  \npublic class MyServer {  \n      \n    private  static int count=0;  \n    public static void main(String[]args){  \n          \n        try {  \n            //实例化服务器套接字 设置端口号8888  \n            ServerSocket server=new ServerSocket(8888);  \n            while(true){  \n                //连接编号设置  \n                count=count+1;  \n                //时间格式  \n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");  \n                //实例化客户端  \n                Socket client=server.accept();  \n                //实例化时间  以及 id  \n                System.out.println(count+\":\"+sdf.format(System.currentTimeMillis()));  \n                //获取输出流  \n                OutputStream out=client.getOutputStream();  \n                //输出字符串  \n                String msg=\"Hello,Android!\";  \n                //写字符串  \n                out.write(msg.getBytes());  \n            }  \n        } catch (IOException e) {  \n            // TODO Auto-generated catch block  \n            e.printStackTrace();  \n        }  \n          \n          \n    }  \n}  \n```\nandroid 客户端代码：\n``` bash\npackage com.client;  \n  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.net.Socket;  \nimport java.net.UnknownHostException;  \n  \nimport android.app.Activity;  \nimport android.os.Bundle;  \nimport android.view.View;  \nimport android.view.View.OnClickListener;  \nimport android.widget.Button;  \nimport android.widget.TextView;  \n  \npublic class MyClientActivity extends Activity {  \n    /** Called when the activity is first created. */  \n    private Button rev=null;  \n    private TextView revtext=null;  \n    @Override  \n    public void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.main);  \n        rev=(Button)findViewById(R.id.rev);      \n        revtext=(TextView)findViewById(R.id.receiver);  \n        rev.setOnClickListener(new receiverlistenr());  \n    }  \n    class receiverlistenr implements OnClickListener{  \n        public void onClick(View v) {  \n            // TODO Auto-generated method stub  \n            try {  \n                //实例化Socket  \n                Socket socket=new Socket(\"169.254.202.149\",8888);  \n                //获得输入流  \n                InputStream in=socket.getInputStream();  \n                //缓冲区  \n                byte[] buffer=new byte[in.available()];  \n                //读取缓冲区  \n                in.read(buffer);  \n                //转换字符串  \n                String msg=new String(buffer);  \n                //设置文本框的字符串  \n                revtext.setText(msg);  \n            } catch (UnknownHostException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            } catch (IOException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            }  \n              \n        }  \n    }  \n}  \n```","source":"_posts/http.md","raw":"---\ntitle: android网络编程(httpurlconnect接口,httpclient接口,与socket接口)\ndate: 2017-05-10 17:20:11\ncategories: android\ntags: 网络编程\n---\n\n## 前言\nAndroid中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。\nHttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。\n另外，在使用POST方式进行传输时，需要进行字符编码。\nManifest文件中权限的设定：Xml代码 \n< uses-permission android:name=\"android.permission.INTERNET\" /> \n\n<!-- more -->\n\n## 1.HttpURLConnection接口\n首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。\nHttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：\n``` bash\nURL url = new URL(\"http://www.51cto.com/index.jsp?par=123456\");    \nHttpURLConnection urlConn=(HttpURLConnection)url.openConnection();\n\n//设置输入和输出流    \nurlConn.setDoOutput(true);    \nurlConn.setDoInput(true);    \n//设置请求方式为POST    \nurlConn.setRequestMethod(\"POST\");    \n//POST请求不能使用缓存    \nurlConn.setUseCaches(false);   \n//关闭连接    \nurlConn.disConnection();  \n```\n具体调用\n``` bash\n//以Get方式上传参数  \npublic class Activity03 extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity03\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);    \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //得到读取的内容(流)  \n                InputStreamReader in = new InputStreamReader(urlConn.getInputStream());  \n                // 为输出创建BufferedReader  \n                BufferedReader buffer = new BufferedReader(in);  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = buffer.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                //关闭InputStreamReader  \n                in.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n}\n\n//以post方式上传参数  \npublic class Activity04  extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity04\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n          \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //因为这个是post请求,设立需要设置为true  \n                urlConn.setDoOutput(true);  \n                urlConn.setDoInput(true);  \n                // 设置以POST方式  \n                urlConn.setRequestMethod(\"POST\");  \n                // Post 请求不能使用缓存  \n                urlConn.setUseCaches(false);  \n                urlConn.setInstanceFollowRedirects(true);  \n                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  \n                urlConn.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded\");  \n                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  \n                // 要注意的是connection.getOutputStream会隐含的进行connect。  \n                urlConn.connect();  \n                //DataOutputStream流  \n                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  \n                //要上传的参数  \n                String content = \"par=\" + URLEncoder.encode(\"ABCDEFG\", \"gb2312\");  \n                //将要上传的内容写入流中  \n                out.writeBytes(content);   \n                //刷新、关闭  \n                out.flush();  \n                out.close();   \n                //获取数据  \n                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = reader.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                reader.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n    }  \n}  \n```\n##  2.HttpClient接口\n使用Apache提供的HttpClient接口同样可以进行HTTP操作。\n对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：\n``` bash\npublic class Activity02 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\";  \n        //HttpGet连接对象  \n        HttpGet httpRequest = new HttpGet(httpUrl);  \n        try  \n        {  \n            //取得HttpClient对象  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //请求HttpClient，取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //请求成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n      \n            }  \n}  \n```\n使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：\n``` bash\npublic class Activity03 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //HttpPost连接对象  \n        HttpPost httpRequest = new HttpPost(httpUrl);  \n        //使用NameValuePair来保存要传递的Post参数  \n        List<NameValuePair> params = new ArrayList<NameValuePair>();  \n        //添加要传递的参数  \n        params.add(new BasicNameValuePair(\"par\", \"HttpClient_android_Post\"));  \n        try  \n        {  \n            //设置字符集  \n            HttpEntity httpentity = new UrlEncodedFormEntity(params, \"gb2312\");  \n            //请求httpRequest  \n            httpRequest.setEntity(httpentity);  \n            //取得默认的HttpClient  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //HttpStatus.SC_OK表示连接成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n    }  \n}  \n````\n## 3 Socket编程实例：\n创建一个java 类作为服务器，android 应用程序作为客户端\n服务器端代码：\n``` bash\npackage com.server;  \n  \nimport java.io.IOException;  \nimport java.io.OutputStream;  \nimport java.net.ServerSocket;  \nimport java.net.Socket;  \nimport java.text.SimpleDateFormat;  \n  \npublic class MyServer {  \n      \n    private  static int count=0;  \n    public static void main(String[]args){  \n          \n        try {  \n            //实例化服务器套接字 设置端口号8888  \n            ServerSocket server=new ServerSocket(8888);  \n            while(true){  \n                //连接编号设置  \n                count=count+1;  \n                //时间格式  \n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");  \n                //实例化客户端  \n                Socket client=server.accept();  \n                //实例化时间  以及 id  \n                System.out.println(count+\":\"+sdf.format(System.currentTimeMillis()));  \n                //获取输出流  \n                OutputStream out=client.getOutputStream();  \n                //输出字符串  \n                String msg=\"Hello,Android!\";  \n                //写字符串  \n                out.write(msg.getBytes());  \n            }  \n        } catch (IOException e) {  \n            // TODO Auto-generated catch block  \n            e.printStackTrace();  \n        }  \n          \n          \n    }  \n}  \n```\nandroid 客户端代码：\n``` bash\npackage com.client;  \n  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.net.Socket;  \nimport java.net.UnknownHostException;  \n  \nimport android.app.Activity;  \nimport android.os.Bundle;  \nimport android.view.View;  \nimport android.view.View.OnClickListener;  \nimport android.widget.Button;  \nimport android.widget.TextView;  \n  \npublic class MyClientActivity extends Activity {  \n    /** Called when the activity is first created. */  \n    private Button rev=null;  \n    private TextView revtext=null;  \n    @Override  \n    public void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.main);  \n        rev=(Button)findViewById(R.id.rev);      \n        revtext=(TextView)findViewById(R.id.receiver);  \n        rev.setOnClickListener(new receiverlistenr());  \n    }  \n    class receiverlistenr implements OnClickListener{  \n        public void onClick(View v) {  \n            // TODO Auto-generated method stub  \n            try {  \n                //实例化Socket  \n                Socket socket=new Socket(\"169.254.202.149\",8888);  \n                //获得输入流  \n                InputStream in=socket.getInputStream();  \n                //缓冲区  \n                byte[] buffer=new byte[in.available()];  \n                //读取缓冲区  \n                in.read(buffer);  \n                //转换字符串  \n                String msg=new String(buffer);  \n                //设置文本框的字符串  \n                revtext.setText(msg);  \n            } catch (UnknownHostException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            } catch (IOException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            }  \n              \n        }  \n    }  \n}  \n```","slug":"http","published":1,"updated":"2018-02-10T06:53:50.944Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbg000wo4l1zumy0tov","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Android中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。<br>HttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。<br>另外，在使用POST方式进行传输时，需要进行字符编码。<br>Manifest文件中权限的设定：Xml代码<br>&lt; uses-permission android:name=”android.permission.INTERNET” /&gt; </p>\n<a id=\"more\"></a>\n<h2 id=\"1-HttpURLConnection接口\"><a href=\"#1-HttpURLConnection接口\" class=\"headerlink\" title=\"1.HttpURLConnection接口\"></a>1.HttpURLConnection接口</h2><p>首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。<br>HttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = new URL(<span class=\"string\">\"http://www.51cto.com/index.jsp?par=123456\"</span>);    </div><div class=\"line\">HttpURLConnection urlConn=(HttpURLConnection)url.openConnection();</div><div class=\"line\"></div><div class=\"line\">//设置输入和输出流    </div><div class=\"line\">urlConn.setDoOutput(<span class=\"literal\">true</span>);    </div><div class=\"line\">urlConn.setDoInput(<span class=\"literal\">true</span>);    </div><div class=\"line\">//设置请求方式为POST    </div><div class=\"line\">urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);    </div><div class=\"line\">//POST请求不能使用缓存    </div><div class=\"line\">urlConn.setUseCaches(<span class=\"literal\">false</span>);   </div><div class=\"line\">//关闭连接    </div><div class=\"line\">urlConn.disConnection();</div></pre></td></tr></table></figure></p>\n<p>具体调用<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以Get方式上传参数  </div><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity03\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);    </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //得到读取的内容(流)  </div><div class=\"line\">                InputStreamReader <span class=\"keyword\">in</span> = new InputStreamReader(urlConn.getInputStream());  </div><div class=\"line\">                // 为输出创建BufferedReader  </div><div class=\"line\">                BufferedReader buffer = new BufferedReader(<span class=\"keyword\">in</span>);  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = buffer.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                //关闭InputStreamReader  </div><div class=\"line\">                in.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//以post方式上传参数  </div><div class=\"line\">public class Activity04  extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity04\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">          </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //因为这个是post请求,设立需要设置为<span class=\"literal\">true</span>  </div><div class=\"line\">                urlConn.setDoOutput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                urlConn.setDoInput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 设置以POST方式  </div><div class=\"line\">                urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);  </div><div class=\"line\">                // Post 请求不能使用缓存  </div><div class=\"line\">                urlConn.setUseCaches(<span class=\"literal\">false</span>);  </div><div class=\"line\">                urlConn.setInstanceFollowRedirects(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  </div><div class=\"line\">                urlConn.setRequestProperty(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);  </div><div class=\"line\">                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  </div><div class=\"line\">                // 要注意的是connection.getOutputStream会隐含的进行connect。  </div><div class=\"line\">                urlConn.connect();  </div><div class=\"line\">                //DataOutputStream流  </div><div class=\"line\">                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  </div><div class=\"line\">                //要上传的参数  </div><div class=\"line\">                String content = <span class=\"string\">\"par=\"</span> + URLEncoder.encode(<span class=\"string\">\"ABCDEFG\"</span>, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">                //将要上传的内容写入流中  </div><div class=\"line\">                out.writeBytes(content);   </div><div class=\"line\">                //刷新、关闭  </div><div class=\"line\">                out.flush();  </div><div class=\"line\">                out.close();   </div><div class=\"line\">                //获取数据  </div><div class=\"line\">                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = reader.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                reader.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-HttpClient接口\"><a href=\"#2-HttpClient接口\" class=\"headerlink\" title=\"2.HttpClient接口\"></a>2.HttpClient接口</h2><p>使用Apache提供的HttpClient接口同样可以进行HTTP操作。<br>对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity02 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\"</span>;  </div><div class=\"line\">        //HttpGet连接对象  </div><div class=\"line\">        HttpGet httpRequest = new HttpGet(httpUrl);  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //取得HttpClient对象  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //请求HttpClient，取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //请求成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">      </div><div class=\"line\">            &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //HttpPost连接对象  </div><div class=\"line\">        HttpPost httpRequest = new HttpPost(httpUrl);  </div><div class=\"line\">        //使用NameValuePair来保存要传递的Post参数  </div><div class=\"line\">        List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();  </div><div class=\"line\">        //添加要传递的参数  </div><div class=\"line\">        params.add(new BasicNameValuePair(<span class=\"string\">\"par\"</span>, <span class=\"string\">\"HttpClient_android_Post\"</span>));  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //设置字符集  </div><div class=\"line\">            HttpEntity httpentity = new UrlEncodedFormEntity(params, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">            //请求httpRequest  </div><div class=\"line\">            httpRequest.setEntity(httpentity);  </div><div class=\"line\">            //取得默认的HttpClient  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //HttpStatus.SC_OK表示连接成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-Socket编程实例：\"><a href=\"#3-Socket编程实例：\" class=\"headerlink\" title=\"3 Socket编程实例：\"></a>3 Socket编程实例：</h2><p>创建一个java 类作为服务器，android 应用程序作为客户端<br>服务器端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.server;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.OutputStream;  </div><div class=\"line\">import java.net.ServerSocket;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.text.SimpleDateFormat;  </div><div class=\"line\">  </div><div class=\"line\">public class MyServer &#123;  </div><div class=\"line\">      </div><div class=\"line\">    private  static int count=0;  </div><div class=\"line\">    public static void main(String[]args)&#123;  </div><div class=\"line\">          </div><div class=\"line\">        try &#123;  </div><div class=\"line\">            //实例化服务器套接字 设置端口号8888  </div><div class=\"line\">            ServerSocket server=new ServerSocket(8888);  </div><div class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;  </div><div class=\"line\">                //连接编号设置  </div><div class=\"line\">                count=count+1;  </div><div class=\"line\">                //时间格式  </div><div class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss.SSS\"</span>);  </div><div class=\"line\">                //实例化客户端  </div><div class=\"line\">                Socket client=server.accept();  </div><div class=\"line\">                //实例化时间  以及 id  </div><div class=\"line\">                System.out.println(count+<span class=\"string\">\":\"</span>+sdf.format(System.currentTimeMillis()));  </div><div class=\"line\">                //获取输出流  </div><div class=\"line\">                OutputStream out=client.getOutputStream();  </div><div class=\"line\">                //输出字符串  </div><div class=\"line\">                String msg=<span class=\"string\">\"Hello,Android!\"</span>;  </div><div class=\"line\">                //写字符串  </div><div class=\"line\">                out.write(msg.getBytes());  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125; catch (IOException e) &#123;  </div><div class=\"line\">            // TODO Auto-generated catch block  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">          </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>android 客户端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.client;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.InputStream;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.net.UnknownHostException;  </div><div class=\"line\">  </div><div class=\"line\">import android.app.Activity;  </div><div class=\"line\">import android.os.Bundle;  </div><div class=\"line\">import android.view.View;  </div><div class=\"line\">import android.view.View.OnClickListener;  </div><div class=\"line\">import android.widget.Button;  </div><div class=\"line\">import android.widget.TextView;  </div><div class=\"line\">  </div><div class=\"line\">public class MyClientActivity extends Activity &#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    private Button rev=null;  </div><div class=\"line\">    private TextView revtext=null;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.main);  </div><div class=\"line\">        rev=(Button)findViewById(R.id.rev);      </div><div class=\"line\">        revtext=(TextView)findViewById(R.id.receiver);  </div><div class=\"line\">        rev.setOnClickListener(new receiverlistenr());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    class receiverlistenr implements OnClickListener&#123;  </div><div class=\"line\">        public void onClick(View v) &#123;  </div><div class=\"line\">            // TODO Auto-generated method stub  </div><div class=\"line\">            try &#123;  </div><div class=\"line\">                //实例化Socket  </div><div class=\"line\">                Socket socket=new Socket(<span class=\"string\">\"169.254.202.149\"</span>,8888);  </div><div class=\"line\">                //获得输入流  </div><div class=\"line\">                InputStream <span class=\"keyword\">in</span>=socket.getInputStream();  </div><div class=\"line\">                //缓冲区  </div><div class=\"line\">                byte[] buffer=new byte[in.available()];  </div><div class=\"line\">                //读取缓冲区  </div><div class=\"line\">                in.read(buffer);  </div><div class=\"line\">                //转换字符串  </div><div class=\"line\">                String msg=new String(buffer);  </div><div class=\"line\">                //设置文本框的字符串  </div><div class=\"line\">                revtext.setText(msg);  </div><div class=\"line\">            &#125; catch (UnknownHostException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125; catch (IOException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">              </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Android中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。<br>HttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。<br>另外，在使用POST方式进行传输时，需要进行字符编码。<br>Manifest文件中权限的设定：Xml代码<br>&lt; uses-permission android:name=”android.permission.INTERNET” /&gt; </p>","more":"<h2 id=\"1-HttpURLConnection接口\"><a href=\"#1-HttpURLConnection接口\" class=\"headerlink\" title=\"1.HttpURLConnection接口\"></a>1.HttpURLConnection接口</h2><p>首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。<br>HttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = new URL(<span class=\"string\">\"http://www.51cto.com/index.jsp?par=123456\"</span>);    </div><div class=\"line\">HttpURLConnection urlConn=(HttpURLConnection)url.openConnection();</div><div class=\"line\"></div><div class=\"line\">//设置输入和输出流    </div><div class=\"line\">urlConn.setDoOutput(<span class=\"literal\">true</span>);    </div><div class=\"line\">urlConn.setDoInput(<span class=\"literal\">true</span>);    </div><div class=\"line\">//设置请求方式为POST    </div><div class=\"line\">urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);    </div><div class=\"line\">//POST请求不能使用缓存    </div><div class=\"line\">urlConn.setUseCaches(<span class=\"literal\">false</span>);   </div><div class=\"line\">//关闭连接    </div><div class=\"line\">urlConn.disConnection();</div></pre></td></tr></table></figure></p>\n<p>具体调用<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以Get方式上传参数  </div><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity03\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);    </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //得到读取的内容(流)  </div><div class=\"line\">                InputStreamReader <span class=\"keyword\">in</span> = new InputStreamReader(urlConn.getInputStream());  </div><div class=\"line\">                // 为输出创建BufferedReader  </div><div class=\"line\">                BufferedReader buffer = new BufferedReader(<span class=\"keyword\">in</span>);  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = buffer.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                //关闭InputStreamReader  </div><div class=\"line\">                in.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//以post方式上传参数  </div><div class=\"line\">public class Activity04  extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity04\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">          </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //因为这个是post请求,设立需要设置为<span class=\"literal\">true</span>  </div><div class=\"line\">                urlConn.setDoOutput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                urlConn.setDoInput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 设置以POST方式  </div><div class=\"line\">                urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);  </div><div class=\"line\">                // Post 请求不能使用缓存  </div><div class=\"line\">                urlConn.setUseCaches(<span class=\"literal\">false</span>);  </div><div class=\"line\">                urlConn.setInstanceFollowRedirects(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  </div><div class=\"line\">                urlConn.setRequestProperty(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);  </div><div class=\"line\">                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  </div><div class=\"line\">                // 要注意的是connection.getOutputStream会隐含的进行connect。  </div><div class=\"line\">                urlConn.connect();  </div><div class=\"line\">                //DataOutputStream流  </div><div class=\"line\">                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  </div><div class=\"line\">                //要上传的参数  </div><div class=\"line\">                String content = <span class=\"string\">\"par=\"</span> + URLEncoder.encode(<span class=\"string\">\"ABCDEFG\"</span>, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">                //将要上传的内容写入流中  </div><div class=\"line\">                out.writeBytes(content);   </div><div class=\"line\">                //刷新、关闭  </div><div class=\"line\">                out.flush();  </div><div class=\"line\">                out.close();   </div><div class=\"line\">                //获取数据  </div><div class=\"line\">                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = reader.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                reader.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-HttpClient接口\"><a href=\"#2-HttpClient接口\" class=\"headerlink\" title=\"2.HttpClient接口\"></a>2.HttpClient接口</h2><p>使用Apache提供的HttpClient接口同样可以进行HTTP操作。<br>对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity02 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\"</span>;  </div><div class=\"line\">        //HttpGet连接对象  </div><div class=\"line\">        HttpGet httpRequest = new HttpGet(httpUrl);  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //取得HttpClient对象  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //请求HttpClient，取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //请求成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">      </div><div class=\"line\">            &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //HttpPost连接对象  </div><div class=\"line\">        HttpPost httpRequest = new HttpPost(httpUrl);  </div><div class=\"line\">        //使用NameValuePair来保存要传递的Post参数  </div><div class=\"line\">        List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();  </div><div class=\"line\">        //添加要传递的参数  </div><div class=\"line\">        params.add(new BasicNameValuePair(<span class=\"string\">\"par\"</span>, <span class=\"string\">\"HttpClient_android_Post\"</span>));  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //设置字符集  </div><div class=\"line\">            HttpEntity httpentity = new UrlEncodedFormEntity(params, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">            //请求httpRequest  </div><div class=\"line\">            httpRequest.setEntity(httpentity);  </div><div class=\"line\">            //取得默认的HttpClient  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //HttpStatus.SC_OK表示连接成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-Socket编程实例：\"><a href=\"#3-Socket编程实例：\" class=\"headerlink\" title=\"3 Socket编程实例：\"></a>3 Socket编程实例：</h2><p>创建一个java 类作为服务器，android 应用程序作为客户端<br>服务器端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.server;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.OutputStream;  </div><div class=\"line\">import java.net.ServerSocket;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.text.SimpleDateFormat;  </div><div class=\"line\">  </div><div class=\"line\">public class MyServer &#123;  </div><div class=\"line\">      </div><div class=\"line\">    private  static int count=0;  </div><div class=\"line\">    public static void main(String[]args)&#123;  </div><div class=\"line\">          </div><div class=\"line\">        try &#123;  </div><div class=\"line\">            //实例化服务器套接字 设置端口号8888  </div><div class=\"line\">            ServerSocket server=new ServerSocket(8888);  </div><div class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;  </div><div class=\"line\">                //连接编号设置  </div><div class=\"line\">                count=count+1;  </div><div class=\"line\">                //时间格式  </div><div class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss.SSS\"</span>);  </div><div class=\"line\">                //实例化客户端  </div><div class=\"line\">                Socket client=server.accept();  </div><div class=\"line\">                //实例化时间  以及 id  </div><div class=\"line\">                System.out.println(count+<span class=\"string\">\":\"</span>+sdf.format(System.currentTimeMillis()));  </div><div class=\"line\">                //获取输出流  </div><div class=\"line\">                OutputStream out=client.getOutputStream();  </div><div class=\"line\">                //输出字符串  </div><div class=\"line\">                String msg=<span class=\"string\">\"Hello,Android!\"</span>;  </div><div class=\"line\">                //写字符串  </div><div class=\"line\">                out.write(msg.getBytes());  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125; catch (IOException e) &#123;  </div><div class=\"line\">            // TODO Auto-generated catch block  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">          </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>android 客户端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.client;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.InputStream;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.net.UnknownHostException;  </div><div class=\"line\">  </div><div class=\"line\">import android.app.Activity;  </div><div class=\"line\">import android.os.Bundle;  </div><div class=\"line\">import android.view.View;  </div><div class=\"line\">import android.view.View.OnClickListener;  </div><div class=\"line\">import android.widget.Button;  </div><div class=\"line\">import android.widget.TextView;  </div><div class=\"line\">  </div><div class=\"line\">public class MyClientActivity extends Activity &#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    private Button rev=null;  </div><div class=\"line\">    private TextView revtext=null;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.main);  </div><div class=\"line\">        rev=(Button)findViewById(R.id.rev);      </div><div class=\"line\">        revtext=(TextView)findViewById(R.id.receiver);  </div><div class=\"line\">        rev.setOnClickListener(new receiverlistenr());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    class receiverlistenr implements OnClickListener&#123;  </div><div class=\"line\">        public void onClick(View v) &#123;  </div><div class=\"line\">            // TODO Auto-generated method stub  </div><div class=\"line\">            try &#123;  </div><div class=\"line\">                //实例化Socket  </div><div class=\"line\">                Socket socket=new Socket(<span class=\"string\">\"169.254.202.149\"</span>,8888);  </div><div class=\"line\">                //获得输入流  </div><div class=\"line\">                InputStream <span class=\"keyword\">in</span>=socket.getInputStream();  </div><div class=\"line\">                //缓冲区  </div><div class=\"line\">                byte[] buffer=new byte[in.available()];  </div><div class=\"line\">                //读取缓冲区  </div><div class=\"line\">                in.read(buffer);  </div><div class=\"line\">                //转换字符串  </div><div class=\"line\">                String msg=new String(buffer);  </div><div class=\"line\">                //设置文本框的字符串  </div><div class=\"line\">                revtext.setText(msg);  </div><div class=\"line\">            &#125; catch (UnknownHostException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125; catch (IOException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">              </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"recyclerview","date":"2017-06-03T08:20:02.000Z","_content":"\n## 如何使用 RecyclerView\n\n首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。\n还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）\n\n<!-- more -->\n\n### 3种布局\n``` bash\nLinearLayoutManager ： \nLinearLayoutManager(Context context, int orientation, boolean reverseLayout)\n很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个\n\nGridLayoutManager :\nGridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)\n\nStaggeredGridLayoutManager:\nStaggeredGridLayoutManager(int spanCount, int orientation)\n```\n\n### 点击事件的实现（有两种）\n\n``` bash\n@Override\n    public void onBindViewHolder(final MyViewHolder holder, int position) {\n        loadThumb(position, holder);\n\n        if (mOnItemLitener != null) {\n            holder.itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemClick(holder.itemView, pos);\n                }\n            });\n           \n            holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {\n                @Override\n                public boolean onLongClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemLongClick(holder.itemView, pos);\n                    return false;\n                }\n            });\n        }\n    }\n\t\n\t public interface OnItemLitener {\n        void onItemClick(View view, int position);\n\n        void onItemLongClick(View view, int position);\n    }\n\n    private OnItemLitener mOnItemLitener;\n\n    public void setOnItemLitener(OnItemLitener mOnItemLitener) {\n        this.mOnItemLitener = mOnItemLitener;\n    }\n```\n另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑\n\n### ItemDecoration 间隔线 \n``` bash\npublic class DividerItemDecoration extends RecyclerView.ItemDecoration {\n\n    private static final int[] ATTRS = new int[]{android.R.attr.listDivider};\n    private Drawable mDivider;\n\n    public DividerItemDecoration(Context context) {\n        final TypedArray a = context.obtainStyledAttributes(ATTRS);\n        mDivider = a.getDrawable(0);\n        a.recycle();\n    }\n\n    @Override\n    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {\n        drawHorizontal(c, parent);\n        drawVertical(c, parent);\n    }\n\n    public int getSpanCount(RecyclerView parent) {\n        // 列数\n        int spanCount = -1;\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n\n            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            spanCount = ((StaggeredGridLayoutManager) layoutManager)\n                    .getSpanCount();\n        }\n        return spanCount;\n    }\n\n    public void drawHorizontal(Canvas c, RecyclerView parent) {\n        int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int left = child.getLeft() - params.leftMargin;\n            final int right = child.getRight() + params.rightMargin\n                    + mDivider.getIntrinsicWidth();\n            final int top = child.getBottom() + params.bottomMargin;\n            final int bottom = top + mDivider.getIntrinsicHeight();\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public void drawVertical(Canvas c, RecyclerView parent) {\n        final int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int top = child.getTop() - params.topMargin;\n            final int bottom = child.getBottom() + params.bottomMargin;\n            final int left = child.getRight() + params.rightMargin;\n            final int right = left + mDivider.getIntrinsicWidth();\n\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) { // 注意 StaggeredGridLayoutManager\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 1) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n            {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager)\n                    .getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n                {\n                    return true;\n                }\n            } else {\n                childCount = childCount - childCount % spanCount;\n                if (pos >= childCount)// 如果是最后一列，则不需要绘制右边\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) {  // 注意 StaggeredGridLayoutManager\n\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if (pos < spanCount) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            childCount = childCount - childCount % spanCount;\n            if (pos >= childCount)// 如果是最后一行，则不需要绘制底部\n                return true;\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            // StaggeredGridLayoutManager 且纵向滚动\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                childCount = childCount - childCount % spanCount;\n                // 如果是最后一行，则不需要绘制底部\n                if (pos >= childCount)\n                    return true;\n            } else\n            // StaggeredGridLayoutManager 且横向滚动\n            {\n                // 如果是最后一行，则不需要绘制底部\n                if ((pos + 1) % spanCount == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\t// 主要的绘制逻辑在这里\n    @Override\n    public void getItemOffsets(Rect outRect, int itemPosition,\n                               RecyclerView parent) {\n        int spanCount = getSpanCount(parent);\n        int childCount = parent.getAdapter().getItemCount();\n        if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部\n        {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);\n        } else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边\n        {\n            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());\n        } else {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(),\n                    mDivider.getIntrinsicHeight());\n        }\n    }\n}\n```\n\n###  ItemTouchHelper.Callback 长按拖拽功能，滑动功能 \n``` bash\n public ItemDragHelperCallback callback;\n\n    public void mAddItemDragHelperCallback() {\n\n        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);\n        callback.setOptions(true, true);\n        ItemTouchHelper helper = new ItemTouchHelper(callback);\n        helper.attachToRecyclerView(mRecyclerView);\n\n    }\n````\nItemDragHelperCallback 的代码\n``` bash\nclass ItemDragHelperCallback extends ItemTouchHelper.Callback {\n\n    private RecyclerView.Adapter mMyRecyclerViewAdapter;\n\n    public ItemDragHelperCallback(RecyclerView.Adapter adapter) {\n        mMyRecyclerViewAdapter = adapter;\n    }\n\n\t// 这里控制了拽拉拖动的实现 \n    @Override\n    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        int dragFlags, swipeFlags;\n        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();\n        if (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) {\n            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n        } else {\n            if (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) {\n                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n            } else {\n                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            }\n        }\n\n        return makeMovementFlags(dragFlags, swipeFlags);\n    }\n\n    @Override\n    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {\n        // 不同Type之间不可移动\n        if (viewHolder.getItemViewType() != target.getItemViewType()) {\n            return false;\n        }\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());\n        }\n        return true;\n    }\n\n    @Override\n    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemDelete(viewHolder.getAdapterPosition());\n        }\n    }\n\n    @Override\n    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) {\n        // 不在闲置状态\n        if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) {\n            if (viewHolder instanceof OnDragVHListener) {\n                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n                itemViewHolder.onItemSelected();\n            }\n        }\n        super.onSelectedChanged(viewHolder, actionState);\n    }\n\n    @Override\n    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        if (viewHolder instanceof OnDragVHListener) {\n            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n            itemViewHolder.onItemFinish();\n        }\n        super.clearView(recyclerView, viewHolder);\n    }\n\n    @Override\n    public boolean isLongPressDragEnabled() {\n        // 长按拖拽功能\n        return isLongPressDragEnabled;\n    }\n\n    @Override\n    public boolean isItemViewSwipeEnabled() {\n        // 滑动功能\n        return isItemViewSwipeEnabled;\n    }\n\n    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;\n\n    public void setOptions(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) {\n        this.isLongPressDragEnabled = isLongPressDragEnabled;\n        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;\n    }\n\n    interface OnDragVHListener {\n\n        // Item被选中时触发\n        void onItemSelected();\n\n        // Item在拖拽结束/滑动结束后触发\n        void onItemFinish();\n    }\n\n    interface OnItemTouchListener {\n        void onItemMove(int fromPosition, int toPosition);\n\n        void onItemDelete(int position);\n    }\n}\n```\nadapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，\nViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener\n``` bash\n  @Override\n    public void onItemMove(int fromPosition, int toPosition) {\n        Object item = m_itemInfos.get(fromPosition);\n        m_itemInfos.remove(fromPosition);\n        m_itemInfos.add(toPosition, item);\n        notifyItemMoved(fromPosition, toPosition);\n    }\n\n    @Override\n    public void onItemDelete(int position) {\n        removeItem(position);\n    }\n```\n","source":"_posts/recyclerview.md","raw":"---\ntitle: recyclerview\ndate: 2017-06-03 16:20:02\ncategories: android\ntags: recyclerview\n---\n\n## 如何使用 RecyclerView\n\n首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。\n还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）\n\n<!-- more -->\n\n### 3种布局\n``` bash\nLinearLayoutManager ： \nLinearLayoutManager(Context context, int orientation, boolean reverseLayout)\n很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个\n\nGridLayoutManager :\nGridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)\n\nStaggeredGridLayoutManager:\nStaggeredGridLayoutManager(int spanCount, int orientation)\n```\n\n### 点击事件的实现（有两种）\n\n``` bash\n@Override\n    public void onBindViewHolder(final MyViewHolder holder, int position) {\n        loadThumb(position, holder);\n\n        if (mOnItemLitener != null) {\n            holder.itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemClick(holder.itemView, pos);\n                }\n            });\n           \n            holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {\n                @Override\n                public boolean onLongClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemLongClick(holder.itemView, pos);\n                    return false;\n                }\n            });\n        }\n    }\n\t\n\t public interface OnItemLitener {\n        void onItemClick(View view, int position);\n\n        void onItemLongClick(View view, int position);\n    }\n\n    private OnItemLitener mOnItemLitener;\n\n    public void setOnItemLitener(OnItemLitener mOnItemLitener) {\n        this.mOnItemLitener = mOnItemLitener;\n    }\n```\n另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑\n\n### ItemDecoration 间隔线 \n``` bash\npublic class DividerItemDecoration extends RecyclerView.ItemDecoration {\n\n    private static final int[] ATTRS = new int[]{android.R.attr.listDivider};\n    private Drawable mDivider;\n\n    public DividerItemDecoration(Context context) {\n        final TypedArray a = context.obtainStyledAttributes(ATTRS);\n        mDivider = a.getDrawable(0);\n        a.recycle();\n    }\n\n    @Override\n    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {\n        drawHorizontal(c, parent);\n        drawVertical(c, parent);\n    }\n\n    public int getSpanCount(RecyclerView parent) {\n        // 列数\n        int spanCount = -1;\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n\n            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            spanCount = ((StaggeredGridLayoutManager) layoutManager)\n                    .getSpanCount();\n        }\n        return spanCount;\n    }\n\n    public void drawHorizontal(Canvas c, RecyclerView parent) {\n        int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int left = child.getLeft() - params.leftMargin;\n            final int right = child.getRight() + params.rightMargin\n                    + mDivider.getIntrinsicWidth();\n            final int top = child.getBottom() + params.bottomMargin;\n            final int bottom = top + mDivider.getIntrinsicHeight();\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public void drawVertical(Canvas c, RecyclerView parent) {\n        final int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int top = child.getTop() - params.topMargin;\n            final int bottom = child.getBottom() + params.bottomMargin;\n            final int left = child.getRight() + params.rightMargin;\n            final int right = left + mDivider.getIntrinsicWidth();\n\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) { // 注意 StaggeredGridLayoutManager\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 1) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n            {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager)\n                    .getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n                {\n                    return true;\n                }\n            } else {\n                childCount = childCount - childCount % spanCount;\n                if (pos >= childCount)// 如果是最后一列，则不需要绘制右边\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) {  // 注意 StaggeredGridLayoutManager\n\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if (pos < spanCount) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            childCount = childCount - childCount % spanCount;\n            if (pos >= childCount)// 如果是最后一行，则不需要绘制底部\n                return true;\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            // StaggeredGridLayoutManager 且纵向滚动\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                childCount = childCount - childCount % spanCount;\n                // 如果是最后一行，则不需要绘制底部\n                if (pos >= childCount)\n                    return true;\n            } else\n            // StaggeredGridLayoutManager 且横向滚动\n            {\n                // 如果是最后一行，则不需要绘制底部\n                if ((pos + 1) % spanCount == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\t// 主要的绘制逻辑在这里\n    @Override\n    public void getItemOffsets(Rect outRect, int itemPosition,\n                               RecyclerView parent) {\n        int spanCount = getSpanCount(parent);\n        int childCount = parent.getAdapter().getItemCount();\n        if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部\n        {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);\n        } else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边\n        {\n            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());\n        } else {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(),\n                    mDivider.getIntrinsicHeight());\n        }\n    }\n}\n```\n\n###  ItemTouchHelper.Callback 长按拖拽功能，滑动功能 \n``` bash\n public ItemDragHelperCallback callback;\n\n    public void mAddItemDragHelperCallback() {\n\n        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);\n        callback.setOptions(true, true);\n        ItemTouchHelper helper = new ItemTouchHelper(callback);\n        helper.attachToRecyclerView(mRecyclerView);\n\n    }\n````\nItemDragHelperCallback 的代码\n``` bash\nclass ItemDragHelperCallback extends ItemTouchHelper.Callback {\n\n    private RecyclerView.Adapter mMyRecyclerViewAdapter;\n\n    public ItemDragHelperCallback(RecyclerView.Adapter adapter) {\n        mMyRecyclerViewAdapter = adapter;\n    }\n\n\t// 这里控制了拽拉拖动的实现 \n    @Override\n    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        int dragFlags, swipeFlags;\n        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();\n        if (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) {\n            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n        } else {\n            if (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) {\n                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n            } else {\n                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            }\n        }\n\n        return makeMovementFlags(dragFlags, swipeFlags);\n    }\n\n    @Override\n    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {\n        // 不同Type之间不可移动\n        if (viewHolder.getItemViewType() != target.getItemViewType()) {\n            return false;\n        }\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());\n        }\n        return true;\n    }\n\n    @Override\n    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemDelete(viewHolder.getAdapterPosition());\n        }\n    }\n\n    @Override\n    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) {\n        // 不在闲置状态\n        if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) {\n            if (viewHolder instanceof OnDragVHListener) {\n                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n                itemViewHolder.onItemSelected();\n            }\n        }\n        super.onSelectedChanged(viewHolder, actionState);\n    }\n\n    @Override\n    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        if (viewHolder instanceof OnDragVHListener) {\n            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n            itemViewHolder.onItemFinish();\n        }\n        super.clearView(recyclerView, viewHolder);\n    }\n\n    @Override\n    public boolean isLongPressDragEnabled() {\n        // 长按拖拽功能\n        return isLongPressDragEnabled;\n    }\n\n    @Override\n    public boolean isItemViewSwipeEnabled() {\n        // 滑动功能\n        return isItemViewSwipeEnabled;\n    }\n\n    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;\n\n    public void setOptions(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) {\n        this.isLongPressDragEnabled = isLongPressDragEnabled;\n        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;\n    }\n\n    interface OnDragVHListener {\n\n        // Item被选中时触发\n        void onItemSelected();\n\n        // Item在拖拽结束/滑动结束后触发\n        void onItemFinish();\n    }\n\n    interface OnItemTouchListener {\n        void onItemMove(int fromPosition, int toPosition);\n\n        void onItemDelete(int position);\n    }\n}\n```\nadapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，\nViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener\n``` bash\n  @Override\n    public void onItemMove(int fromPosition, int toPosition) {\n        Object item = m_itemInfos.get(fromPosition);\n        m_itemInfos.remove(fromPosition);\n        m_itemInfos.add(toPosition, item);\n        notifyItemMoved(fromPosition, toPosition);\n    }\n\n    @Override\n    public void onItemDelete(int position) {\n        removeItem(position);\n    }\n```\n","slug":"recyclerview","published":1,"updated":"2018-02-10T06:53:50.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbi0010o4l1lspobpqm","content":"<h2 id=\"如何使用-RecyclerView\"><a href=\"#如何使用-RecyclerView\" class=\"headerlink\" title=\"如何使用 RecyclerView\"></a>如何使用 RecyclerView</h2><p>首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。<br>还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）</p>\n<a id=\"more\"></a>\n<h3 id=\"3种布局\"><a href=\"#3种布局\" class=\"headerlink\" title=\"3种布局\"></a>3种布局</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">LinearLayoutManager ： </div><div class=\"line\">LinearLayoutManager(Context context, int orientation, boolean reverseLayout)</div><div class=\"line\">很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个</div><div class=\"line\"></div><div class=\"line\">GridLayoutManager :</div><div class=\"line\">GridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)</div><div class=\"line\"></div><div class=\"line\">StaggeredGridLayoutManager:</div><div class=\"line\">StaggeredGridLayoutManager(int spanCount, int orientation)</div></pre></td></tr></table></figure>\n<h3 id=\"点击事件的实现（有两种）\"><a href=\"#点击事件的实现（有两种）\" class=\"headerlink\" title=\"点击事件的实现（有两种）\"></a>点击事件的实现（有两种）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void onBindViewHolder(final MyViewHolder holder, int position) &#123;</div><div class=\"line\">        loadThumb(position, holder);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mOnItemLitener != null) &#123;</div><div class=\"line\">            holder.itemView.setOnClickListener(new View.<span class=\"function\"><span class=\"title\">OnClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void onClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemClick(holder.itemView, pos);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">           </div><div class=\"line\">            holder.itemView.setOnLongClickListener(new View.<span class=\"function\"><span class=\"title\">OnLongClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public boolean onLongClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemLongClick(holder.itemView, pos);</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t public interface OnItemLitener &#123;</div><div class=\"line\">        void onItemClick(View view, int position);</div><div class=\"line\"></div><div class=\"line\">        void onItemLongClick(View view, int position);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private OnItemLitener mOnItemLitener;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>OnItemLitener(OnItemLitener mOnItemLitener) &#123;</div><div class=\"line\">        this.mOnItemLitener = mOnItemLitener;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑</p>\n<h3 id=\"ItemDecoration-间隔线\"><a href=\"#ItemDecoration-间隔线\" class=\"headerlink\" title=\"ItemDecoration 间隔线\"></a>ItemDecoration 间隔线</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final int[] ATTRS = new int[]&#123;android.R.attr.listDivider&#125;;</div><div class=\"line\">    private Drawable mDivider;</div><div class=\"line\"></div><div class=\"line\">    public DividerItemDecoration(Context context) &#123;</div><div class=\"line\">        final TypedArray a = context.obtainStyledAttributes(ATTRS);</div><div class=\"line\">        mDivider = a.getDrawable(0);</div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</div><div class=\"line\">        drawHorizontal(c, parent);</div><div class=\"line\">        drawVertical(c, parent);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getSpanCount(RecyclerView parent) &#123;</div><div class=\"line\">        // 列数</div><div class=\"line\">        int spanCount = -1;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\"></div><div class=\"line\">            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            spanCount = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getSpanCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> spanCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawHorizontal(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int left = child.getLeft() - params.leftMargin;</div><div class=\"line\">            final int right = child.getRight() + params.rightMargin</div><div class=\"line\">                    + mDivider.getIntrinsicWidth();</div><div class=\"line\">            final int top = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int bottom = top + mDivider.getIntrinsicHeight();</div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawVertical(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        final int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\"></div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int top = child.getTop() - params.topMargin;</div><div class=\"line\">            final int bottom = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int left = child.getRight() + params.rightMargin;</div><div class=\"line\">            final int right = left + mDivider.getIntrinsicWidth();</div><div class=\"line\"></div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; // 注意 StaggeredGridLayoutManager</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 1) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;  // 注意 StaggeredGridLayoutManager</div><div class=\"line\"></div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &lt; spanCount) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            childCount = childCount - childCount % spanCount;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            // StaggeredGridLayoutManager 且纵向滚动</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span></div><div class=\"line\">            // StaggeredGridLayoutManager 且横向滚动</div><div class=\"line\">            &#123;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0) &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 主要的绘制逻辑在这里</div><div class=\"line\">    @Override</div><div class=\"line\">    public void getItemOffsets(Rect outRect, int itemPosition,</div><div class=\"line\">                               RecyclerView parent) &#123;</div><div class=\"line\">        int spanCount = getSpanCount(parent);</div><div class=\"line\">        int childCount = parent.getAdapter().getItemCount();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(),</div><div class=\"line\">                    mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ItemTouchHelper-Callback-长按拖拽功能，滑动功能\"><a href=\"#ItemTouchHelper-Callback-长按拖拽功能，滑动功能\" class=\"headerlink\" title=\"ItemTouchHelper.Callback 长按拖拽功能，滑动功能\"></a>ItemTouchHelper.Callback 长按拖拽功能，滑动功能</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public ItemDragHelperCallback callback;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">mAddItemDragHelperCallback</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);</div><div class=\"line\">        callback.setOptions(<span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">        ItemTouchHelper helper = new ItemTouchHelper(callback);</div><div class=\"line\">        helper.attachToRecyclerView(mRecyclerView);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p>ItemDragHelperCallback 的代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ItemDragHelperCallback extends ItemTouchHelper.Callback &#123;</div><div class=\"line\"></div><div class=\"line\">    private RecyclerView.Adapter mMyRecyclerViewAdapter;</div><div class=\"line\"></div><div class=\"line\">    public ItemDragHelperCallback(RecyclerView.Adapter adapter) &#123;</div><div class=\"line\">        mMyRecyclerViewAdapter = adapter;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 这里控制了拽拉拖动的实现 </div><div class=\"line\">    @Override</div><div class=\"line\">    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        int dragFlags, swipeFlags;</div><div class=\"line\">        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">return</span> makeMovementFlags(dragFlags, swipeFlags);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123;</div><div class=\"line\">        // 不同Type之间不可移动</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder.getItemViewType() != target.getItemViewType()) &#123;</div><div class=\"line\">            <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemDelete(viewHolder.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123;</div><div class=\"line\">        // 不在闲置状态</div><div class=\"line\">        <span class=\"keyword\">if</span> (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">                itemViewHolder.onItemSelected();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.onSelectedChanged(viewHolder, actionState);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">            itemViewHolder.onItemFinish();</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.clearView(recyclerView, viewHolder);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isLongPressDragEnabled</span></span>() &#123;</div><div class=\"line\">        // 长按拖拽功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isLongPressDragEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isItemViewSwipeEnabled</span></span>() &#123;</div><div class=\"line\">        // 滑动功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>Options(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) &#123;</div><div class=\"line\">        this.isLongPressDragEnabled = isLongPressDragEnabled;</div><div class=\"line\">        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnDragVHListener &#123;</div><div class=\"line\"></div><div class=\"line\">        // Item被选中时触发</div><div class=\"line\">        void onItemSelected();</div><div class=\"line\"></div><div class=\"line\">        // Item在拖拽结束/滑动结束后触发</div><div class=\"line\">        void onItemFinish();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnItemTouchListener &#123;</div><div class=\"line\">        void onItemMove(int fromPosition, int toPosition);</div><div class=\"line\"></div><div class=\"line\">        void onItemDelete(int position);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>adapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，<br>ViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  public void onItemMove(int fromPosition, int toPosition) &#123;</div><div class=\"line\">      Object item = m_itemInfos.get(fromPosition);</div><div class=\"line\">      m_itemInfos.remove(fromPosition);</div><div class=\"line\">      m_itemInfos.add(toPosition, item);</div><div class=\"line\">      notifyItemMoved(fromPosition, toPosition);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onItemDelete(int position) &#123;</div><div class=\"line\">      removeItem(position);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何使用-RecyclerView\"><a href=\"#如何使用-RecyclerView\" class=\"headerlink\" title=\"如何使用 RecyclerView\"></a>如何使用 RecyclerView</h2><p>首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。<br>还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）</p>","more":"<h3 id=\"3种布局\"><a href=\"#3种布局\" class=\"headerlink\" title=\"3种布局\"></a>3种布局</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">LinearLayoutManager ： </div><div class=\"line\">LinearLayoutManager(Context context, int orientation, boolean reverseLayout)</div><div class=\"line\">很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个</div><div class=\"line\"></div><div class=\"line\">GridLayoutManager :</div><div class=\"line\">GridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)</div><div class=\"line\"></div><div class=\"line\">StaggeredGridLayoutManager:</div><div class=\"line\">StaggeredGridLayoutManager(int spanCount, int orientation)</div></pre></td></tr></table></figure>\n<h3 id=\"点击事件的实现（有两种）\"><a href=\"#点击事件的实现（有两种）\" class=\"headerlink\" title=\"点击事件的实现（有两种）\"></a>点击事件的实现（有两种）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void onBindViewHolder(final MyViewHolder holder, int position) &#123;</div><div class=\"line\">        loadThumb(position, holder);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mOnItemLitener != null) &#123;</div><div class=\"line\">            holder.itemView.setOnClickListener(new View.<span class=\"function\"><span class=\"title\">OnClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void onClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemClick(holder.itemView, pos);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">           </div><div class=\"line\">            holder.itemView.setOnLongClickListener(new View.<span class=\"function\"><span class=\"title\">OnLongClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public boolean onLongClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemLongClick(holder.itemView, pos);</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t public interface OnItemLitener &#123;</div><div class=\"line\">        void onItemClick(View view, int position);</div><div class=\"line\"></div><div class=\"line\">        void onItemLongClick(View view, int position);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private OnItemLitener mOnItemLitener;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>OnItemLitener(OnItemLitener mOnItemLitener) &#123;</div><div class=\"line\">        this.mOnItemLitener = mOnItemLitener;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑</p>\n<h3 id=\"ItemDecoration-间隔线\"><a href=\"#ItemDecoration-间隔线\" class=\"headerlink\" title=\"ItemDecoration 间隔线\"></a>ItemDecoration 间隔线</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final int[] ATTRS = new int[]&#123;android.R.attr.listDivider&#125;;</div><div class=\"line\">    private Drawable mDivider;</div><div class=\"line\"></div><div class=\"line\">    public DividerItemDecoration(Context context) &#123;</div><div class=\"line\">        final TypedArray a = context.obtainStyledAttributes(ATTRS);</div><div class=\"line\">        mDivider = a.getDrawable(0);</div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</div><div class=\"line\">        drawHorizontal(c, parent);</div><div class=\"line\">        drawVertical(c, parent);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getSpanCount(RecyclerView parent) &#123;</div><div class=\"line\">        // 列数</div><div class=\"line\">        int spanCount = -1;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\"></div><div class=\"line\">            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            spanCount = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getSpanCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> spanCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawHorizontal(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int left = child.getLeft() - params.leftMargin;</div><div class=\"line\">            final int right = child.getRight() + params.rightMargin</div><div class=\"line\">                    + mDivider.getIntrinsicWidth();</div><div class=\"line\">            final int top = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int bottom = top + mDivider.getIntrinsicHeight();</div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawVertical(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        final int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\"></div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int top = child.getTop() - params.topMargin;</div><div class=\"line\">            final int bottom = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int left = child.getRight() + params.rightMargin;</div><div class=\"line\">            final int right = left + mDivider.getIntrinsicWidth();</div><div class=\"line\"></div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; // 注意 StaggeredGridLayoutManager</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 1) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;  // 注意 StaggeredGridLayoutManager</div><div class=\"line\"></div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &lt; spanCount) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            childCount = childCount - childCount % spanCount;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            // StaggeredGridLayoutManager 且纵向滚动</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span></div><div class=\"line\">            // StaggeredGridLayoutManager 且横向滚动</div><div class=\"line\">            &#123;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0) &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 主要的绘制逻辑在这里</div><div class=\"line\">    @Override</div><div class=\"line\">    public void getItemOffsets(Rect outRect, int itemPosition,</div><div class=\"line\">                               RecyclerView parent) &#123;</div><div class=\"line\">        int spanCount = getSpanCount(parent);</div><div class=\"line\">        int childCount = parent.getAdapter().getItemCount();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(),</div><div class=\"line\">                    mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ItemTouchHelper-Callback-长按拖拽功能，滑动功能\"><a href=\"#ItemTouchHelper-Callback-长按拖拽功能，滑动功能\" class=\"headerlink\" title=\"ItemTouchHelper.Callback 长按拖拽功能，滑动功能\"></a>ItemTouchHelper.Callback 长按拖拽功能，滑动功能</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public ItemDragHelperCallback callback;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">mAddItemDragHelperCallback</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);</div><div class=\"line\">        callback.setOptions(<span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">        ItemTouchHelper helper = new ItemTouchHelper(callback);</div><div class=\"line\">        helper.attachToRecyclerView(mRecyclerView);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p>ItemDragHelperCallback 的代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ItemDragHelperCallback extends ItemTouchHelper.Callback &#123;</div><div class=\"line\"></div><div class=\"line\">    private RecyclerView.Adapter mMyRecyclerViewAdapter;</div><div class=\"line\"></div><div class=\"line\">    public ItemDragHelperCallback(RecyclerView.Adapter adapter) &#123;</div><div class=\"line\">        mMyRecyclerViewAdapter = adapter;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 这里控制了拽拉拖动的实现 </div><div class=\"line\">    @Override</div><div class=\"line\">    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        int dragFlags, swipeFlags;</div><div class=\"line\">        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">return</span> makeMovementFlags(dragFlags, swipeFlags);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123;</div><div class=\"line\">        // 不同Type之间不可移动</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder.getItemViewType() != target.getItemViewType()) &#123;</div><div class=\"line\">            <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemDelete(viewHolder.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123;</div><div class=\"line\">        // 不在闲置状态</div><div class=\"line\">        <span class=\"keyword\">if</span> (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">                itemViewHolder.onItemSelected();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.onSelectedChanged(viewHolder, actionState);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">            itemViewHolder.onItemFinish();</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.clearView(recyclerView, viewHolder);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isLongPressDragEnabled</span></span>() &#123;</div><div class=\"line\">        // 长按拖拽功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isLongPressDragEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isItemViewSwipeEnabled</span></span>() &#123;</div><div class=\"line\">        // 滑动功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>Options(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) &#123;</div><div class=\"line\">        this.isLongPressDragEnabled = isLongPressDragEnabled;</div><div class=\"line\">        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnDragVHListener &#123;</div><div class=\"line\"></div><div class=\"line\">        // Item被选中时触发</div><div class=\"line\">        void onItemSelected();</div><div class=\"line\"></div><div class=\"line\">        // Item在拖拽结束/滑动结束后触发</div><div class=\"line\">        void onItemFinish();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnItemTouchListener &#123;</div><div class=\"line\">        void onItemMove(int fromPosition, int toPosition);</div><div class=\"line\"></div><div class=\"line\">        void onItemDelete(int position);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>adapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，<br>ViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  public void onItemMove(int fromPosition, int toPosition) &#123;</div><div class=\"line\">      Object item = m_itemInfos.get(fromPosition);</div><div class=\"line\">      m_itemInfos.remove(fromPosition);</div><div class=\"line\">      m_itemInfos.add(toPosition, item);</div><div class=\"line\">      notifyItemMoved(fromPosition, toPosition);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onItemDelete(int position) &#123;</div><div class=\"line\">      removeItem(position);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>"},{"title":"memory_problem","date":"2017-10-10T07:09:28.000Z","_content":"\n## sdk 内存泄漏\n\n1.Android InputMethodManager\n\n2.MTK Webview的内存泄露(org.chromium.android_webview.AwPasswordHandler.java中private static AwPasswordHandler sInstance = null导致的内存泄露)。\n\n<!-- more -->\n\n## 常见内存泄漏\n \n1.在Activity中写一些内部类，并且这些内部类具有生命周期过长的现象\n\n2.非静态内部类导致的内存泄露，比如Handler（持有this），解决方法是将内部类写成静态内部类，在静态内部类中使用软引用/弱引用持有外部类的实例\n\n3.资源对象没有关闭，比如数据库操作中得Cursor,IO操作的对象\n\n4.调用了registerReceiver注册广播后未调用unregisterReceiver()来取消\n\n5.调用了View.getViewTreeObserver().addOnXXXListener ,而没有调用View.getViewTreeObserver().removeXXXListener\n\n6.Context的泄露，比如我们在单例类中使用Context对象，解决方案：使用getApplicationContext()来代替Activity的Context\n\n## 内存检测工具\n\n1.DDMS(Dalvik Debug Monitor Server)和MAT(Memory Analyzer Tool)工具\n\n2.Android studio 自带的 Android Profiler\n\n3.LeakCanary","source":"_posts/memory-problem.md","raw":"---\ntitle: memory_problem\ndate: 2017-10-10 15:09:28\ncategories: android\ntags: 内存\n---\n\n## sdk 内存泄漏\n\n1.Android InputMethodManager\n\n2.MTK Webview的内存泄露(org.chromium.android_webview.AwPasswordHandler.java中private static AwPasswordHandler sInstance = null导致的内存泄露)。\n\n<!-- more -->\n\n## 常见内存泄漏\n \n1.在Activity中写一些内部类，并且这些内部类具有生命周期过长的现象\n\n2.非静态内部类导致的内存泄露，比如Handler（持有this），解决方法是将内部类写成静态内部类，在静态内部类中使用软引用/弱引用持有外部类的实例\n\n3.资源对象没有关闭，比如数据库操作中得Cursor,IO操作的对象\n\n4.调用了registerReceiver注册广播后未调用unregisterReceiver()来取消\n\n5.调用了View.getViewTreeObserver().addOnXXXListener ,而没有调用View.getViewTreeObserver().removeXXXListener\n\n6.Context的泄露，比如我们在单例类中使用Context对象，解决方案：使用getApplicationContext()来代替Activity的Context\n\n## 内存检测工具\n\n1.DDMS(Dalvik Debug Monitor Server)和MAT(Memory Analyzer Tool)工具\n\n2.Android studio 自带的 Android Profiler\n\n3.LeakCanary","slug":"memory-problem","published":1,"updated":"2018-02-10T08:06:50.611Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbl0013o4l1ok2aqakz","content":"<h2 id=\"sdk-内存泄漏\"><a href=\"#sdk-内存泄漏\" class=\"headerlink\" title=\"sdk 内存泄漏\"></a>sdk 内存泄漏</h2><p>1.Android InputMethodManager</p>\n<p>2.MTK Webview的内存泄露(org.chromium.android_webview.AwPasswordHandler.java中private static AwPasswordHandler sInstance = null导致的内存泄露)。</p>\n<a id=\"more\"></a>\n<h2 id=\"常见内存泄漏\"><a href=\"#常见内存泄漏\" class=\"headerlink\" title=\"常见内存泄漏\"></a>常见内存泄漏</h2><p>1.在Activity中写一些内部类，并且这些内部类具有生命周期过长的现象</p>\n<p>2.非静态内部类导致的内存泄露，比如Handler（持有this），解决方法是将内部类写成静态内部类，在静态内部类中使用软引用/弱引用持有外部类的实例</p>\n<p>3.资源对象没有关闭，比如数据库操作中得Cursor,IO操作的对象</p>\n<p>4.调用了registerReceiver注册广播后未调用unregisterReceiver()来取消</p>\n<p>5.调用了View.getViewTreeObserver().addOnXXXListener ,而没有调用View.getViewTreeObserver().removeXXXListener</p>\n<p>6.Context的泄露，比如我们在单例类中使用Context对象，解决方案：使用getApplicationContext()来代替Activity的Context</p>\n<h2 id=\"内存检测工具\"><a href=\"#内存检测工具\" class=\"headerlink\" title=\"内存检测工具\"></a>内存检测工具</h2><p>1.DDMS(Dalvik Debug Monitor Server)和MAT(Memory Analyzer Tool)工具</p>\n<p>2.Android studio 自带的 Android Profiler</p>\n<p>3.LeakCanary</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"sdk-内存泄漏\"><a href=\"#sdk-内存泄漏\" class=\"headerlink\" title=\"sdk 内存泄漏\"></a>sdk 内存泄漏</h2><p>1.Android InputMethodManager</p>\n<p>2.MTK Webview的内存泄露(org.chromium.android_webview.AwPasswordHandler.java中private static AwPasswordHandler sInstance = null导致的内存泄露)。</p>","more":"<h2 id=\"常见内存泄漏\"><a href=\"#常见内存泄漏\" class=\"headerlink\" title=\"常见内存泄漏\"></a>常见内存泄漏</h2><p>1.在Activity中写一些内部类，并且这些内部类具有生命周期过长的现象</p>\n<p>2.非静态内部类导致的内存泄露，比如Handler（持有this），解决方法是将内部类写成静态内部类，在静态内部类中使用软引用/弱引用持有外部类的实例</p>\n<p>3.资源对象没有关闭，比如数据库操作中得Cursor,IO操作的对象</p>\n<p>4.调用了registerReceiver注册广播后未调用unregisterReceiver()来取消</p>\n<p>5.调用了View.getViewTreeObserver().addOnXXXListener ,而没有调用View.getViewTreeObserver().removeXXXListener</p>\n<p>6.Context的泄露，比如我们在单例类中使用Context对象，解决方案：使用getApplicationContext()来代替Activity的Context</p>\n<h2 id=\"内存检测工具\"><a href=\"#内存检测工具\" class=\"headerlink\" title=\"内存检测工具\"></a>内存检测工具</h2><p>1.DDMS(Dalvik Debug Monitor Server)和MAT(Memory Analyzer Tool)工具</p>\n<p>2.Android studio 自带的 Android Profiler</p>\n<p>3.LeakCanary</p>"},{"title":"recyclerview 自定义动画","date":"2017-06-04T08:19:42.000Z","_content":"\n## DefaultItemAnimator \n\nRecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画\nDefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析\n\n``` bash\n public class BaseItemAnimator extends SimpleItemAnimator {\n    //Item移除回调\n    @Override\n    public boolean animateRemove(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n    //Item添加回调\n    @Override\n    public boolean animateAdd(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n\n    //用于控制添加，移动更新时，其它Item的动画执行\n    @Override\n    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) {\n        return false;\n    }\n\n    //Item更新回调\n    @Override\n    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) {\n        return false;\n    }\n\n    //真正控制执行动画的地方\n    @Override\n    public void runPendingAnimations() {\n\n    }\n\n    //停止某个Item的动画\n    @Override\n    public void endAnimation(RecyclerView.ViewHolder item) {\n\n    }\n\n    //停止所有动画\n    @Override\n    public void endAnimations() {\n\n    }\n\n    @Override\n    public boolean isRunning() {\n        return false;\n    }\n}\n```\n\n<!-- more -->\n\n具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add\n``` bash\n\t\t// Next, add stuff\n        if (additionsPending) {\n            final ArrayList<ViewHolder> additions = new ArrayList<>();\n            additions.addAll(mPendingAdditions);\n            mAdditionsList.add(additions);\n            mPendingAdditions.clear();\n            Runnable adder = new Runnable() {\n                @Override\n                public void run() {\n                    for (ViewHolder holder : additions) {\n                        animateAddImpl(holder);\n                    }\n                    additions.clear();\n                    mAdditionsList.remove(additions);\n                }\n            };\n            if (removalsPending || movesPending || changesPending) {\n                long removeDuration = removalsPending ? getRemoveDuration() : 0;\n                long moveDuration = movesPending ? getMoveDuration() : 0;\n                long changeDuration = changesPending ? getChangeDuration() : 0;\n                long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);\n                View view = additions.get(0).itemView;\n                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算\n            } else {\n                adder.run();\n            }\n        }\n```\n\n## ViewPropertyAnimatorCompat\n\nDefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说\n``` bash\n private void animateRemoveImpl(final ViewHolder holder) {\n        final View view = holder.itemView;\n        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);\n        mRemoveAnimations.add(holder);\n        animation.setDuration(getRemoveDuration())\n                .alpha(0).setListener(new VpaListenerAdapter() {\n            @Override\n            public void onAnimationStart(View view) {\n                dispatchRemoveStarting(holder);\n            }\n\n            @Override\n            public void onAnimationEnd(View view) {\n                animation.setListener(null);\n                ViewCompat.setAlpha(view, 1);\n                dispatchRemoveFinished(holder);\n                mRemoveAnimations.remove(holder);\n                dispatchFinishedWhenDone();\n            }\n        }).start();\n    }\n```\n这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画\n``` bash\n    interface ViewPropertyAnimatorCompatImpl {\n        public void setDuration(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getDuration(ViewPropertyAnimatorCompat vpa, View view);\n        public void setInterpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);\n        public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);\n        public void setStartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);\n        public void alpha(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotation(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void cancel(ViewPropertyAnimatorCompat vpa, View view);\n        public void x(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void xBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void y(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void yBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void z(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void zBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZ(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void start(ViewPropertyAnimatorCompat vpa, View view);\n        public void withLayer(ViewPropertyAnimatorCompat vpa, View view);\n        public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void setListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorListener listener);\n        public void setUpdateListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorUpdateListener listener);\n    };\n```","source":"_posts/recyclerviewANM.md","raw":"---\ntitle: recyclerview 自定义动画\ndate: 2017-06-04 16:19:42\ncategories: android\ntags: recyclerview\n---\n\n## DefaultItemAnimator \n\nRecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画\nDefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析\n\n``` bash\n public class BaseItemAnimator extends SimpleItemAnimator {\n    //Item移除回调\n    @Override\n    public boolean animateRemove(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n    //Item添加回调\n    @Override\n    public boolean animateAdd(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n\n    //用于控制添加，移动更新时，其它Item的动画执行\n    @Override\n    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) {\n        return false;\n    }\n\n    //Item更新回调\n    @Override\n    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) {\n        return false;\n    }\n\n    //真正控制执行动画的地方\n    @Override\n    public void runPendingAnimations() {\n\n    }\n\n    //停止某个Item的动画\n    @Override\n    public void endAnimation(RecyclerView.ViewHolder item) {\n\n    }\n\n    //停止所有动画\n    @Override\n    public void endAnimations() {\n\n    }\n\n    @Override\n    public boolean isRunning() {\n        return false;\n    }\n}\n```\n\n<!-- more -->\n\n具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add\n``` bash\n\t\t// Next, add stuff\n        if (additionsPending) {\n            final ArrayList<ViewHolder> additions = new ArrayList<>();\n            additions.addAll(mPendingAdditions);\n            mAdditionsList.add(additions);\n            mPendingAdditions.clear();\n            Runnable adder = new Runnable() {\n                @Override\n                public void run() {\n                    for (ViewHolder holder : additions) {\n                        animateAddImpl(holder);\n                    }\n                    additions.clear();\n                    mAdditionsList.remove(additions);\n                }\n            };\n            if (removalsPending || movesPending || changesPending) {\n                long removeDuration = removalsPending ? getRemoveDuration() : 0;\n                long moveDuration = movesPending ? getMoveDuration() : 0;\n                long changeDuration = changesPending ? getChangeDuration() : 0;\n                long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);\n                View view = additions.get(0).itemView;\n                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算\n            } else {\n                adder.run();\n            }\n        }\n```\n\n## ViewPropertyAnimatorCompat\n\nDefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说\n``` bash\n private void animateRemoveImpl(final ViewHolder holder) {\n        final View view = holder.itemView;\n        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);\n        mRemoveAnimations.add(holder);\n        animation.setDuration(getRemoveDuration())\n                .alpha(0).setListener(new VpaListenerAdapter() {\n            @Override\n            public void onAnimationStart(View view) {\n                dispatchRemoveStarting(holder);\n            }\n\n            @Override\n            public void onAnimationEnd(View view) {\n                animation.setListener(null);\n                ViewCompat.setAlpha(view, 1);\n                dispatchRemoveFinished(holder);\n                mRemoveAnimations.remove(holder);\n                dispatchFinishedWhenDone();\n            }\n        }).start();\n    }\n```\n这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画\n``` bash\n    interface ViewPropertyAnimatorCompatImpl {\n        public void setDuration(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getDuration(ViewPropertyAnimatorCompat vpa, View view);\n        public void setInterpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);\n        public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);\n        public void setStartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);\n        public void alpha(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotation(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void cancel(ViewPropertyAnimatorCompat vpa, View view);\n        public void x(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void xBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void y(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void yBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void z(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void zBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZ(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void start(ViewPropertyAnimatorCompat vpa, View view);\n        public void withLayer(ViewPropertyAnimatorCompat vpa, View view);\n        public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void setListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorListener listener);\n        public void setUpdateListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorUpdateListener listener);\n    };\n```","slug":"recyclerviewANM","published":1,"updated":"2018-02-10T06:53:50.954Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbo0017o4l1tjiskgyo","content":"<h2 id=\"DefaultItemAnimator\"><a href=\"#DefaultItemAnimator\" class=\"headerlink\" title=\"DefaultItemAnimator\"></a>DefaultItemAnimator</h2><p>RecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画<br>DefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class BaseItemAnimator extends SimpleItemAnimator &#123;</div><div class=\"line\">    //Item移除回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateRemove(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item添加回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateAdd(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    //用于控制添加，移动更新时，其它Item的动画执行</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item更新回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //真正控制执行动画的地方</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">runPendingAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止某个Item的动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void endAnimation(RecyclerView.ViewHolder item) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止所有动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">endAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isRunning</span></span>() &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Next, add stuff</div><div class=\"line\">      <span class=\"keyword\">if</span> (additionsPending) &#123;</div><div class=\"line\">          final ArrayList&lt;ViewHolder&gt; additions = new ArrayList&lt;&gt;();</div><div class=\"line\">          additions.addAll(mPendingAdditions);</div><div class=\"line\">          mAdditionsList.add(additions);</div><div class=\"line\">          mPendingAdditions.clear();</div><div class=\"line\">          Runnable adder = new <span class=\"function\"><span class=\"title\">Runnable</span></span>() &#123;</div><div class=\"line\">              @Override</div><div class=\"line\">              public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">                  <span class=\"keyword\">for</span> (ViewHolder holder : additions) &#123;</div><div class=\"line\">                      animateAddImpl(holder);</div><div class=\"line\">                  &#125;</div><div class=\"line\">                  additions.clear();</div><div class=\"line\">                  mAdditionsList.remove(additions);</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;;</div><div class=\"line\">          <span class=\"keyword\">if</span> (removalsPending || movesPending || changesPending) &#123;</div><div class=\"line\">              long removeDuration = removalsPending ? getRemoveDuration() : 0;</div><div class=\"line\">              long moveDuration = movesPending ? getMoveDuration() : 0;</div><div class=\"line\">              long changeDuration = changesPending ? getChangeDuration() : 0;</div><div class=\"line\">              long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</div><div class=\"line\">              View view = additions.get(0).itemView;</div><div class=\"line\">              ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              adder.run();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"ViewPropertyAnimatorCompat\"><a href=\"#ViewPropertyAnimatorCompat\" class=\"headerlink\" title=\"ViewPropertyAnimatorCompat\"></a>ViewPropertyAnimatorCompat</h2><p>DefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void animateRemoveImpl(final ViewHolder holder) &#123;</div><div class=\"line\">       final View view = holder.itemView;</div><div class=\"line\">       final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class=\"line\">       mRemoveAnimations.add(holder);</div><div class=\"line\">       animation.setDuration(getRemoveDuration())</div><div class=\"line\">               .alpha(0).setListener(new <span class=\"function\"><span class=\"title\">VpaListenerAdapter</span></span>() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationStart(View view) &#123;</div><div class=\"line\">               dispatchRemoveStarting(holder);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationEnd(View view) &#123;</div><div class=\"line\">               animation.setListener(null);</div><div class=\"line\">               ViewCompat.setAlpha(view, 1);</div><div class=\"line\">               dispatchRemoveFinished(holder);</div><div class=\"line\">               mRemoveAnimations.remove(holder);</div><div class=\"line\">               dispatchFinishedWhenDone();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;).start();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface ViewPropertyAnimatorCompatImpl &#123;</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Duration(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getDuration(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Interpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);</div><div class=\"line\">    public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>StartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void alpha(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotation(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void cancel(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void x(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void xBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void y(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void yBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void z(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void zBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZ(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void start(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withLayer(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Listener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorListener listener);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>UpdateListener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorUpdateListener listener);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"DefaultItemAnimator\"><a href=\"#DefaultItemAnimator\" class=\"headerlink\" title=\"DefaultItemAnimator\"></a>DefaultItemAnimator</h2><p>RecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画<br>DefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class BaseItemAnimator extends SimpleItemAnimator &#123;</div><div class=\"line\">    //Item移除回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateRemove(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item添加回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateAdd(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    //用于控制添加，移动更新时，其它Item的动画执行</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item更新回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //真正控制执行动画的地方</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">runPendingAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止某个Item的动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void endAnimation(RecyclerView.ViewHolder item) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止所有动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">endAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isRunning</span></span>() &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Next, add stuff</div><div class=\"line\">      <span class=\"keyword\">if</span> (additionsPending) &#123;</div><div class=\"line\">          final ArrayList&lt;ViewHolder&gt; additions = new ArrayList&lt;&gt;();</div><div class=\"line\">          additions.addAll(mPendingAdditions);</div><div class=\"line\">          mAdditionsList.add(additions);</div><div class=\"line\">          mPendingAdditions.clear();</div><div class=\"line\">          Runnable adder = new <span class=\"function\"><span class=\"title\">Runnable</span></span>() &#123;</div><div class=\"line\">              @Override</div><div class=\"line\">              public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">                  <span class=\"keyword\">for</span> (ViewHolder holder : additions) &#123;</div><div class=\"line\">                      animateAddImpl(holder);</div><div class=\"line\">                  &#125;</div><div class=\"line\">                  additions.clear();</div><div class=\"line\">                  mAdditionsList.remove(additions);</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;;</div><div class=\"line\">          <span class=\"keyword\">if</span> (removalsPending || movesPending || changesPending) &#123;</div><div class=\"line\">              long removeDuration = removalsPending ? getRemoveDuration() : 0;</div><div class=\"line\">              long moveDuration = movesPending ? getMoveDuration() : 0;</div><div class=\"line\">              long changeDuration = changesPending ? getChangeDuration() : 0;</div><div class=\"line\">              long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</div><div class=\"line\">              View view = additions.get(0).itemView;</div><div class=\"line\">              ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              adder.run();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"ViewPropertyAnimatorCompat\"><a href=\"#ViewPropertyAnimatorCompat\" class=\"headerlink\" title=\"ViewPropertyAnimatorCompat\"></a>ViewPropertyAnimatorCompat</h2><p>DefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void animateRemoveImpl(final ViewHolder holder) &#123;</div><div class=\"line\">       final View view = holder.itemView;</div><div class=\"line\">       final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class=\"line\">       mRemoveAnimations.add(holder);</div><div class=\"line\">       animation.setDuration(getRemoveDuration())</div><div class=\"line\">               .alpha(0).setListener(new <span class=\"function\"><span class=\"title\">VpaListenerAdapter</span></span>() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationStart(View view) &#123;</div><div class=\"line\">               dispatchRemoveStarting(holder);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationEnd(View view) &#123;</div><div class=\"line\">               animation.setListener(null);</div><div class=\"line\">               ViewCompat.setAlpha(view, 1);</div><div class=\"line\">               dispatchRemoveFinished(holder);</div><div class=\"line\">               mRemoveAnimations.remove(holder);</div><div class=\"line\">               dispatchFinishedWhenDone();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;).start();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface ViewPropertyAnimatorCompatImpl &#123;</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Duration(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getDuration(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Interpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);</div><div class=\"line\">    public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>StartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void alpha(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotation(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void cancel(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void x(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void xBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void y(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void yBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void z(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void zBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZ(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void start(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withLayer(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Listener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorListener listener);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>UpdateListener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorUpdateListener listener);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>"},{"title":"线程池ThreadPoolExecutor","date":"2017-05-10T08:58:30.000Z","_content":"\n1.ThreadPoolExecutor参数\n\njdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。 \nThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler) \ncorePoolSize: 核心线程数，能够同时执行的任务数量； \nmaximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）； \nkeepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间； \nunit：时间单位； \nworkQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满； \nthreadFactory：创建线程的工厂，使用系统默认的类； \nhandler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；\n\n<!-- more -->\n\n2.阻塞队列\n\n队列用于排队，避免一瞬间出现大量请求的问题。 \n阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。\n\n3.执行流程\n\n当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。 \n下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。\n\n4.代码\n``` bash\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        /**\n         * 创建九个任务\n         */\n        for (int i = 0; i < 9; i++) {\n            ThreadPoolManager.getInstance().execute(new DownloadTask(i));\n        }\n    }\n    /**\n     * 模仿下载任务，实现Runnable\n     */\n    class DownloadTask implements Runnable{\n        private int num;\n        public DownloadTask(int num) {\n            super();\n            this.num = num;\n            Log.d(\"JAVA\", \"task - \"+num + \" 等待中...\");\n        }\n        @Override\n        public void run() {\n            Log.d(\"JAVA\", \"task - \"+num + \" 开始执行了...开始执行了...\");\n            SystemClock.sleep(5000); //模拟延时执行的时间\n            Log.e(\"JAVA\", \"task - \"+num + \" 结束了...\");\n        }\n    }\n}\n```\n运行结果\n![运行结果](http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg)","source":"_posts/threadPoolExecutor.md","raw":"---\ntitle: 线程池ThreadPoolExecutor\ndate: 2017-05-10 16:58:30\ncategories: android\ntags: 多线程\n---\n\n1.ThreadPoolExecutor参数\n\njdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。 \nThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler) \ncorePoolSize: 核心线程数，能够同时执行的任务数量； \nmaximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）； \nkeepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间； \nunit：时间单位； \nworkQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满； \nthreadFactory：创建线程的工厂，使用系统默认的类； \nhandler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；\n\n<!-- more -->\n\n2.阻塞队列\n\n队列用于排队，避免一瞬间出现大量请求的问题。 \n阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。\n\n3.执行流程\n\n当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。 \n下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。\n\n4.代码\n``` bash\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        /**\n         * 创建九个任务\n         */\n        for (int i = 0; i < 9; i++) {\n            ThreadPoolManager.getInstance().execute(new DownloadTask(i));\n        }\n    }\n    /**\n     * 模仿下载任务，实现Runnable\n     */\n    class DownloadTask implements Runnable{\n        private int num;\n        public DownloadTask(int num) {\n            super();\n            this.num = num;\n            Log.d(\"JAVA\", \"task - \"+num + \" 等待中...\");\n        }\n        @Override\n        public void run() {\n            Log.d(\"JAVA\", \"task - \"+num + \" 开始执行了...开始执行了...\");\n            SystemClock.sleep(5000); //模拟延时执行的时间\n            Log.e(\"JAVA\", \"task - \"+num + \" 结束了...\");\n        }\n    }\n}\n```\n运行结果\n![运行结果](http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg)","slug":"threadPoolExecutor","published":1,"updated":"2018-02-10T06:53:50.955Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbq001ao4l1hpb6ra4p","content":"<p>1.ThreadPoolExecutor参数</p>\n<p>jdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。<br>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler)<br>corePoolSize: 核心线程数，能够同时执行的任务数量；<br>maximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）；<br>keepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间；<br>unit：时间单位；<br>workQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满；<br>threadFactory：创建线程的工厂，使用系统默认的类；<br>handler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；</p>\n<a id=\"more\"></a>\n<p>2.阻塞队列</p>\n<p>队列用于排队，避免一瞬间出现大量请求的问题。<br>阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。</p>\n<p>3.执行流程</p>\n<p>当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。<br>下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。</p>\n<p>4.代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends AppCompatActivity &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">        super.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.activity_main);</div><div class=\"line\">        /**</div><div class=\"line\">         * 创建九个任务</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 9; i++) &#123;</div><div class=\"line\">            ThreadPoolManager.getInstance().execute(new DownloadTask(i));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /**</div><div class=\"line\">     * 模仿下载任务，实现Runnable</div><div class=\"line\">     */</div><div class=\"line\">    class DownloadTask implements Runnable&#123;</div><div class=\"line\">        private int num;</div><div class=\"line\">        public DownloadTask(int num) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            this.num = num;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 等待中...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 开始执行了...开始执行了...\"</span>);</div><div class=\"line\">            SystemClock.sleep(5000); //模拟延时执行的时间</div><div class=\"line\">            Log.e(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 结束了...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果<br><img src=\"http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg\" alt=\"运行结果\"></p>\n","site":{"data":{}},"excerpt":"<p>1.ThreadPoolExecutor参数</p>\n<p>jdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。<br>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler)<br>corePoolSize: 核心线程数，能够同时执行的任务数量；<br>maximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）；<br>keepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间；<br>unit：时间单位；<br>workQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满；<br>threadFactory：创建线程的工厂，使用系统默认的类；<br>handler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；</p>","more":"<p>2.阻塞队列</p>\n<p>队列用于排队，避免一瞬间出现大量请求的问题。<br>阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。</p>\n<p>3.执行流程</p>\n<p>当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。<br>下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。</p>\n<p>4.代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends AppCompatActivity &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">        super.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.activity_main);</div><div class=\"line\">        /**</div><div class=\"line\">         * 创建九个任务</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 9; i++) &#123;</div><div class=\"line\">            ThreadPoolManager.getInstance().execute(new DownloadTask(i));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /**</div><div class=\"line\">     * 模仿下载任务，实现Runnable</div><div class=\"line\">     */</div><div class=\"line\">    class DownloadTask implements Runnable&#123;</div><div class=\"line\">        private int num;</div><div class=\"line\">        public DownloadTask(int num) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            this.num = num;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 等待中...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 开始执行了...开始执行了...\"</span>);</div><div class=\"line\">            SystemClock.sleep(5000); //模拟延时执行的时间</div><div class=\"line\">            Log.e(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 结束了...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果<br><img src=\"http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg\" alt=\"运行结果\"></p>"},{"title":"tip","date":"2017-09-17T12:20:20.000Z","_content":"\n## 坑与提示\n\n### 记得吃药\n\n<!-- more -->\n\n### Today is a special one ， hand in hand ！\n\n### other\n\n旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置","source":"_posts/tip.md","raw":"---\ntitle: tip\ndate: 2017-09-17 20:20:20\ncategories: fdbook\ntags: tip\n---\n\n## 坑与提示\n\n### 记得吃药\n\n<!-- more -->\n\n### Today is a special one ， hand in hand ！\n\n### other\n\n旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置","slug":"tip","published":1,"updated":"2018-02-10T06:53:50.957Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbu001eo4l1347jwz59","content":"<h2 id=\"坑与提示\"><a href=\"#坑与提示\" class=\"headerlink\" title=\"坑与提示\"></a>坑与提示</h2><h3 id=\"记得吃药\"><a href=\"#记得吃药\" class=\"headerlink\" title=\"记得吃药\"></a>记得吃药</h3><a id=\"more\"></a>\n<h3 id=\"Today-is-a-special-one-，-hand-in-hand-！\"><a href=\"#Today-is-a-special-one-，-hand-in-hand-！\" class=\"headerlink\" title=\"Today is a special one ， hand in hand ！\"></a>Today is a special one ， hand in hand ！</h3><h3 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h3><p>旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"坑与提示\"><a href=\"#坑与提示\" class=\"headerlink\" title=\"坑与提示\"></a>坑与提示</h2><h3 id=\"记得吃药\"><a href=\"#记得吃药\" class=\"headerlink\" title=\"记得吃药\"></a>记得吃药</h3>","more":"<h3 id=\"Today-is-a-special-one-，-hand-in-hand-！\"><a href=\"#Today-is-a-special-one-，-hand-in-hand-！\" class=\"headerlink\" title=\"Today is a special one ， hand in hand ！\"></a>Today is a special one ， hand in hand ！</h3><h3 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h3><p>旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置</p>"},{"title":"view_anm","date":"2017-11-11T07:08:13.000Z","_content":"\n## 安卓动画简介\n\n总的来说，Android动画可以分为两类，最初的传统动画和Android3.0 之后出现的属性动画；\n传统动画又包括 帧动画（Frame Animation）和补间动画（Tweened Animation）。\n温馨提示 ： 本文所有动画没有使用xml的实现只介绍代码实现\n\n<!-- more -->\n\n### 帧动画（Frame Animation）\n\n他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。\n\n``` bash\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:drawable=\"@drawable/a_0\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_2\"\n        android:duration=\"100\" />\n</animation-list>\n\nImageView animationImg1 = (ImageView) findViewById(R.id.animation1);\n        animationImg1.setImageResource(R.drawable.frame_anim1);\n        AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();\n        animationDrawable1.start();\n```\n\n### 补间动画（Tweened Animation）\n\n不改变view的实际属性，只改变绘制效果\n\n``` bash\nandroid:fillAfter 如果设置为true，控件动画结束时，将保持动画最后时的状态\nandroid:fillBefore       如果设置为true,控件动画结束时，还原到开始动画前的状态\nandroid:fillEnabled    与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态\nandroid:repeatCount 重复次数\nandroid:repeatMode\t重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。\nandroid:interpolator  设定插值器\n\n缩放\nScaleAnimation(float fromX, float toX, float fromY, float toY,\n            float pivotX, float pivotY) {}\nScaleAnimation(float fromX, float toX, float fromY, float toY,int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) {}\n\n旋转\nRotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY){}\nRotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,int pivotYType, float pivotYValue) {\n\n位移\nTranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) {}\t\t\nTranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,int fromYType, float fromYValue, int toYType, float toYValue) {}\n\n透明度\nAlphaAnimation(float fromAlpha, float toAlpha)\n\n动画集 \nAnimationSet animationSet = new AnimationSet(true);\nanimationSet.setAnimationListener(animationListener);\nview.startAnimation(animationSet);\n```\n\n### 属性动画\n\n改变的是对象的实际属性\n\n1.ValueAnimator \n\n``` bash \n\npublic static ValueAnimator ofInt(int... values)  \npublic static ValueAnimator ofFloat(float... values)\n参数类型都是可变参数长参数，所以我们可以传入任何数量的值；\n传进去的值列表，就表示动画时的变化范围；比如ofInt(5,88,55)就表示从数值5变化到数字88再变化到数字55\n\nValueAnimator animator = ValueAnimator.ofInt(0,500);  \nanimator.setDuration(1000);  \n\nanimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {  \n    @Override  \n    public void onAnimationUpdate(ValueAnimator animation) {  \n        int curValue = (int)animation.getAnimatedValue();   \n    }  \n});  \nanimator.start(); \n```\n\n2.ObjectAnimator\n\n``` bash\nObjectAnimator oa=ObjectAnimator.ofFloat(tv, \"alpha\", 0f, 1f); // \"rotation\" , \"translationX\" , \"scaleX\" ...\n\n动画集\nAnimatorSet bouncer = new AnimatorSet();\nbouncer.play(anim1).before(anim2);\nbouncer.play(anim2).with(anim3);\nbouncer.play(anim2).with(anim4)\nbouncer.play(anim5).after(amin2);\nanimatorSet.start();\n```\n\n### ViewPropertyAnimator\n\n如果需要对一个View的多个属性进行动画可以用ViewPropertyAnimator类，该类对多属性动画进行了优化，会合并一些invalidate()来减少刷新视图，该类在3.1中引入\n\n``` bash\nPropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f);\nPropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f);\nObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();\nmyView.animate().x(50f).y(100f);\n```\n\n### LayoutTransition\n\n在3.0及以后只需要在XML中设置animateLayoutChanges=\"true\"或者在Java代码中添加一个LayoutTransition对象\n\n1.APPEARING：容器中出现一个视图。\n\n2.DISAPPEARING：容器中消失一个视图。\n\n3.CHANGING：布局改变导致某个视图随之改变，例如调整大小，但不包括添加或者移除视图。\n\n4.CHANGE_APPEARING：其他视图的出现导致某个视图改变。\n\n5.CHANGE_DISAPPEARING：其他视图的消失导致某个视图改变。\n\n``` bash\nView mContainer = (LinearLayout) findViewById(R.id.main_container);  \nLayoutTransition transition = new LayoutTransition();  \nmContainer.setLayoutTransition(transition);  \nfindViewById(R.id.main_btn).setOnClickListener(this);  \n  \n//使用翻转进入的动画代替默认动画  \nAnimator appearAnim = ObjectAnimator  \n        .ofFloat(null, \"rotationY\", 90f, 0)  \n        .setDuration(transition.getDuration(LayoutTransition.APPEARING));  \ntransition.setAnimator(LayoutTransition.APPEARING, appearAnim);  \n  \n//使用翻转消失的动画代替默认动画  \nAnimator disappearAnim = ObjectAnimator.ofFloat(null, \"rotationX\", 0, 90f).setDuration( transition.getDuration(LayoutTransition.DISAPPEARING));  \ntransition.setAnimator(LayoutTransition.DISAPPEARING, disappearAnim);  \n  \n//使用滑动动画代替默认布局改变的动画  \n//这个动画会让视图滑动进入并短暂地缩小一半，具有平滑和缩放的效果  \nPropertyValuesHolder pvhSlide = PropertyValuesHolder.ofFloat(\"y\", 0, 1);  \nPropertyValuesHolder pvhScaleY = PropertyValuesHolder.ofFloat(\"scaleY\", 1f, 0.5f, 1f);  \nPropertyValuesHolder pvhScaleX = PropertyValuesHolder.ofFloat(\"scaleX\", 1f, 0.5f, 1f);  \n  \n//这里将上面三个动画综合  \nAnimator changingDisappearAnim = ObjectAnimator.ofPropertyValuesHolder(this, pvhSlide, pvhScaleY, pvhScaleX);  \nchangingDisappearAnim.setDuration(transition.getDuration(LayoutTransition.CHANGE_DISAPPEARING));  \ntransition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING,changingDisappearAnim);  \n```\n\n### Keyframes\n\n可以让我们定义除了开始和结束以外的关键帧。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，\n然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象\n\n``` bash\n//设置btn对象的width属性值使其：开始时 Width=400，动画开始1/4时 Width=200，动画开始1/2时 Width=400，动画开始3/4时 Width=100，动画结束时 Width=500\nKeyframe kf0 = Keyframe.ofInt(0, 400);\nKeyframe kf1 = Keyframe.ofInt(0.25f, 200);\nKeyframe kf2 = Keyframe.ofInt(0.5f, 400);\nKeyframe kf4 = Keyframe.ofInt(0.75f, 100);\nKeyframe kf3 = Keyframe.ofInt(1f, 500);\nPropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(width, kf0, kf1, kf2, kf4, kf3);\nObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn, pvhRotation);\n```\n\n### TimeInterplator\n\nTime interplator定义了属性值变化的方式，如线性均匀改变，开始慢然后逐渐快等。在Property Animation中是TimeInterplator，在View Animation中是Interplator，这两个是一样的，在3.0之前只有Interplator，3.0之后实现代码转移至了TimeInterplator。Interplator继承自TimeInterplator，内部没有任何其他代码。\n\n``` bash\nAccelerateInterpolator　　　　　     加速，开始时慢中间加速\nDecelerateInterpolator　　　 　　   减速，开始时快然后减速\nAccelerateDecelerateInterolator　   先加速后减速，开始结束时慢，中间加速\nAnticipateInterpolator　　　　　　  反向 ，先向相反方向改变一段再加速播放\nAnticipateOvershootInterpolator　   反向加回弹，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值\nBounceInterpolator　　　　　　　  跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100\nCycleIinterpolator　　　　　　　　 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI * input)\nLinearInterpolator　　　　　　　　 线性，线性均匀改变\nOvershottInterpolator　　　　　　  回弹，最后超出目的值然后缓慢改变到目的值\nTimeInterpolator　　　　　　　　   一个接口，允许你自定义interpolator，以上几个都是实现了这个接口\n\n自定义 \npublic class MyInterploator implements TimeInterpolator {  \n    @Override  \n    public float getInterpolation(float input) {  \n        return 1-input;  \n    }  \n}  \n```\n\n### TypeEvalutors\n\n根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值，android提供了以下几个evalutor：\n\nIntEvaluator：属性的值类型为int；\nFloatEvaluator：属性的值类型为float；\nArgbEvaluator：属性的值类型为十六进制颜色值；\nTypeEvaluator：一个接口，可以通过实现该接口自定义Evaluator。\n自定义TypeEvalutor很简单，只需要实现一个方法，如FloatEvalutor的定义：\n\n``` bash\npublic class FloatEvaluator implements TypeEvaluator {\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n        float startFloat = ((Number) startValue).floatValue();\n        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);\n    }\n}\n根据动画执行的时间跟应用的Interplator，会计算出一个0~1之间的因子，即evalute函数中的fraction参数，通过上述FloatEvaluator应该很好看出其意思。\n```\n\n","source":"_posts/view-anm.md","raw":"---\ntitle: view_anm\ndate: 2017-11-11 15:08:13\ncategories: android\ntags: 动画\n---\n\n## 安卓动画简介\n\n总的来说，Android动画可以分为两类，最初的传统动画和Android3.0 之后出现的属性动画；\n传统动画又包括 帧动画（Frame Animation）和补间动画（Tweened Animation）。\n温馨提示 ： 本文所有动画没有使用xml的实现只介绍代码实现\n\n<!-- more -->\n\n### 帧动画（Frame Animation）\n\n他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。\n\n``` bash\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\">\n    <item\n        android:drawable=\"@drawable/a_0\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_1\"\n        android:duration=\"100\" />\n    <item\n        android:drawable=\"@drawable/a_2\"\n        android:duration=\"100\" />\n</animation-list>\n\nImageView animationImg1 = (ImageView) findViewById(R.id.animation1);\n        animationImg1.setImageResource(R.drawable.frame_anim1);\n        AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();\n        animationDrawable1.start();\n```\n\n### 补间动画（Tweened Animation）\n\n不改变view的实际属性，只改变绘制效果\n\n``` bash\nandroid:fillAfter 如果设置为true，控件动画结束时，将保持动画最后时的状态\nandroid:fillBefore       如果设置为true,控件动画结束时，还原到开始动画前的状态\nandroid:fillEnabled    与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态\nandroid:repeatCount 重复次数\nandroid:repeatMode\t重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。\nandroid:interpolator  设定插值器\n\n缩放\nScaleAnimation(float fromX, float toX, float fromY, float toY,\n            float pivotX, float pivotY) {}\nScaleAnimation(float fromX, float toX, float fromY, float toY,int pivotXType, float pivotXValue, int pivotYType, float pivotYValue) {}\n\n旋转\nRotateAnimation(float fromDegrees, float toDegrees, float pivotX, float pivotY){}\nRotateAnimation(float fromDegrees, float toDegrees, int pivotXType, float pivotXValue,int pivotYType, float pivotYValue) {\n\n位移\nTranslateAnimation(float fromXDelta, float toXDelta, float fromYDelta, float toYDelta) {}\t\t\nTranslateAnimation(int fromXType, float fromXValue, int toXType, float toXValue,int fromYType, float fromYValue, int toYType, float toYValue) {}\n\n透明度\nAlphaAnimation(float fromAlpha, float toAlpha)\n\n动画集 \nAnimationSet animationSet = new AnimationSet(true);\nanimationSet.setAnimationListener(animationListener);\nview.startAnimation(animationSet);\n```\n\n### 属性动画\n\n改变的是对象的实际属性\n\n1.ValueAnimator \n\n``` bash \n\npublic static ValueAnimator ofInt(int... values)  \npublic static ValueAnimator ofFloat(float... values)\n参数类型都是可变参数长参数，所以我们可以传入任何数量的值；\n传进去的值列表，就表示动画时的变化范围；比如ofInt(5,88,55)就表示从数值5变化到数字88再变化到数字55\n\nValueAnimator animator = ValueAnimator.ofInt(0,500);  \nanimator.setDuration(1000);  \n\nanimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {  \n    @Override  \n    public void onAnimationUpdate(ValueAnimator animation) {  \n        int curValue = (int)animation.getAnimatedValue();   \n    }  \n});  \nanimator.start(); \n```\n\n2.ObjectAnimator\n\n``` bash\nObjectAnimator oa=ObjectAnimator.ofFloat(tv, \"alpha\", 0f, 1f); // \"rotation\" , \"translationX\" , \"scaleX\" ...\n\n动画集\nAnimatorSet bouncer = new AnimatorSet();\nbouncer.play(anim1).before(anim2);\nbouncer.play(anim2).with(anim3);\nbouncer.play(anim2).with(anim4)\nbouncer.play(anim5).after(amin2);\nanimatorSet.start();\n```\n\n### ViewPropertyAnimator\n\n如果需要对一个View的多个属性进行动画可以用ViewPropertyAnimator类，该类对多属性动画进行了优化，会合并一些invalidate()来减少刷新视图，该类在3.1中引入\n\n``` bash\nPropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(\"x\", 50f);\nPropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(\"y\", 100f);\nObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();\nmyView.animate().x(50f).y(100f);\n```\n\n### LayoutTransition\n\n在3.0及以后只需要在XML中设置animateLayoutChanges=\"true\"或者在Java代码中添加一个LayoutTransition对象\n\n1.APPEARING：容器中出现一个视图。\n\n2.DISAPPEARING：容器中消失一个视图。\n\n3.CHANGING：布局改变导致某个视图随之改变，例如调整大小，但不包括添加或者移除视图。\n\n4.CHANGE_APPEARING：其他视图的出现导致某个视图改变。\n\n5.CHANGE_DISAPPEARING：其他视图的消失导致某个视图改变。\n\n``` bash\nView mContainer = (LinearLayout) findViewById(R.id.main_container);  \nLayoutTransition transition = new LayoutTransition();  \nmContainer.setLayoutTransition(transition);  \nfindViewById(R.id.main_btn).setOnClickListener(this);  \n  \n//使用翻转进入的动画代替默认动画  \nAnimator appearAnim = ObjectAnimator  \n        .ofFloat(null, \"rotationY\", 90f, 0)  \n        .setDuration(transition.getDuration(LayoutTransition.APPEARING));  \ntransition.setAnimator(LayoutTransition.APPEARING, appearAnim);  \n  \n//使用翻转消失的动画代替默认动画  \nAnimator disappearAnim = ObjectAnimator.ofFloat(null, \"rotationX\", 0, 90f).setDuration( transition.getDuration(LayoutTransition.DISAPPEARING));  \ntransition.setAnimator(LayoutTransition.DISAPPEARING, disappearAnim);  \n  \n//使用滑动动画代替默认布局改变的动画  \n//这个动画会让视图滑动进入并短暂地缩小一半，具有平滑和缩放的效果  \nPropertyValuesHolder pvhSlide = PropertyValuesHolder.ofFloat(\"y\", 0, 1);  \nPropertyValuesHolder pvhScaleY = PropertyValuesHolder.ofFloat(\"scaleY\", 1f, 0.5f, 1f);  \nPropertyValuesHolder pvhScaleX = PropertyValuesHolder.ofFloat(\"scaleX\", 1f, 0.5f, 1f);  \n  \n//这里将上面三个动画综合  \nAnimator changingDisappearAnim = ObjectAnimator.ofPropertyValuesHolder(this, pvhSlide, pvhScaleY, pvhScaleX);  \nchangingDisappearAnim.setDuration(transition.getDuration(LayoutTransition.CHANGE_DISAPPEARING));  \ntransition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING,changingDisappearAnim);  \n```\n\n### Keyframes\n\n可以让我们定义除了开始和结束以外的关键帧。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，\n然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象\n\n``` bash\n//设置btn对象的width属性值使其：开始时 Width=400，动画开始1/4时 Width=200，动画开始1/2时 Width=400，动画开始3/4时 Width=100，动画结束时 Width=500\nKeyframe kf0 = Keyframe.ofInt(0, 400);\nKeyframe kf1 = Keyframe.ofInt(0.25f, 200);\nKeyframe kf2 = Keyframe.ofInt(0.5f, 400);\nKeyframe kf4 = Keyframe.ofInt(0.75f, 100);\nKeyframe kf3 = Keyframe.ofInt(1f, 500);\nPropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(width, kf0, kf1, kf2, kf4, kf3);\nObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn, pvhRotation);\n```\n\n### TimeInterplator\n\nTime interplator定义了属性值变化的方式，如线性均匀改变，开始慢然后逐渐快等。在Property Animation中是TimeInterplator，在View Animation中是Interplator，这两个是一样的，在3.0之前只有Interplator，3.0之后实现代码转移至了TimeInterplator。Interplator继承自TimeInterplator，内部没有任何其他代码。\n\n``` bash\nAccelerateInterpolator　　　　　     加速，开始时慢中间加速\nDecelerateInterpolator　　　 　　   减速，开始时快然后减速\nAccelerateDecelerateInterolator　   先加速后减速，开始结束时慢，中间加速\nAnticipateInterpolator　　　　　　  反向 ，先向相反方向改变一段再加速播放\nAnticipateOvershootInterpolator　   反向加回弹，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值\nBounceInterpolator　　　　　　　  跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100\nCycleIinterpolator　　　　　　　　 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI * input)\nLinearInterpolator　　　　　　　　 线性，线性均匀改变\nOvershottInterpolator　　　　　　  回弹，最后超出目的值然后缓慢改变到目的值\nTimeInterpolator　　　　　　　　   一个接口，允许你自定义interpolator，以上几个都是实现了这个接口\n\n自定义 \npublic class MyInterploator implements TimeInterpolator {  \n    @Override  \n    public float getInterpolation(float input) {  \n        return 1-input;  \n    }  \n}  \n```\n\n### TypeEvalutors\n\n根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值，android提供了以下几个evalutor：\n\nIntEvaluator：属性的值类型为int；\nFloatEvaluator：属性的值类型为float；\nArgbEvaluator：属性的值类型为十六进制颜色值；\nTypeEvaluator：一个接口，可以通过实现该接口自定义Evaluator。\n自定义TypeEvalutor很简单，只需要实现一个方法，如FloatEvalutor的定义：\n\n``` bash\npublic class FloatEvaluator implements TypeEvaluator {\n    public Object evaluate(float fraction, Object startValue, Object endValue) {\n        float startFloat = ((Number) startValue).floatValue();\n        return startFloat + fraction * (((Number) endValue).floatValue() - startFloat);\n    }\n}\n根据动画执行的时间跟应用的Interplator，会计算出一个0~1之间的因子，即evalute函数中的fraction参数，通过上述FloatEvaluator应该很好看出其意思。\n```\n\n","slug":"view-anm","published":1,"updated":"2018-02-12T07:14:10.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gbw001ho4l1l9n3hr27","content":"<h2 id=\"安卓动画简介\"><a href=\"#安卓动画简介\" class=\"headerlink\" title=\"安卓动画简介\"></a>安卓动画简介</h2><p>总的来说，Android动画可以分为两类，最初的传统动画和Android3.0 之后出现的属性动画；<br>传统动画又包括 帧动画（Frame Animation）和补间动画（Tweened Animation）。<br>温馨提示 ： 本文所有动画没有使用xml的实现只介绍代码实现</p>\n<a id=\"more\"></a>\n<h3 id=\"帧动画（Frame-Animation）\"><a href=\"#帧动画（Frame-Animation）\" class=\"headerlink\" title=\"帧动画（Frame Animation）\"></a>帧动画（Frame Animation）</h3><p>他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"utf-8\"</span>?&gt;</div><div class=\"line\">&lt;animation-list xmlns:android=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</div><div class=\"line\">    &lt;item</div><div class=\"line\">        android:drawable=<span class=\"string\">\"@drawable/a_0\"</span></div><div class=\"line\">        android:duration=<span class=\"string\">\"100\"</span> /&gt;</div><div class=\"line\">    &lt;item</div><div class=\"line\">        android:drawable=<span class=\"string\">\"@drawable/a_1\"</span></div><div class=\"line\">        android:duration=<span class=\"string\">\"100\"</span> /&gt;</div><div class=\"line\">    &lt;item</div><div class=\"line\">        android:drawable=<span class=\"string\">\"@drawable/a_2\"</span></div><div class=\"line\">        android:duration=<span class=\"string\">\"100\"</span> /&gt;</div><div class=\"line\">&lt;/animation-list&gt;</div><div class=\"line\"></div><div class=\"line\">ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);</div><div class=\"line\">        animationImg1.setImageResource(R.drawable.frame_anim1);</div><div class=\"line\">        AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();</div><div class=\"line\">        animationDrawable1.start();</div></pre></td></tr></table></figure>\n<h3 id=\"补间动画（Tweened-Animation）\"><a href=\"#补间动画（Tweened-Animation）\" class=\"headerlink\" title=\"补间动画（Tweened Animation）\"></a>补间动画（Tweened Animation）</h3><p>不改变view的实际属性，只改变绘制效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:fillAfter 如果设置为<span class=\"literal\">true</span>，控件动画结束时，将保持动画最后时的状态</div><div class=\"line\">android:fillBefore       如果设置为<span class=\"literal\">true</span>,控件动画结束时，还原到开始动画前的状态</div><div class=\"line\">android:fillEnabled    与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态</div><div class=\"line\">android:repeatCount 重复次数</div><div class=\"line\">android:repeatMode\t重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。</div><div class=\"line\">android:interpolator  设定插值器</div><div class=\"line\"></div><div class=\"line\">缩放</div><div class=\"line\">ScaleAnimation(<span class=\"built_in\">float</span> fromX, <span class=\"built_in\">float</span> toX, <span class=\"built_in\">float</span> fromY, <span class=\"built_in\">float</span> toY,</div><div class=\"line\">            <span class=\"built_in\">float</span> pivotX, <span class=\"built_in\">float</span> pivotY) &#123;&#125;</div><div class=\"line\">ScaleAnimation(<span class=\"built_in\">float</span> fromX, <span class=\"built_in\">float</span> toX, <span class=\"built_in\">float</span> fromY, <span class=\"built_in\">float</span> toY,int pivotXType, <span class=\"built_in\">float</span> pivotXValue, int pivotYType, <span class=\"built_in\">float</span> pivotYValue) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">旋转</div><div class=\"line\">RotateAnimation(<span class=\"built_in\">float</span> fromDegrees, <span class=\"built_in\">float</span> toDegrees, <span class=\"built_in\">float</span> pivotX, <span class=\"built_in\">float</span> pivotY)&#123;&#125;</div><div class=\"line\">RotateAnimation(<span class=\"built_in\">float</span> fromDegrees, <span class=\"built_in\">float</span> toDegrees, int pivotXType, <span class=\"built_in\">float</span> pivotXValue,int pivotYType, <span class=\"built_in\">float</span> pivotYValue) &#123;</div><div class=\"line\"></div><div class=\"line\">位移</div><div class=\"line\">TranslateAnimation(<span class=\"built_in\">float</span> fromXDelta, <span class=\"built_in\">float</span> toXDelta, <span class=\"built_in\">float</span> fromYDelta, <span class=\"built_in\">float</span> toYDelta) &#123;&#125;\t\t</div><div class=\"line\">TranslateAnimation(int fromXType, <span class=\"built_in\">float</span> fromXValue, int toXType, <span class=\"built_in\">float</span> toXValue,int fromYType, <span class=\"built_in\">float</span> fromYValue, int toYType, <span class=\"built_in\">float</span> toYValue) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">透明度</div><div class=\"line\">AlphaAnimation(<span class=\"built_in\">float</span> fromAlpha, <span class=\"built_in\">float</span> toAlpha)</div><div class=\"line\"></div><div class=\"line\">动画集 </div><div class=\"line\">AnimationSet animationSet = new AnimationSet(<span class=\"literal\">true</span>);</div><div class=\"line\">animationSet.setAnimationListener(animationListener);</div><div class=\"line\">view.startAnimation(animationSet);</div></pre></td></tr></table></figure>\n<h3 id=\"属性动画\"><a href=\"#属性动画\" class=\"headerlink\" title=\"属性动画\"></a>属性动画</h3><p>改变的是对象的实际属性</p>\n<p>1.ValueAnimator </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public static ValueAnimator ofInt(int... values)  </div><div class=\"line\">public static ValueAnimator ofFloat(float... values)</div><div class=\"line\">参数类型都是可变参数长参数，所以我们可以传入任何数量的值；</div><div class=\"line\">传进去的值列表，就表示动画时的变化范围；比如ofInt(5,88,55)就表示从数值5变化到数字88再变化到数字55</div><div class=\"line\"></div><div class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(0,500);  </div><div class=\"line\">animator.setDuration(1000);  </div><div class=\"line\"></div><div class=\"line\">animator.addUpdateListener(new ValueAnimator.<span class=\"function\"><span class=\"title\">AnimatorUpdateListener</span></span>() &#123;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onAnimationUpdate(ValueAnimator animation) &#123;  </div><div class=\"line\">        int curValue = (int)animation.getAnimatedValue();   </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;);  </div><div class=\"line\">animator.start();</div></pre></td></tr></table></figure>\n<p>2.ObjectAnimator</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ObjectAnimator oa=ObjectAnimator.ofFloat(tv, <span class=\"string\">\"alpha\"</span>, 0f, 1f); // <span class=\"string\">\"rotation\"</span> , <span class=\"string\">\"translationX\"</span> , <span class=\"string\">\"scaleX\"</span> ...</div><div class=\"line\"></div><div class=\"line\">动画集</div><div class=\"line\">AnimatorSet bouncer = new AnimatorSet();</div><div class=\"line\">bouncer.play(anim1).before(anim2);</div><div class=\"line\">bouncer.play(anim2).with(anim3);</div><div class=\"line\">bouncer.play(anim2).with(anim4)</div><div class=\"line\">bouncer.play(anim5).after(amin2);</div><div class=\"line\">animatorSet.start();</div></pre></td></tr></table></figure>\n<h3 id=\"ViewPropertyAnimator\"><a href=\"#ViewPropertyAnimator\" class=\"headerlink\" title=\"ViewPropertyAnimator\"></a>ViewPropertyAnimator</h3><p>如果需要对一个View的多个属性进行动画可以用ViewPropertyAnimator类，该类对多属性动画进行了优化，会合并一些invalidate()来减少刷新视图，该类在3.1中引入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(<span class=\"string\">\"x\"</span>, 50f);</div><div class=\"line\">PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(<span class=\"string\">\"y\"</span>, 100f);</div><div class=\"line\">ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();</div><div class=\"line\">myView.animate().x(50f).y(100f);</div></pre></td></tr></table></figure>\n<h3 id=\"LayoutTransition\"><a href=\"#LayoutTransition\" class=\"headerlink\" title=\"LayoutTransition\"></a>LayoutTransition</h3><p>在3.0及以后只需要在XML中设置animateLayoutChanges=”true”或者在Java代码中添加一个LayoutTransition对象</p>\n<p>1.APPEARING：容器中出现一个视图。</p>\n<p>2.DISAPPEARING：容器中消失一个视图。</p>\n<p>3.CHANGING：布局改变导致某个视图随之改变，例如调整大小，但不包括添加或者移除视图。</p>\n<p>4.CHANGE_APPEARING：其他视图的出现导致某个视图改变。</p>\n<p>5.CHANGE_DISAPPEARING：其他视图的消失导致某个视图改变。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">View mContainer = (LinearLayout) findViewById(R.id.main_container);  </div><div class=\"line\">LayoutTransition transition = new LayoutTransition();  </div><div class=\"line\">mContainer.setLayoutTransition(transition);  </div><div class=\"line\">findViewById(R.id.main_btn).setOnClickListener(this);  </div><div class=\"line\">  </div><div class=\"line\">//使用翻转进入的动画代替默认动画  </div><div class=\"line\">Animator appearAnim = ObjectAnimator  </div><div class=\"line\">        .ofFloat(null, <span class=\"string\">\"rotationY\"</span>, 90f, 0)  </div><div class=\"line\">        .setDuration(transition.getDuration(LayoutTransition.APPEARING));  </div><div class=\"line\">transition.setAnimator(LayoutTransition.APPEARING, appearAnim);  </div><div class=\"line\">  </div><div class=\"line\">//使用翻转消失的动画代替默认动画  </div><div class=\"line\">Animator disappearAnim = ObjectAnimator.ofFloat(null, <span class=\"string\">\"rotationX\"</span>, 0, 90f).setDuration( transition.getDuration(LayoutTransition.DISAPPEARING));  </div><div class=\"line\">transition.setAnimator(LayoutTransition.DISAPPEARING, disappearAnim);  </div><div class=\"line\">  </div><div class=\"line\">//使用滑动动画代替默认布局改变的动画  </div><div class=\"line\">//这个动画会让视图滑动进入并短暂地缩小一半，具有平滑和缩放的效果  </div><div class=\"line\">PropertyValuesHolder pvhSlide = PropertyValuesHolder.ofFloat(<span class=\"string\">\"y\"</span>, 0, 1);  </div><div class=\"line\">PropertyValuesHolder pvhScaleY = PropertyValuesHolder.ofFloat(<span class=\"string\">\"scaleY\"</span>, 1f, 0.5f, 1f);  </div><div class=\"line\">PropertyValuesHolder pvhScaleX = PropertyValuesHolder.ofFloat(<span class=\"string\">\"scaleX\"</span>, 1f, 0.5f, 1f);  </div><div class=\"line\">  </div><div class=\"line\">//这里将上面三个动画综合  </div><div class=\"line\">Animator changingDisappearAnim = ObjectAnimator.ofPropertyValuesHolder(this, pvhSlide, pvhScaleY, pvhScaleX);  </div><div class=\"line\">changingDisappearAnim.setDuration(transition.getDuration(LayoutTransition.CHANGE_DISAPPEARING));  </div><div class=\"line\">transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING,changingDisappearAnim);</div></pre></td></tr></table></figure>\n<h3 id=\"Keyframes\"><a href=\"#Keyframes\" class=\"headerlink\" title=\"Keyframes\"></a>Keyframes</h3><p>可以让我们定义除了开始和结束以外的关键帧。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，<br>然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//设置btn对象的width属性值使其：开始时 Width=400，动画开始1/4时 Width=200，动画开始1/2时 Width=400，动画开始3/4时 Width=100，动画结束时 Width=500</div><div class=\"line\">Keyframe kf0 = Keyframe.ofInt(0, 400);</div><div class=\"line\">Keyframe kf1 = Keyframe.ofInt(0.25f, 200);</div><div class=\"line\">Keyframe kf2 = Keyframe.ofInt(0.5f, 400);</div><div class=\"line\">Keyframe kf4 = Keyframe.ofInt(0.75f, 100);</div><div class=\"line\">Keyframe kf3 = Keyframe.ofInt(1f, 500);</div><div class=\"line\">PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(width, kf0, kf1, kf2, kf4, kf3);</div><div class=\"line\">ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn, pvhRotation);</div></pre></td></tr></table></figure>\n<h3 id=\"TimeInterplator\"><a href=\"#TimeInterplator\" class=\"headerlink\" title=\"TimeInterplator\"></a>TimeInterplator</h3><p>Time interplator定义了属性值变化的方式，如线性均匀改变，开始慢然后逐渐快等。在Property Animation中是TimeInterplator，在View Animation中是Interplator，这两个是一样的，在3.0之前只有Interplator，3.0之后实现代码转移至了TimeInterplator。Interplator继承自TimeInterplator，内部没有任何其他代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">AccelerateInterpolator　　　　　     加速，开始时慢中间加速</div><div class=\"line\">DecelerateInterpolator　　　 　　   减速，开始时快然后减速</div><div class=\"line\">AccelerateDecelerateInterolator　   先加速后减速，开始结束时慢，中间加速</div><div class=\"line\">AnticipateInterpolator　　　　　　  反向 ，先向相反方向改变一段再加速播放</div><div class=\"line\">AnticipateOvershootInterpolator　   反向加回弹，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值</div><div class=\"line\">BounceInterpolator　　　　　　　  跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100</div><div class=\"line\">CycleIinterpolator　　　　　　　　 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI * input)</div><div class=\"line\">LinearInterpolator　　　　　　　　 线性，线性均匀改变</div><div class=\"line\">OvershottInterpolator　　　　　　  回弹，最后超出目的值然后缓慢改变到目的值</div><div class=\"line\">TimeInterpolator　　　　　　　　   一个接口，允许你自定义interpolator，以上几个都是实现了这个接口</div><div class=\"line\"></div><div class=\"line\">自定义 </div><div class=\"line\">public class MyInterploator implements TimeInterpolator &#123;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public <span class=\"built_in\">float</span> getInterpolation(<span class=\"built_in\">float</span> input) &#123;  </div><div class=\"line\">        <span class=\"built_in\">return</span> 1-input;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"TypeEvalutors\"><a href=\"#TypeEvalutors\" class=\"headerlink\" title=\"TypeEvalutors\"></a>TypeEvalutors</h3><p>根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值，android提供了以下几个evalutor：</p>\n<p>IntEvaluator：属性的值类型为int；<br>FloatEvaluator：属性的值类型为float；<br>ArgbEvaluator：属性的值类型为十六进制颜色值；<br>TypeEvaluator：一个接口，可以通过实现该接口自定义Evaluator。<br>自定义TypeEvalutor很简单，只需要实现一个方法，如FloatEvalutor的定义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class FloatEvaluator implements TypeEvaluator &#123;</div><div class=\"line\">    public Object evaluate(<span class=\"built_in\">float</span> fraction, Object startValue, Object endValue) &#123;</div><div class=\"line\">        <span class=\"built_in\">float</span> startFloat = ((Number) startValue).floatValue();</div><div class=\"line\">        <span class=\"built_in\">return</span> startFloat + fraction * (((Number) endValue).floatValue() - startFloat);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">根据动画执行的时间跟应用的Interplator，会计算出一个0~1之间的因子，即evalute函数中的fraction参数，通过上述FloatEvaluator应该很好看出其意思。</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"安卓动画简介\"><a href=\"#安卓动画简介\" class=\"headerlink\" title=\"安卓动画简介\"></a>安卓动画简介</h2><p>总的来说，Android动画可以分为两类，最初的传统动画和Android3.0 之后出现的属性动画；<br>传统动画又包括 帧动画（Frame Animation）和补间动画（Tweened Animation）。<br>温馨提示 ： 本文所有动画没有使用xml的实现只介绍代码实现</p>","more":"<h3 id=\"帧动画（Frame-Animation）\"><a href=\"#帧动画（Frame-Animation）\" class=\"headerlink\" title=\"帧动画（Frame Animation）\"></a>帧动画（Frame Animation）</h3><p>他的原理就是将一张张单独的图片连贯的进行播放，从而在视觉上产生一种动画的效果；有点类似于某些软件制作gif动画的方式。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=<span class=\"string\">\"1.0\"</span> encoding=<span class=\"string\">\"utf-8\"</span>?&gt;</div><div class=\"line\">&lt;animation-list xmlns:android=<span class=\"string\">\"http://schemas.android.com/apk/res/android\"</span>&gt;</div><div class=\"line\">    &lt;item</div><div class=\"line\">        android:drawable=<span class=\"string\">\"@drawable/a_0\"</span></div><div class=\"line\">        android:duration=<span class=\"string\">\"100\"</span> /&gt;</div><div class=\"line\">    &lt;item</div><div class=\"line\">        android:drawable=<span class=\"string\">\"@drawable/a_1\"</span></div><div class=\"line\">        android:duration=<span class=\"string\">\"100\"</span> /&gt;</div><div class=\"line\">    &lt;item</div><div class=\"line\">        android:drawable=<span class=\"string\">\"@drawable/a_2\"</span></div><div class=\"line\">        android:duration=<span class=\"string\">\"100\"</span> /&gt;</div><div class=\"line\">&lt;/animation-list&gt;</div><div class=\"line\"></div><div class=\"line\">ImageView animationImg1 = (ImageView) findViewById(R.id.animation1);</div><div class=\"line\">        animationImg1.setImageResource(R.drawable.frame_anim1);</div><div class=\"line\">        AnimationDrawable animationDrawable1 = (AnimationDrawable) animationImg1.getDrawable();</div><div class=\"line\">        animationDrawable1.start();</div></pre></td></tr></table></figure>\n<h3 id=\"补间动画（Tweened-Animation）\"><a href=\"#补间动画（Tweened-Animation）\" class=\"headerlink\" title=\"补间动画（Tweened Animation）\"></a>补间动画（Tweened Animation）</h3><p>不改变view的实际属性，只改变绘制效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">android:fillAfter 如果设置为<span class=\"literal\">true</span>，控件动画结束时，将保持动画最后时的状态</div><div class=\"line\">android:fillBefore       如果设置为<span class=\"literal\">true</span>,控件动画结束时，还原到开始动画前的状态</div><div class=\"line\">android:fillEnabled    与android:fillBefore 效果相同，都是在动画结束时，将控件还原到初始化状态</div><div class=\"line\">android:repeatCount 重复次数</div><div class=\"line\">android:repeatMode\t重复类型，有reverse和restart两个值，reverse表示倒序回放，restart表示重新放一遍，必须与repeatCount一起使用才能看到效果。因为这里的意义是重复的类型，即回放时的动作。</div><div class=\"line\">android:interpolator  设定插值器</div><div class=\"line\"></div><div class=\"line\">缩放</div><div class=\"line\">ScaleAnimation(<span class=\"built_in\">float</span> fromX, <span class=\"built_in\">float</span> toX, <span class=\"built_in\">float</span> fromY, <span class=\"built_in\">float</span> toY,</div><div class=\"line\">            <span class=\"built_in\">float</span> pivotX, <span class=\"built_in\">float</span> pivotY) &#123;&#125;</div><div class=\"line\">ScaleAnimation(<span class=\"built_in\">float</span> fromX, <span class=\"built_in\">float</span> toX, <span class=\"built_in\">float</span> fromY, <span class=\"built_in\">float</span> toY,int pivotXType, <span class=\"built_in\">float</span> pivotXValue, int pivotYType, <span class=\"built_in\">float</span> pivotYValue) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">旋转</div><div class=\"line\">RotateAnimation(<span class=\"built_in\">float</span> fromDegrees, <span class=\"built_in\">float</span> toDegrees, <span class=\"built_in\">float</span> pivotX, <span class=\"built_in\">float</span> pivotY)&#123;&#125;</div><div class=\"line\">RotateAnimation(<span class=\"built_in\">float</span> fromDegrees, <span class=\"built_in\">float</span> toDegrees, int pivotXType, <span class=\"built_in\">float</span> pivotXValue,int pivotYType, <span class=\"built_in\">float</span> pivotYValue) &#123;</div><div class=\"line\"></div><div class=\"line\">位移</div><div class=\"line\">TranslateAnimation(<span class=\"built_in\">float</span> fromXDelta, <span class=\"built_in\">float</span> toXDelta, <span class=\"built_in\">float</span> fromYDelta, <span class=\"built_in\">float</span> toYDelta) &#123;&#125;\t\t</div><div class=\"line\">TranslateAnimation(int fromXType, <span class=\"built_in\">float</span> fromXValue, int toXType, <span class=\"built_in\">float</span> toXValue,int fromYType, <span class=\"built_in\">float</span> fromYValue, int toYType, <span class=\"built_in\">float</span> toYValue) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">透明度</div><div class=\"line\">AlphaAnimation(<span class=\"built_in\">float</span> fromAlpha, <span class=\"built_in\">float</span> toAlpha)</div><div class=\"line\"></div><div class=\"line\">动画集 </div><div class=\"line\">AnimationSet animationSet = new AnimationSet(<span class=\"literal\">true</span>);</div><div class=\"line\">animationSet.setAnimationListener(animationListener);</div><div class=\"line\">view.startAnimation(animationSet);</div></pre></td></tr></table></figure>\n<h3 id=\"属性动画\"><a href=\"#属性动画\" class=\"headerlink\" title=\"属性动画\"></a>属性动画</h3><p>改变的是对象的实际属性</p>\n<p>1.ValueAnimator </p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">public static ValueAnimator ofInt(int... values)  </div><div class=\"line\">public static ValueAnimator ofFloat(float... values)</div><div class=\"line\">参数类型都是可变参数长参数，所以我们可以传入任何数量的值；</div><div class=\"line\">传进去的值列表，就表示动画时的变化范围；比如ofInt(5,88,55)就表示从数值5变化到数字88再变化到数字55</div><div class=\"line\"></div><div class=\"line\">ValueAnimator animator = ValueAnimator.ofInt(0,500);  </div><div class=\"line\">animator.setDuration(1000);  </div><div class=\"line\"></div><div class=\"line\">animator.addUpdateListener(new ValueAnimator.<span class=\"function\"><span class=\"title\">AnimatorUpdateListener</span></span>() &#123;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onAnimationUpdate(ValueAnimator animation) &#123;  </div><div class=\"line\">        int curValue = (int)animation.getAnimatedValue();   </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;);  </div><div class=\"line\">animator.start();</div></pre></td></tr></table></figure>\n<p>2.ObjectAnimator</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ObjectAnimator oa=ObjectAnimator.ofFloat(tv, <span class=\"string\">\"alpha\"</span>, 0f, 1f); // <span class=\"string\">\"rotation\"</span> , <span class=\"string\">\"translationX\"</span> , <span class=\"string\">\"scaleX\"</span> ...</div><div class=\"line\"></div><div class=\"line\">动画集</div><div class=\"line\">AnimatorSet bouncer = new AnimatorSet();</div><div class=\"line\">bouncer.play(anim1).before(anim2);</div><div class=\"line\">bouncer.play(anim2).with(anim3);</div><div class=\"line\">bouncer.play(anim2).with(anim4)</div><div class=\"line\">bouncer.play(anim5).after(amin2);</div><div class=\"line\">animatorSet.start();</div></pre></td></tr></table></figure>\n<h3 id=\"ViewPropertyAnimator\"><a href=\"#ViewPropertyAnimator\" class=\"headerlink\" title=\"ViewPropertyAnimator\"></a>ViewPropertyAnimator</h3><p>如果需要对一个View的多个属性进行动画可以用ViewPropertyAnimator类，该类对多属性动画进行了优化，会合并一些invalidate()来减少刷新视图，该类在3.1中引入</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">PropertyValuesHolder pvhX = PropertyValuesHolder.ofFloat(<span class=\"string\">\"x\"</span>, 50f);</div><div class=\"line\">PropertyValuesHolder pvhY = PropertyValuesHolder.ofFloat(<span class=\"string\">\"y\"</span>, 100f);</div><div class=\"line\">ObjectAnimator.ofPropertyValuesHolder(myView, pvhX, pvyY).start();</div><div class=\"line\">myView.animate().x(50f).y(100f);</div></pre></td></tr></table></figure>\n<h3 id=\"LayoutTransition\"><a href=\"#LayoutTransition\" class=\"headerlink\" title=\"LayoutTransition\"></a>LayoutTransition</h3><p>在3.0及以后只需要在XML中设置animateLayoutChanges=”true”或者在Java代码中添加一个LayoutTransition对象</p>\n<p>1.APPEARING：容器中出现一个视图。</p>\n<p>2.DISAPPEARING：容器中消失一个视图。</p>\n<p>3.CHANGING：布局改变导致某个视图随之改变，例如调整大小，但不包括添加或者移除视图。</p>\n<p>4.CHANGE_APPEARING：其他视图的出现导致某个视图改变。</p>\n<p>5.CHANGE_DISAPPEARING：其他视图的消失导致某个视图改变。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">View mContainer = (LinearLayout) findViewById(R.id.main_container);  </div><div class=\"line\">LayoutTransition transition = new LayoutTransition();  </div><div class=\"line\">mContainer.setLayoutTransition(transition);  </div><div class=\"line\">findViewById(R.id.main_btn).setOnClickListener(this);  </div><div class=\"line\">  </div><div class=\"line\">//使用翻转进入的动画代替默认动画  </div><div class=\"line\">Animator appearAnim = ObjectAnimator  </div><div class=\"line\">        .ofFloat(null, <span class=\"string\">\"rotationY\"</span>, 90f, 0)  </div><div class=\"line\">        .setDuration(transition.getDuration(LayoutTransition.APPEARING));  </div><div class=\"line\">transition.setAnimator(LayoutTransition.APPEARING, appearAnim);  </div><div class=\"line\">  </div><div class=\"line\">//使用翻转消失的动画代替默认动画  </div><div class=\"line\">Animator disappearAnim = ObjectAnimator.ofFloat(null, <span class=\"string\">\"rotationX\"</span>, 0, 90f).setDuration( transition.getDuration(LayoutTransition.DISAPPEARING));  </div><div class=\"line\">transition.setAnimator(LayoutTransition.DISAPPEARING, disappearAnim);  </div><div class=\"line\">  </div><div class=\"line\">//使用滑动动画代替默认布局改变的动画  </div><div class=\"line\">//这个动画会让视图滑动进入并短暂地缩小一半，具有平滑和缩放的效果  </div><div class=\"line\">PropertyValuesHolder pvhSlide = PropertyValuesHolder.ofFloat(<span class=\"string\">\"y\"</span>, 0, 1);  </div><div class=\"line\">PropertyValuesHolder pvhScaleY = PropertyValuesHolder.ofFloat(<span class=\"string\">\"scaleY\"</span>, 1f, 0.5f, 1f);  </div><div class=\"line\">PropertyValuesHolder pvhScaleX = PropertyValuesHolder.ofFloat(<span class=\"string\">\"scaleX\"</span>, 1f, 0.5f, 1f);  </div><div class=\"line\">  </div><div class=\"line\">//这里将上面三个动画综合  </div><div class=\"line\">Animator changingDisappearAnim = ObjectAnimator.ofPropertyValuesHolder(this, pvhSlide, pvhScaleY, pvhScaleX);  </div><div class=\"line\">changingDisappearAnim.setDuration(transition.getDuration(LayoutTransition.CHANGE_DISAPPEARING));  </div><div class=\"line\">transition.setAnimator(LayoutTransition.CHANGE_DISAPPEARING,changingDisappearAnim);</div></pre></td></tr></table></figure>\n<h3 id=\"Keyframes\"><a href=\"#Keyframes\" class=\"headerlink\" title=\"Keyframes\"></a>Keyframes</h3><p>可以让我们定义除了开始和结束以外的关键帧。KeyFrame是抽象类，要通过ofInt(),ofFloat(),ofObject()获得适当的KeyFrame，<br>然后通过PropertyValuesHolder.ofKeyframe获得PropertyValuesHolder对象</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">//设置btn对象的width属性值使其：开始时 Width=400，动画开始1/4时 Width=200，动画开始1/2时 Width=400，动画开始3/4时 Width=100，动画结束时 Width=500</div><div class=\"line\">Keyframe kf0 = Keyframe.ofInt(0, 400);</div><div class=\"line\">Keyframe kf1 = Keyframe.ofInt(0.25f, 200);</div><div class=\"line\">Keyframe kf2 = Keyframe.ofInt(0.5f, 400);</div><div class=\"line\">Keyframe kf4 = Keyframe.ofInt(0.75f, 100);</div><div class=\"line\">Keyframe kf3 = Keyframe.ofInt(1f, 500);</div><div class=\"line\">PropertyValuesHolder pvhRotation = PropertyValuesHolder.ofKeyframe(width, kf0, kf1, kf2, kf4, kf3);</div><div class=\"line\">ObjectAnimator rotationAnim = ObjectAnimator.ofPropertyValuesHolder(btn, pvhRotation);</div></pre></td></tr></table></figure>\n<h3 id=\"TimeInterplator\"><a href=\"#TimeInterplator\" class=\"headerlink\" title=\"TimeInterplator\"></a>TimeInterplator</h3><p>Time interplator定义了属性值变化的方式，如线性均匀改变，开始慢然后逐渐快等。在Property Animation中是TimeInterplator，在View Animation中是Interplator，这两个是一样的，在3.0之前只有Interplator，3.0之后实现代码转移至了TimeInterplator。Interplator继承自TimeInterplator，内部没有任何其他代码。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">AccelerateInterpolator　　　　　     加速，开始时慢中间加速</div><div class=\"line\">DecelerateInterpolator　　　 　　   减速，开始时快然后减速</div><div class=\"line\">AccelerateDecelerateInterolator　   先加速后减速，开始结束时慢，中间加速</div><div class=\"line\">AnticipateInterpolator　　　　　　  反向 ，先向相反方向改变一段再加速播放</div><div class=\"line\">AnticipateOvershootInterpolator　   反向加回弹，先向相反方向改变，再加速播放，会超出目的值然后缓慢移动至目的值</div><div class=\"line\">BounceInterpolator　　　　　　　  跳跃，快到目的值时值会跳跃，如目的值100，后面的值可能依次为85，77，70，80，90，100</div><div class=\"line\">CycleIinterpolator　　　　　　　　 循环，动画循环一定次数，值的改变为一正弦函数：Math.sin(2 * mCycles * Math.PI * input)</div><div class=\"line\">LinearInterpolator　　　　　　　　 线性，线性均匀改变</div><div class=\"line\">OvershottInterpolator　　　　　　  回弹，最后超出目的值然后缓慢改变到目的值</div><div class=\"line\">TimeInterpolator　　　　　　　　   一个接口，允许你自定义interpolator，以上几个都是实现了这个接口</div><div class=\"line\"></div><div class=\"line\">自定义 </div><div class=\"line\">public class MyInterploator implements TimeInterpolator &#123;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public <span class=\"built_in\">float</span> getInterpolation(<span class=\"built_in\">float</span> input) &#123;  </div><div class=\"line\">        <span class=\"built_in\">return</span> 1-input;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"TypeEvalutors\"><a href=\"#TypeEvalutors\" class=\"headerlink\" title=\"TypeEvalutors\"></a>TypeEvalutors</h3><p>根据属性的开始、结束值与TimeInterpolation计算出的因子计算出当前时间的属性值，android提供了以下几个evalutor：</p>\n<p>IntEvaluator：属性的值类型为int；<br>FloatEvaluator：属性的值类型为float；<br>ArgbEvaluator：属性的值类型为十六进制颜色值；<br>TypeEvaluator：一个接口，可以通过实现该接口自定义Evaluator。<br>自定义TypeEvalutor很简单，只需要实现一个方法，如FloatEvalutor的定义：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class FloatEvaluator implements TypeEvaluator &#123;</div><div class=\"line\">    public Object evaluate(<span class=\"built_in\">float</span> fraction, Object startValue, Object endValue) &#123;</div><div class=\"line\">        <span class=\"built_in\">float</span> startFloat = ((Number) startValue).floatValue();</div><div class=\"line\">        <span class=\"built_in\">return</span> startFloat + fraction * (((Number) endValue).floatValue() - startFloat);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">根据动画执行的时间跟应用的Interplator，会计算出一个0~1之间的因子，即evalute函数中的fraction参数，通过上述FloatEvaluator应该很好看出其意思。</div></pre></td></tr></table></figure>"},{"title":"view_move","date":"2017-12-12T03:54:11.000Z","_content":"\n## 浅谈view移动的几种方式\n\n### 通过改变布局参数来实现View的滑动\n\n会影响四个位置的值\n\n``` bash\nMarginLayoutParams params = (MarginLayoutParams) mButton.getLayoutParams();\nparams.leftMargin += 520;\nmButton.requestLayout();\n```\n\n<!-- more -->\n\n### 使用scrollTo/scrollBy实现View的滑动\n\n实际上，调用scrollBy/scrollTo方法只能实现View的内容的滚动，而View的四个位置参数(l,t,r,b)是保持不变的(listview ,recyclerview等)\n向右滚动时mScrollX负的，向左滚动时mScrollX是正的。同理，向下滚动时，mScrollY是负的，向上滚动时，mScrollY是正的\n\n点击事件还是在原位置\n``` bash\n/** \n   * Set the scrolled position of your view. This will cause a call to \n\n   * {@link #onScrollChanged(int, int, int, int)} and the view will be \n\n   * invalidated. \n\n   * @param x the x position to scroll to \n\n   * @param y the y position to scroll to \n\n   */  \npublic void scrollTo(int x, int y) {  \n      if (mScrollX != x || mScrollY != y) {  \n          int oldX = mScrollX;  \n          int oldY = mScrollY;  \n          mScrollX = x;  \n          mScrollY = y;  \n          onScrollChanged(mScrollX, mScrollY, oldX, oldY);  \n          if (!awakenScrollBars()) {  \n              invalidate();  \n          }  \n      }  \n}  \n\n/** \n    * Move the scrolled position of your view. This will cause a call to \n    * {@link #onScrollChanged(int, int, int, int)} and the view will be \n    * invalidated. \n    * @param x the amount of pixels to scroll by horizontally \n    * @param y the amount of pixels to scroll by vertically \n*/  \npublic void scrollBy(int x, int y) {  \n      scrollTo(mScrollX + x, mScrollY + y);  \n}\n\n通过以上代码的33~35行我们可以看到，scrollBy方法内部也是调用了scrollTo方法来实现。\n以上源码中我们注意到了mScrollX和mScrollY成员变量，前者是View的左边缘减去View的内容的左边缘，后者是View的上边缘减去View的内容的上边缘\n```\n\n### 使用Scroller来实现弹性滑动\n\nScroller 实现弹性滑动的原理：invaldate方法会导致View的draw方法被调用，而draw会调用computeScroll方法，因此重写了computeScroll方法，\n而computeScrollOffset方法会根据时间的流逝动态的计算出很小的一段时间应该滑动多少距离。也就是把一次滑动拆分成无数次小距离滑动从而实现“弹性滑动”\n所以必须自己写个view重载computeScroll方法\n``` bash\nScroller scroller = new Scroller(mContext);\n\nprivate void smoothScrollTo(int dstX, int dstY) {\n    int scrollX = getScrollX();\n    int delta = dstX - scrollX;\n    scroller.startScroll(scrollX, 0, delta, 0, 1000);\n    invalidate(); // 必须调用invalidate()才,否则不会调用computeScroll()方法。看不到滚动效果 \n}\n\n@Override\npublic void computeScroll() {\n    if (scroller.computeScrollOffset()) {\n        scrollTo(scroller.getCurrX(), scroller.getCurY());\n        postInvalidate(); //一定要调用  \n    }\n}\n\n// startScroll 的源码\npublic void startScroll(int startX, int startY, int dx, int dy, int duration) {  \n    mMode = SCROLL_MODE;  \n    mFinished = false;  \n    mDuration = duration;  \n    mStartTime = AnimationUtils.currentAnimationTimeMillis();  \n    mStartX = startX;  \n    mStartY = startY;  \n    mFinalX = startX + dx;  \n    mFinalY = startY + dy;  \n    mDeltaX = dx;  \n    mDeltaY = dy;  \n    mDurationReciprocal = 1.0f / (float) mDuration;  \n    \n    mViscousFluidScale = 8.0f;  \n   \n    mViscousFluidNormalize = 1.0f;  \n    mViscousFluidNormalize = 1.0f / viscousFluid(1.0f);  \n}\n\n从以上的源码我们可以看到，startScroll方法中并没有进行实际的滚动操作，而是把startX、startY、deltaX、deltaY等参数都保存了下来。\n我们看到第7行调用了invalidate方法，这个方法会请求重绘View，这会导致View的draw的方法被调用，draw的方法内部会调用computeScroll方法。\n我们来看看第13行，调用了scrollTo方法，并传入mScroller.getCurrX()和mScroller.getCurrY()方法作为参数。这两个参数是在第12行调用的computeScrollOffset方法中设置的，我们来看看这个方法中设置这两个参数的相关代码\npublic boolean computeScrollOffset() {\n    ...\n    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);\n    if (timePassed < mDuration) {\n        switch (mMode) {\n            case SCROLL_MODE:\n                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);\n                mCurrX = mStartX + Math.round(x * mDeltaX);\n                mCurrY = mStartY + Math.rounc(y * mDeltaY);\n                break;\n        ...\n        }\n    }\n    return true;\n}\n```\n\n### layout() and offsetTopAndBottom/offsetLeftAndRight\n\n主要是通过坐标位置的改变产生移动效果\n\n``` bash\n layout(getLeft() + 5,getTop() + 5,getRight() + 5,getBottom() + 5);\n\t\t\n//  offsetLeftAndRight(5); 作用同上\n//  offsetTopAndBottom(5);\n```\n\n### setTranslationX/Y\n\n这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变 ，点击事件的位置会变\nObjectAnimator 实际上也是通过它实现\n\n``` bash\n /**\n     * Sets the horizontal location of this view relative to its {@link #getLeft() left} position.\n     * This effectively positions the object post-layout, in addition to wherever the object's\n     * layout placed it.\n     *\n     * @param translationX The horizontal position of this view relative to its left position,\n     * in pixels.\n     *\n     * @attr ref android.R.styleable#View_translationX\n     */\n    public void setTranslationX(float translationX) {\n        if (translationX != getTranslationX()) {\n            invalidateViewProperty(true, false);\n            mRenderNode.setTranslationX(translationX);\n            invalidateViewProperty(false, true);\n\n            invalidateParentIfNeededAndWasQuickRejected();\n            notifySubtreeAccessibilityStateChangedIfNeeded();\n        }\n    }\n\t\n从源码可以看出，它的参数不是一个相对位移，而是绝对的偏移值，所以设置多少次都不会叠加\n```\n\n\n\n","source":"_posts/view-move.md","raw":"---\ntitle: view_move\ndate: 2017-12-12 11:54:11\ncategories: android\ntags: view\n---\n\n## 浅谈view移动的几种方式\n\n### 通过改变布局参数来实现View的滑动\n\n会影响四个位置的值\n\n``` bash\nMarginLayoutParams params = (MarginLayoutParams) mButton.getLayoutParams();\nparams.leftMargin += 520;\nmButton.requestLayout();\n```\n\n<!-- more -->\n\n### 使用scrollTo/scrollBy实现View的滑动\n\n实际上，调用scrollBy/scrollTo方法只能实现View的内容的滚动，而View的四个位置参数(l,t,r,b)是保持不变的(listview ,recyclerview等)\n向右滚动时mScrollX负的，向左滚动时mScrollX是正的。同理，向下滚动时，mScrollY是负的，向上滚动时，mScrollY是正的\n\n点击事件还是在原位置\n``` bash\n/** \n   * Set the scrolled position of your view. This will cause a call to \n\n   * {@link #onScrollChanged(int, int, int, int)} and the view will be \n\n   * invalidated. \n\n   * @param x the x position to scroll to \n\n   * @param y the y position to scroll to \n\n   */  \npublic void scrollTo(int x, int y) {  \n      if (mScrollX != x || mScrollY != y) {  \n          int oldX = mScrollX;  \n          int oldY = mScrollY;  \n          mScrollX = x;  \n          mScrollY = y;  \n          onScrollChanged(mScrollX, mScrollY, oldX, oldY);  \n          if (!awakenScrollBars()) {  \n              invalidate();  \n          }  \n      }  \n}  \n\n/** \n    * Move the scrolled position of your view. This will cause a call to \n    * {@link #onScrollChanged(int, int, int, int)} and the view will be \n    * invalidated. \n    * @param x the amount of pixels to scroll by horizontally \n    * @param y the amount of pixels to scroll by vertically \n*/  \npublic void scrollBy(int x, int y) {  \n      scrollTo(mScrollX + x, mScrollY + y);  \n}\n\n通过以上代码的33~35行我们可以看到，scrollBy方法内部也是调用了scrollTo方法来实现。\n以上源码中我们注意到了mScrollX和mScrollY成员变量，前者是View的左边缘减去View的内容的左边缘，后者是View的上边缘减去View的内容的上边缘\n```\n\n### 使用Scroller来实现弹性滑动\n\nScroller 实现弹性滑动的原理：invaldate方法会导致View的draw方法被调用，而draw会调用computeScroll方法，因此重写了computeScroll方法，\n而computeScrollOffset方法会根据时间的流逝动态的计算出很小的一段时间应该滑动多少距离。也就是把一次滑动拆分成无数次小距离滑动从而实现“弹性滑动”\n所以必须自己写个view重载computeScroll方法\n``` bash\nScroller scroller = new Scroller(mContext);\n\nprivate void smoothScrollTo(int dstX, int dstY) {\n    int scrollX = getScrollX();\n    int delta = dstX - scrollX;\n    scroller.startScroll(scrollX, 0, delta, 0, 1000);\n    invalidate(); // 必须调用invalidate()才,否则不会调用computeScroll()方法。看不到滚动效果 \n}\n\n@Override\npublic void computeScroll() {\n    if (scroller.computeScrollOffset()) {\n        scrollTo(scroller.getCurrX(), scroller.getCurY());\n        postInvalidate(); //一定要调用  \n    }\n}\n\n// startScroll 的源码\npublic void startScroll(int startX, int startY, int dx, int dy, int duration) {  \n    mMode = SCROLL_MODE;  \n    mFinished = false;  \n    mDuration = duration;  \n    mStartTime = AnimationUtils.currentAnimationTimeMillis();  \n    mStartX = startX;  \n    mStartY = startY;  \n    mFinalX = startX + dx;  \n    mFinalY = startY + dy;  \n    mDeltaX = dx;  \n    mDeltaY = dy;  \n    mDurationReciprocal = 1.0f / (float) mDuration;  \n    \n    mViscousFluidScale = 8.0f;  \n   \n    mViscousFluidNormalize = 1.0f;  \n    mViscousFluidNormalize = 1.0f / viscousFluid(1.0f);  \n}\n\n从以上的源码我们可以看到，startScroll方法中并没有进行实际的滚动操作，而是把startX、startY、deltaX、deltaY等参数都保存了下来。\n我们看到第7行调用了invalidate方法，这个方法会请求重绘View，这会导致View的draw的方法被调用，draw的方法内部会调用computeScroll方法。\n我们来看看第13行，调用了scrollTo方法，并传入mScroller.getCurrX()和mScroller.getCurrY()方法作为参数。这两个参数是在第12行调用的computeScrollOffset方法中设置的，我们来看看这个方法中设置这两个参数的相关代码\npublic boolean computeScrollOffset() {\n    ...\n    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);\n    if (timePassed < mDuration) {\n        switch (mMode) {\n            case SCROLL_MODE:\n                final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);\n                mCurrX = mStartX + Math.round(x * mDeltaX);\n                mCurrY = mStartY + Math.rounc(y * mDeltaY);\n                break;\n        ...\n        }\n    }\n    return true;\n}\n```\n\n### layout() and offsetTopAndBottom/offsetLeftAndRight\n\n主要是通过坐标位置的改变产生移动效果\n\n``` bash\n layout(getLeft() + 5,getTop() + 5,getRight() + 5,getBottom() + 5);\n\t\t\n//  offsetLeftAndRight(5); 作用同上\n//  offsetTopAndBottom(5);\n```\n\n### setTranslationX/Y\n\n这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变 ，点击事件的位置会变\nObjectAnimator 实际上也是通过它实现\n\n``` bash\n /**\n     * Sets the horizontal location of this view relative to its {@link #getLeft() left} position.\n     * This effectively positions the object post-layout, in addition to wherever the object's\n     * layout placed it.\n     *\n     * @param translationX The horizontal position of this view relative to its left position,\n     * in pixels.\n     *\n     * @attr ref android.R.styleable#View_translationX\n     */\n    public void setTranslationX(float translationX) {\n        if (translationX != getTranslationX()) {\n            invalidateViewProperty(true, false);\n            mRenderNode.setTranslationX(translationX);\n            invalidateViewProperty(false, true);\n\n            invalidateParentIfNeededAndWasQuickRejected();\n            notifySubtreeAccessibilityStateChangedIfNeeded();\n        }\n    }\n\t\n从源码可以看出，它的参数不是一个相对位移，而是绝对的偏移值，所以设置多少次都不会叠加\n```\n\n\n\n","slug":"view-move","published":1,"updated":"2018-02-12T07:36:21.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gby001jo4l1qytx9axk","content":"<h2 id=\"浅谈view移动的几种方式\"><a href=\"#浅谈view移动的几种方式\" class=\"headerlink\" title=\"浅谈view移动的几种方式\"></a>浅谈view移动的几种方式</h2><h3 id=\"通过改变布局参数来实现View的滑动\"><a href=\"#通过改变布局参数来实现View的滑动\" class=\"headerlink\" title=\"通过改变布局参数来实现View的滑动\"></a>通过改变布局参数来实现View的滑动</h3><p>会影响四个位置的值</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MarginLayoutParams params = (MarginLayoutParams) mButton.getLayoutParams();</div><div class=\"line\">params.leftMargin += 520;</div><div class=\"line\">mButton.requestLayout();</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"使用scrollTo-scrollBy实现View的滑动\"><a href=\"#使用scrollTo-scrollBy实现View的滑动\" class=\"headerlink\" title=\"使用scrollTo/scrollBy实现View的滑动\"></a>使用scrollTo/scrollBy实现View的滑动</h3><p>实际上，调用scrollBy/scrollTo方法只能实现View的内容的滚动，而View的四个位置参数(l,t,r,b)是保持不变的(listview ,recyclerview等)<br>向右滚动时mScrollX负的，向左滚动时mScrollX是正的。同理，向下滚动时，mScrollY是负的，向上滚动时，mScrollY是正的</p>\n<p>点击事件还是在原位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\">   * Set the scrolled position of your view. This will cause a call to </div><div class=\"line\"></div><div class=\"line\">   * &#123;@link <span class=\"comment\">#onScrollChanged(int, int, int, int)&#125; and the view will be </span></div><div class=\"line\"></div><div class=\"line\">   * invalidated. </div><div class=\"line\"></div><div class=\"line\">   * @param x the x position to scroll to </div><div class=\"line\"></div><div class=\"line\">   * @param y the y position to scroll to </div><div class=\"line\"></div><div class=\"line\">   */  </div><div class=\"line\">public void scrollTo(int x, int y) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (mScrollX != x || mScrollY != y) &#123;  </div><div class=\"line\">          int oldX = mScrollX;  </div><div class=\"line\">          int oldY = mScrollY;  </div><div class=\"line\">          mScrollX = x;  </div><div class=\"line\">          mScrollY = y;  </div><div class=\"line\">          onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class=\"line\">          <span class=\"keyword\">if</span> (!awakenScrollBars()) &#123;  </div><div class=\"line\">              invalidate();  </div><div class=\"line\">          &#125;  </div><div class=\"line\">      &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">/** </div><div class=\"line\">    * Move the scrolled position of your view. This will cause a call to </div><div class=\"line\">    * &#123;@link <span class=\"comment\">#onScrollChanged(int, int, int, int)&#125; and the view will be </span></div><div class=\"line\">    * invalidated. </div><div class=\"line\">    * @param x the amount of pixels to scroll by horizontally </div><div class=\"line\">    * @param y the amount of pixels to scroll by vertically </div><div class=\"line\">*/  </div><div class=\"line\">public void scrollBy(int x, int y) &#123;  </div><div class=\"line\">      scrollTo(mScrollX + x, mScrollY + y);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">通过以上代码的33~35行我们可以看到，scrollBy方法内部也是调用了scrollTo方法来实现。</div><div class=\"line\">以上源码中我们注意到了mScrollX和mScrollY成员变量，前者是View的左边缘减去View的内容的左边缘，后者是View的上边缘减去View的内容的上边缘</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用Scroller来实现弹性滑动\"><a href=\"#使用Scroller来实现弹性滑动\" class=\"headerlink\" title=\"使用Scroller来实现弹性滑动\"></a>使用Scroller来实现弹性滑动</h3><p>Scroller 实现弹性滑动的原理：invaldate方法会导致View的draw方法被调用，而draw会调用computeScroll方法，因此重写了computeScroll方法，<br>而computeScrollOffset方法会根据时间的流逝动态的计算出很小的一段时间应该滑动多少距离。也就是把一次滑动拆分成无数次小距离滑动从而实现“弹性滑动”<br>所以必须自己写个view重载computeScroll方法<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scroller scroller = new Scroller(mContext);</div><div class=\"line\"></div><div class=\"line\">private void smoothScrollTo(int dstX, int dstY) &#123;</div><div class=\"line\">    int scrollX = getScrollX();</div><div class=\"line\">    int delta = dstX - scrollX;</div><div class=\"line\">    scroller.startScroll(scrollX, 0, delta, 0, 1000);</div><div class=\"line\">    invalidate(); // 必须调用invalidate()才,否则不会调用computeScroll()方法。看不到滚动效果 </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">public void <span class=\"function\"><span class=\"title\">computeScroll</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scroller.computeScrollOffset()) &#123;</div><div class=\"line\">        scrollTo(scroller.getCurrX(), scroller.getCurY());</div><div class=\"line\">        postInvalidate(); //一定要调用  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// startScroll 的源码</div><div class=\"line\">public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;  </div><div class=\"line\">    mMode = SCROLL_MODE;  </div><div class=\"line\">    mFinished = <span class=\"literal\">false</span>;  </div><div class=\"line\">    mDuration = duration;  </div><div class=\"line\">    mStartTime = AnimationUtils.currentAnimationTimeMillis();  </div><div class=\"line\">    mStartX = startX;  </div><div class=\"line\">    mStartY = startY;  </div><div class=\"line\">    mFinalX = startX + dx;  </div><div class=\"line\">    mFinalY = startY + dy;  </div><div class=\"line\">    mDeltaX = dx;  </div><div class=\"line\">    mDeltaY = dy;  </div><div class=\"line\">    mDurationReciprocal = 1.0f / (<span class=\"built_in\">float</span>) mDuration;  </div><div class=\"line\">    </div><div class=\"line\">    mViscousFluidScale = 8.0f;  </div><div class=\"line\">   </div><div class=\"line\">    mViscousFluidNormalize = 1.0f;  </div><div class=\"line\">    mViscousFluidNormalize = 1.0f / viscousFluid(1.0f);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">从以上的源码我们可以看到，startScroll方法中并没有进行实际的滚动操作，而是把startX、startY、deltaX、deltaY等参数都保存了下来。</div><div class=\"line\">我们看到第7行调用了invalidate方法，这个方法会请求重绘View，这会导致View的draw的方法被调用，draw的方法内部会调用computeScroll方法。</div><div class=\"line\">我们来看看第13行，调用了scrollTo方法，并传入mScroller.getCurrX()和mScroller.getCurrY()方法作为参数。这两个参数是在第12行调用的computeScrollOffset方法中设置的，我们来看看这个方法中设置这两个参数的相关代码</div><div class=\"line\">public boolean <span class=\"function\"><span class=\"title\">computeScrollOffset</span></span>() &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class=\"line\">    <span class=\"keyword\">if</span> (timePassed &lt; mDuration) &#123;</div><div class=\"line\">        switch (mMode) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> SCROLL_MODE:</div><div class=\"line\">                final <span class=\"built_in\">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class=\"line\">                mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class=\"line\">                mCurrY = mStartY + Math.rounc(y * mDeltaY);</div><div class=\"line\">                <span class=\"built_in\">break</span>;</div><div class=\"line\">        ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"layout-and-offsetTopAndBottom-offsetLeftAndRight\"><a href=\"#layout-and-offsetTopAndBottom-offsetLeftAndRight\" class=\"headerlink\" title=\"layout() and offsetTopAndBottom/offsetLeftAndRight\"></a>layout() and offsetTopAndBottom/offsetLeftAndRight</h3><p>主要是通过坐标位置的改变产生移动效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> layout(getLeft() + 5,getTop() + 5,getRight() + 5,getBottom() + 5);</div><div class=\"line\">\t\t</div><div class=\"line\">//  offsetLeftAndRight(5); 作用同上</div><div class=\"line\">//  offsetTopAndBottom(5);</div></pre></td></tr></table></figure>\n<h3 id=\"setTranslationX-Y\"><a href=\"#setTranslationX-Y\" class=\"headerlink\" title=\"setTranslationX/Y\"></a>setTranslationX/Y</h3><p>这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变 ，点击事件的位置会变<br>ObjectAnimator 实际上也是通过它实现</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> /**</div><div class=\"line\">     * Sets the horizontal location of this view relative to its &#123;@link <span class=\"comment\">#getLeft() left&#125; position.</span></div><div class=\"line\">     * This effectively positions the object post-layout, <span class=\"keyword\">in</span> addition to wherever the object<span class=\"string\">'s</span></div><div class=\"line\">     * layout placed it.</div><div class=\"line\">     *</div><div class=\"line\">     * @param translationX The horizontal position of this view relative to its left position,</div><div class=\"line\">     * in pixels.</div><div class=\"line\">     *</div><div class=\"line\">     * @attr ref android.R.styleable#View_translationX</div><div class=\"line\">     */</div><div class=\"line\">    public void setTranslationX(float translationX) &#123;</div><div class=\"line\">        if (translationX != getTranslationX()) &#123;</div><div class=\"line\">            invalidateViewProperty(true, false);</div><div class=\"line\">            mRenderNode.setTranslationX(translationX);</div><div class=\"line\">            invalidateViewProperty(false, true);</div><div class=\"line\"></div><div class=\"line\">            invalidateParentIfNeededAndWasQuickRejected();</div><div class=\"line\">            notifySubtreeAccessibilityStateChangedIfNeeded();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">从源码可以看出，它的参数不是一个相对位移，而是绝对的偏移值，所以设置多少次都不会叠加</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"浅谈view移动的几种方式\"><a href=\"#浅谈view移动的几种方式\" class=\"headerlink\" title=\"浅谈view移动的几种方式\"></a>浅谈view移动的几种方式</h2><h3 id=\"通过改变布局参数来实现View的滑动\"><a href=\"#通过改变布局参数来实现View的滑动\" class=\"headerlink\" title=\"通过改变布局参数来实现View的滑动\"></a>通过改变布局参数来实现View的滑动</h3><p>会影响四个位置的值</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">MarginLayoutParams params = (MarginLayoutParams) mButton.getLayoutParams();</div><div class=\"line\">params.leftMargin += 520;</div><div class=\"line\">mButton.requestLayout();</div></pre></td></tr></table></figure>","more":"<h3 id=\"使用scrollTo-scrollBy实现View的滑动\"><a href=\"#使用scrollTo-scrollBy实现View的滑动\" class=\"headerlink\" title=\"使用scrollTo/scrollBy实现View的滑动\"></a>使用scrollTo/scrollBy实现View的滑动</h3><p>实际上，调用scrollBy/scrollTo方法只能实现View的内容的滚动，而View的四个位置参数(l,t,r,b)是保持不变的(listview ,recyclerview等)<br>向右滚动时mScrollX负的，向左滚动时mScrollX是正的。同理，向下滚动时，mScrollY是负的，向上滚动时，mScrollY是正的</p>\n<p>点击事件还是在原位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\">   * Set the scrolled position of your view. This will cause a call to </div><div class=\"line\"></div><div class=\"line\">   * &#123;@link <span class=\"comment\">#onScrollChanged(int, int, int, int)&#125; and the view will be </span></div><div class=\"line\"></div><div class=\"line\">   * invalidated. </div><div class=\"line\"></div><div class=\"line\">   * @param x the x position to scroll to </div><div class=\"line\"></div><div class=\"line\">   * @param y the y position to scroll to </div><div class=\"line\"></div><div class=\"line\">   */  </div><div class=\"line\">public void scrollTo(int x, int y) &#123;  </div><div class=\"line\">      <span class=\"keyword\">if</span> (mScrollX != x || mScrollY != y) &#123;  </div><div class=\"line\">          int oldX = mScrollX;  </div><div class=\"line\">          int oldY = mScrollY;  </div><div class=\"line\">          mScrollX = x;  </div><div class=\"line\">          mScrollY = y;  </div><div class=\"line\">          onScrollChanged(mScrollX, mScrollY, oldX, oldY);  </div><div class=\"line\">          <span class=\"keyword\">if</span> (!awakenScrollBars()) &#123;  </div><div class=\"line\">              invalidate();  </div><div class=\"line\">          &#125;  </div><div class=\"line\">      &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\"></div><div class=\"line\">/** </div><div class=\"line\">    * Move the scrolled position of your view. This will cause a call to </div><div class=\"line\">    * &#123;@link <span class=\"comment\">#onScrollChanged(int, int, int, int)&#125; and the view will be </span></div><div class=\"line\">    * invalidated. </div><div class=\"line\">    * @param x the amount of pixels to scroll by horizontally </div><div class=\"line\">    * @param y the amount of pixels to scroll by vertically </div><div class=\"line\">*/  </div><div class=\"line\">public void scrollBy(int x, int y) &#123;  </div><div class=\"line\">      scrollTo(mScrollX + x, mScrollY + y);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">通过以上代码的33~35行我们可以看到，scrollBy方法内部也是调用了scrollTo方法来实现。</div><div class=\"line\">以上源码中我们注意到了mScrollX和mScrollY成员变量，前者是View的左边缘减去View的内容的左边缘，后者是View的上边缘减去View的内容的上边缘</div></pre></td></tr></table></figure></p>\n<h3 id=\"使用Scroller来实现弹性滑动\"><a href=\"#使用Scroller来实现弹性滑动\" class=\"headerlink\" title=\"使用Scroller来实现弹性滑动\"></a>使用Scroller来实现弹性滑动</h3><p>Scroller 实现弹性滑动的原理：invaldate方法会导致View的draw方法被调用，而draw会调用computeScroll方法，因此重写了computeScroll方法，<br>而computeScrollOffset方法会根据时间的流逝动态的计算出很小的一段时间应该滑动多少距离。也就是把一次滑动拆分成无数次小距离滑动从而实现“弹性滑动”<br>所以必须自己写个view重载computeScroll方法<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">Scroller scroller = new Scroller(mContext);</div><div class=\"line\"></div><div class=\"line\">private void smoothScrollTo(int dstX, int dstY) &#123;</div><div class=\"line\">    int scrollX = getScrollX();</div><div class=\"line\">    int delta = dstX - scrollX;</div><div class=\"line\">    scroller.startScroll(scrollX, 0, delta, 0, 1000);</div><div class=\"line\">    invalidate(); // 必须调用invalidate()才,否则不会调用computeScroll()方法。看不到滚动效果 </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">public void <span class=\"function\"><span class=\"title\">computeScroll</span></span>() &#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (scroller.computeScrollOffset()) &#123;</div><div class=\"line\">        scrollTo(scroller.getCurrX(), scroller.getCurY());</div><div class=\"line\">        postInvalidate(); //一定要调用  </div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">// startScroll 的源码</div><div class=\"line\">public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;  </div><div class=\"line\">    mMode = SCROLL_MODE;  </div><div class=\"line\">    mFinished = <span class=\"literal\">false</span>;  </div><div class=\"line\">    mDuration = duration;  </div><div class=\"line\">    mStartTime = AnimationUtils.currentAnimationTimeMillis();  </div><div class=\"line\">    mStartX = startX;  </div><div class=\"line\">    mStartY = startY;  </div><div class=\"line\">    mFinalX = startX + dx;  </div><div class=\"line\">    mFinalY = startY + dy;  </div><div class=\"line\">    mDeltaX = dx;  </div><div class=\"line\">    mDeltaY = dy;  </div><div class=\"line\">    mDurationReciprocal = 1.0f / (<span class=\"built_in\">float</span>) mDuration;  </div><div class=\"line\">    </div><div class=\"line\">    mViscousFluidScale = 8.0f;  </div><div class=\"line\">   </div><div class=\"line\">    mViscousFluidNormalize = 1.0f;  </div><div class=\"line\">    mViscousFluidNormalize = 1.0f / viscousFluid(1.0f);  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">从以上的源码我们可以看到，startScroll方法中并没有进行实际的滚动操作，而是把startX、startY、deltaX、deltaY等参数都保存了下来。</div><div class=\"line\">我们看到第7行调用了invalidate方法，这个方法会请求重绘View，这会导致View的draw的方法被调用，draw的方法内部会调用computeScroll方法。</div><div class=\"line\">我们来看看第13行，调用了scrollTo方法，并传入mScroller.getCurrX()和mScroller.getCurrY()方法作为参数。这两个参数是在第12行调用的computeScrollOffset方法中设置的，我们来看看这个方法中设置这两个参数的相关代码</div><div class=\"line\">public boolean <span class=\"function\"><span class=\"title\">computeScrollOffset</span></span>() &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    int timePassed = (int) (AnimationUtils.currentAnimationTimeMillis() - mStartTime);</div><div class=\"line\">    <span class=\"keyword\">if</span> (timePassed &lt; mDuration) &#123;</div><div class=\"line\">        switch (mMode) &#123;</div><div class=\"line\">            <span class=\"keyword\">case</span> SCROLL_MODE:</div><div class=\"line\">                final <span class=\"built_in\">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</div><div class=\"line\">                mCurrX = mStartX + Math.round(x * mDeltaX);</div><div class=\"line\">                mCurrY = mStartY + Math.rounc(y * mDeltaY);</div><div class=\"line\">                <span class=\"built_in\">break</span>;</div><div class=\"line\">        ...</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"layout-and-offsetTopAndBottom-offsetLeftAndRight\"><a href=\"#layout-and-offsetTopAndBottom-offsetLeftAndRight\" class=\"headerlink\" title=\"layout() and offsetTopAndBottom/offsetLeftAndRight\"></a>layout() and offsetTopAndBottom/offsetLeftAndRight</h3><p>主要是通过坐标位置的改变产生移动效果</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> layout(getLeft() + 5,getTop() + 5,getRight() + 5,getBottom() + 5);</div><div class=\"line\">\t\t</div><div class=\"line\">//  offsetLeftAndRight(5); 作用同上</div><div class=\"line\">//  offsetTopAndBottom(5);</div></pre></td></tr></table></figure>\n<h3 id=\"setTranslationX-Y\"><a href=\"#setTranslationX-Y\" class=\"headerlink\" title=\"setTranslationX/Y\"></a>setTranslationX/Y</h3><p>这个方法的底层实现主要是通过metrix矩阵变换来的，坐标位置没有改变 ，点击事件的位置会变<br>ObjectAnimator 实际上也是通过它实现</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"> /**</div><div class=\"line\">     * Sets the horizontal location of this view relative to its &#123;@link <span class=\"comment\">#getLeft() left&#125; position.</span></div><div class=\"line\">     * This effectively positions the object post-layout, <span class=\"keyword\">in</span> addition to wherever the object<span class=\"string\">'s</span></div><div class=\"line\">     * layout placed it.</div><div class=\"line\">     *</div><div class=\"line\">     * @param translationX The horizontal position of this view relative to its left position,</div><div class=\"line\">     * in pixels.</div><div class=\"line\">     *</div><div class=\"line\">     * @attr ref android.R.styleable#View_translationX</div><div class=\"line\">     */</div><div class=\"line\">    public void setTranslationX(float translationX) &#123;</div><div class=\"line\">        if (translationX != getTranslationX()) &#123;</div><div class=\"line\">            invalidateViewProperty(true, false);</div><div class=\"line\">            mRenderNode.setTranslationX(translationX);</div><div class=\"line\">            invalidateViewProperty(false, true);</div><div class=\"line\"></div><div class=\"line\">            invalidateParentIfNeededAndWasQuickRejected();</div><div class=\"line\">            notifySubtreeAccessibilityStateChangedIfNeeded();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">从源码可以看出，它的参数不是一个相对位移，而是绝对的偏移值，所以设置多少次都不会叠加</div></pre></td></tr></table></figure>"},{"title":"初识 android View","date":"2017-05-14T05:57:51.000Z","_content":"\n## View的坐标系\n![](http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg)\n\nView在屏幕上的位置由它的以下四个参数所决定：\ntop：View的左上角的纵坐标，对应着View类中的成员变量mTop，可由getTop方法获得；\nleft：View的左上角的横坐标，对应着View类中的成员变量mLeft，可由getLeft方法获得；\nbottom：View的右下角的纵坐标，对应着View类中的成员变量mBottom，可由getBottom方法获得；\nright：View的右下角的横坐标，对应着View类中的成员变量mRight，可由getRight方法获得。\n\n有了这四个参数，计算View的宽高就很容易了：width = right - left；height = bottom - top。\n关于View还有两个参数需要我们注意：translationX代表View平移的水平距离，translationY代表View平移的竖直距离；x、y分别为View的左上角的横纵坐标。\nView若经过了平移，改变的是它的x、y（代表当前View的左上角位置），它的四个位置参数代表了View的原始位置信息，是始终不变的。\nView在平移的过程中始终满足关系：x = left + translationX; y = top + translationY。\n\n<!-- more -->\n## 从构造函数开始\n``` bash\npublic void SloopView(Context context) {} // 一般在直接New一个View的时候调用。\n// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。\npublic void SloopView(Context context, AttributeSet attrs) {} \npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr) {}\npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {} // 有四个参数的构造函数在API21的时候才添加上\n```\n有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，\n且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：\n``` bash\npublic ImageButton(Context context, AttributeSet attrs) {\n    //调用了三个参数的构造函数，明确指定第三个参数\n    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);\n}\n\npublic ImageButton(Context context, AttributeSet attrs, int defStyleAttr) {\n    //此处调了四个参数的构造函数，无视即可\n    this(context, attrs, defStyleAttr, 0); \n}\n//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数\n```\n\n## view 的绘制过程 (注意不要在里面做ui更新操作)\n![](http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg)\nonMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。\n``` bash\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值\n    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式\n    \n    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值\n    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式\n}\n```\n测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：\n\n|  模式\t\t\t|二进制数值\t\t|描述\n| --------  | \t-----:   \t\t| :----: |\n|UNSPECIFIED\t|00\t|\t\t\t默认值，父控件没有给子view任何限制，子View可以设置为任意大小。\n|EXACTLY\t\t|01\t|\t\t\t表示父控件已经确切的指定了子View的大小。\n|AT_MOST\t\t|10\t|\t\t\t表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。\n\n注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数\n\nonSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度\n\nonLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的\n\n## 实用api\n``` bash\nevent.getX();       //触摸点相对于其所在组件坐标系的坐标\nevent.getY();\n\nevent.getRawX();    //触摸点相对于屏幕默认坐标系的坐标\nevent.getRawY();\n\ngetTop();       //获取子View左上角距父View顶部的距离\ngetLeft();      //获取子View左上角距父View左侧的距离\ngetBottom();    //获取子View右下角距父View顶部的距离\ngetRight();     //获取子View右下角距父View左侧的距离\n```","source":"_posts/view.md","raw":"---\ntitle: 初识 android View\ndate: 2017-05-14 13:57:51\ncategories: android\ntags: 自定义view\n---\n\n## View的坐标系\n![](http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg)\n\nView在屏幕上的位置由它的以下四个参数所决定：\ntop：View的左上角的纵坐标，对应着View类中的成员变量mTop，可由getTop方法获得；\nleft：View的左上角的横坐标，对应着View类中的成员变量mLeft，可由getLeft方法获得；\nbottom：View的右下角的纵坐标，对应着View类中的成员变量mBottom，可由getBottom方法获得；\nright：View的右下角的横坐标，对应着View类中的成员变量mRight，可由getRight方法获得。\n\n有了这四个参数，计算View的宽高就很容易了：width = right - left；height = bottom - top。\n关于View还有两个参数需要我们注意：translationX代表View平移的水平距离，translationY代表View平移的竖直距离；x、y分别为View的左上角的横纵坐标。\nView若经过了平移，改变的是它的x、y（代表当前View的左上角位置），它的四个位置参数代表了View的原始位置信息，是始终不变的。\nView在平移的过程中始终满足关系：x = left + translationX; y = top + translationY。\n\n<!-- more -->\n## 从构造函数开始\n``` bash\npublic void SloopView(Context context) {} // 一般在直接New一个View的时候调用。\n// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。\npublic void SloopView(Context context, AttributeSet attrs) {} \npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr) {}\npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {} // 有四个参数的构造函数在API21的时候才添加上\n```\n有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，\n且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：\n``` bash\npublic ImageButton(Context context, AttributeSet attrs) {\n    //调用了三个参数的构造函数，明确指定第三个参数\n    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);\n}\n\npublic ImageButton(Context context, AttributeSet attrs, int defStyleAttr) {\n    //此处调了四个参数的构造函数，无视即可\n    this(context, attrs, defStyleAttr, 0); \n}\n//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数\n```\n\n## view 的绘制过程 (注意不要在里面做ui更新操作)\n![](http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg)\nonMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。\n``` bash\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值\n    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式\n    \n    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值\n    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式\n}\n```\n测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：\n\n|  模式\t\t\t|二进制数值\t\t|描述\n| --------  | \t-----:   \t\t| :----: |\n|UNSPECIFIED\t|00\t|\t\t\t默认值，父控件没有给子view任何限制，子View可以设置为任意大小。\n|EXACTLY\t\t|01\t|\t\t\t表示父控件已经确切的指定了子View的大小。\n|AT_MOST\t\t|10\t|\t\t\t表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。\n\n注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数\n\nonSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度\n\nonLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的\n\n## 实用api\n``` bash\nevent.getX();       //触摸点相对于其所在组件坐标系的坐标\nevent.getY();\n\nevent.getRawX();    //触摸点相对于屏幕默认坐标系的坐标\nevent.getRawY();\n\ngetTop();       //获取子View左上角距父View顶部的距离\ngetLeft();      //获取子View左上角距父View左侧的距离\ngetBottom();    //获取子View右下角距父View顶部的距离\ngetRight();     //获取子View右下角距父View左侧的距离\n```","slug":"view","published":1,"updated":"2018-02-12T07:04:10.623Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gc1001no4l1qjgm2dzw","content":"<h2 id=\"View的坐标系\"><a href=\"#View的坐标系\" class=\"headerlink\" title=\"View的坐标系\"></a>View的坐标系</h2><p><img src=\"http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg\" alt=\"\"></p>\n<p>View在屏幕上的位置由它的以下四个参数所决定：<br>top：View的左上角的纵坐标，对应着View类中的成员变量mTop，可由getTop方法获得；<br>left：View的左上角的横坐标，对应着View类中的成员变量mLeft，可由getLeft方法获得；<br>bottom：View的右下角的纵坐标，对应着View类中的成员变量mBottom，可由getBottom方法获得；<br>right：View的右下角的横坐标，对应着View类中的成员变量mRight，可由getRight方法获得。</p>\n<p>有了这四个参数，计算View的宽高就很容易了：width = right - left；height = bottom - top。<br>关于View还有两个参数需要我们注意：translationX代表View平移的水平距离，translationY代表View平移的竖直距离；x、y分别为View的左上角的横纵坐标。<br>View若经过了平移，改变的是它的x、y（代表当前View的左上角位置），它的四个位置参数代表了View的原始位置信息，是始终不变的。<br>View在平移的过程中始终满足关系：x = left + translationX; y = top + translationY。</p>\n<a id=\"more\"></a>\n<h2 id=\"从构造函数开始\"><a href=\"#从构造函数开始\" class=\"headerlink\" title=\"从构造函数开始\"></a>从构造函数开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void SloopView(Context context) &#123;&#125; // 一般在直接New一个View的时候调用。</div><div class=\"line\">// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs) &#123;&#125; </div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr) &#123;&#125;</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;&#125; // 有四个参数的构造函数在API21的时候才添加上</div></pre></td></tr></table></figure>\n<p>有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，<br>且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ImageButton(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    //调用了三个参数的构造函数，明确指定第三个参数</div><div class=\"line\">    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public ImageButton(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class=\"line\">    //此处调了四个参数的构造函数，无视即可</div><div class=\"line\">    this(context, attrs, defStyleAttr, 0); </div><div class=\"line\">&#125;</div><div class=\"line\">//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数</div></pre></td></tr></table></figure></p>\n<h2 id=\"view-的绘制过程-注意不要在里面做ui更新操作\"><a href=\"#view-的绘制过程-注意不要在里面做ui更新操作\" class=\"headerlink\" title=\"view 的绘制过程 (注意不要在里面做ui更新操作)\"></a>view 的绘制过程 (注意不要在里面做ui更新操作)</h2><p><img src=\"http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg\" alt=\"\"><br>onMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值</div><div class=\"line\">    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式</div><div class=\"line\">    </div><div class=\"line\">    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值</div><div class=\"line\">    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:right\">二进制数值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UNSPECIFIED</td>\n<td style=\"text-align:right\">00</td>\n<td style=\"text-align:center\">默认值，父控件没有给子view任何限制，子View可以设置为任意大小。</td>\n</tr>\n<tr>\n<td>EXACTLY</td>\n<td style=\"text-align:right\">01</td>\n<td style=\"text-align:center\">表示父控件已经确切的指定了子View的大小。</td>\n</tr>\n<tr>\n<td>AT_MOST</td>\n<td style=\"text-align:right\">10</td>\n<td style=\"text-align:center\">表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数</p>\n<p>onSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度</p>\n<p>onLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的</p>\n<h2 id=\"实用api\"><a href=\"#实用api\" class=\"headerlink\" title=\"实用api\"></a>实用api</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">event.getX();       //触摸点相对于其所在组件坐标系的坐标</div><div class=\"line\">event.getY();</div><div class=\"line\"></div><div class=\"line\">event.getRawX();    //触摸点相对于屏幕默认坐标系的坐标</div><div class=\"line\">event.getRawY();</div><div class=\"line\"></div><div class=\"line\">getTop();       //获取子View左上角距父View顶部的距离</div><div class=\"line\">getLeft();      //获取子View左上角距父View左侧的距离</div><div class=\"line\">getBottom();    //获取子View右下角距父View顶部的距离</div><div class=\"line\">getRight();     //获取子View右下角距父View左侧的距离</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"View的坐标系\"><a href=\"#View的坐标系\" class=\"headerlink\" title=\"View的坐标系\"></a>View的坐标系</h2><p><img src=\"http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg\" alt=\"\"></p>\n<p>View在屏幕上的位置由它的以下四个参数所决定：<br>top：View的左上角的纵坐标，对应着View类中的成员变量mTop，可由getTop方法获得；<br>left：View的左上角的横坐标，对应着View类中的成员变量mLeft，可由getLeft方法获得；<br>bottom：View的右下角的纵坐标，对应着View类中的成员变量mBottom，可由getBottom方法获得；<br>right：View的右下角的横坐标，对应着View类中的成员变量mRight，可由getRight方法获得。</p>\n<p>有了这四个参数，计算View的宽高就很容易了：width = right - left；height = bottom - top。<br>关于View还有两个参数需要我们注意：translationX代表View平移的水平距离，translationY代表View平移的竖直距离；x、y分别为View的左上角的横纵坐标。<br>View若经过了平移，改变的是它的x、y（代表当前View的左上角位置），它的四个位置参数代表了View的原始位置信息，是始终不变的。<br>View在平移的过程中始终满足关系：x = left + translationX; y = top + translationY。</p>","more":"<h2 id=\"从构造函数开始\"><a href=\"#从构造函数开始\" class=\"headerlink\" title=\"从构造函数开始\"></a>从构造函数开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void SloopView(Context context) &#123;&#125; // 一般在直接New一个View的时候调用。</div><div class=\"line\">// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs) &#123;&#125; </div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr) &#123;&#125;</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;&#125; // 有四个参数的构造函数在API21的时候才添加上</div></pre></td></tr></table></figure>\n<p>有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，<br>且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ImageButton(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    //调用了三个参数的构造函数，明确指定第三个参数</div><div class=\"line\">    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public ImageButton(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class=\"line\">    //此处调了四个参数的构造函数，无视即可</div><div class=\"line\">    this(context, attrs, defStyleAttr, 0); </div><div class=\"line\">&#125;</div><div class=\"line\">//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数</div></pre></td></tr></table></figure></p>\n<h2 id=\"view-的绘制过程-注意不要在里面做ui更新操作\"><a href=\"#view-的绘制过程-注意不要在里面做ui更新操作\" class=\"headerlink\" title=\"view 的绘制过程 (注意不要在里面做ui更新操作)\"></a>view 的绘制过程 (注意不要在里面做ui更新操作)</h2><p><img src=\"http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg\" alt=\"\"><br>onMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值</div><div class=\"line\">    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式</div><div class=\"line\">    </div><div class=\"line\">    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值</div><div class=\"line\">    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:right\">二进制数值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UNSPECIFIED</td>\n<td style=\"text-align:right\">00</td>\n<td style=\"text-align:center\">默认值，父控件没有给子view任何限制，子View可以设置为任意大小。</td>\n</tr>\n<tr>\n<td>EXACTLY</td>\n<td style=\"text-align:right\">01</td>\n<td style=\"text-align:center\">表示父控件已经确切的指定了子View的大小。</td>\n</tr>\n<tr>\n<td>AT_MOST</td>\n<td style=\"text-align:right\">10</td>\n<td style=\"text-align:center\">表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数</p>\n<p>onSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度</p>\n<p>onLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的</p>\n<h2 id=\"实用api\"><a href=\"#实用api\" class=\"headerlink\" title=\"实用api\"></a>实用api</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">event.getX();       //触摸点相对于其所在组件坐标系的坐标</div><div class=\"line\">event.getY();</div><div class=\"line\"></div><div class=\"line\">event.getRawX();    //触摸点相对于屏幕默认坐标系的坐标</div><div class=\"line\">event.getRawY();</div><div class=\"line\"></div><div class=\"line\">getTop();       //获取子View左上角距父View顶部的距离</div><div class=\"line\">getLeft();      //获取子View左上角距父View左侧的距离</div><div class=\"line\">getBottom();    //获取子View右下角距父View顶部的距离</div><div class=\"line\">getRight();     //获取子View右下角距父View左侧的距离</div></pre></td></tr></table></figure>"},{"title":"volatitle 关键字","date":"2017-05-10T07:35:10.000Z","_content":"\n## 首先先普及下内存模型的概念\n  \n大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n\n<!-- more -->\n\n## 并发编程中的三个概念\n1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值\n3.有序性：即程序执行的顺序按照代码的先后顺序执行\n\n## volatitle的作用\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n3）不保證原子性\n\n### [参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\n\n","source":"_posts/volatitle.md","raw":"---\ntitle: volatitle 关键字\ndate: 2017-05-10 15:35:10\ncategories: android\ntags: java\n---\n\n## 首先先普及下内存模型的概念\n  \n大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n\n<!-- more -->\n\n## 并发编程中的三个概念\n1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值\n3.有序性：即程序执行的顺序按照代码的先后顺序执行\n\n## volatitle的作用\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n3）不保證原子性\n\n### [参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\n\n","slug":"volatitle","published":1,"updated":"2018-02-10T06:53:50.960Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gc3001po4l152w3tfr5","content":"<h2 id=\"首先先普及下内存模型的概念\"><a href=\"#首先先普及下内存模型的概念\" class=\"headerlink\" title=\"首先先普及下内存模型的概念\"></a>首先先普及下内存模型的概念</h2><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。<br>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>\n<a id=\"more\"></a>\n<h2 id=\"并发编程中的三个概念\"><a href=\"#并发编程中的三个概念\" class=\"headerlink\" title=\"并发编程中的三个概念\"></a>并发编程中的三个概念</h2><p>1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行<br>2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值<br>3.有序性：即程序执行的顺序按照代码的先后顺序执行</p>\n<h2 id=\"volatitle的作用\"><a href=\"#volatitle的作用\" class=\"headerlink\" title=\"volatitle的作用\"></a>volatitle的作用</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。<br>3）不保證原子性</p>\n<h3 id=\"参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\"><a href=\"#参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\" class=\"headerlink\" title=\"[参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\"></a>[参考链接] (<a href=\"http://blog.csdn.net/victor_cindy1/article/details/44310195\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/victor_cindy1/article/details/44310195</a>)</h3>","site":{"data":{}},"excerpt":"<h2 id=\"首先先普及下内存模型的概念\"><a href=\"#首先先普及下内存模型的概念\" class=\"headerlink\" title=\"首先先普及下内存模型的概念\"></a>首先先普及下内存模型的概念</h2><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。<br>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>","more":"<h2 id=\"并发编程中的三个概念\"><a href=\"#并发编程中的三个概念\" class=\"headerlink\" title=\"并发编程中的三个概念\"></a>并发编程中的三个概念</h2><p>1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行<br>2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值<br>3.有序性：即程序执行的顺序按照代码的先后顺序执行</p>\n<h2 id=\"volatitle的作用\"><a href=\"#volatitle的作用\" class=\"headerlink\" title=\"volatitle的作用\"></a>volatitle的作用</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。<br>3）不保證原子性</p>\n<h3 id=\"参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\"><a href=\"#参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\" class=\"headerlink\" title=\"[参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\"></a>[参考链接] (<a href=\"http://blog.csdn.net/victor_cindy1/article/details/44310195\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/victor_cindy1/article/details/44310195</a>)</h3>"},{"title":"synchronized ， sleep ，wait ，notify，等的理解","date":"2017-05-10T08:30:04.000Z","_content":"\n1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。\n\n2.wait，notify以及notifyall`只能在同步控制方法或者同步控制块中使用`，而sleep可是在任何地方使用。\n\n3.sleep必须捕获异常，而其他3个则不需要。\n\n<!-- more -->\n\n4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别\n\n5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了\n\n6.Obj.wait()，与Obj.notify()`必须要与synchronized(Obj)一起使用`，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制\n\n7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。\n这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。\n    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。\n    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。\n其中wait方法有三个over load方法：\n\nwait()\n\nwait(long)\n\nwait(long,int)\n\nwait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。","source":"_posts/lock.md","raw":"---\ntitle: synchronized ， sleep ，wait ，notify，等的理解\ndate: 2017-05-10 16:30:04\ncategories: android\ntags: 多线程\n---\n\n1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。\n\n2.wait，notify以及notifyall`只能在同步控制方法或者同步控制块中使用`，而sleep可是在任何地方使用。\n\n3.sleep必须捕获异常，而其他3个则不需要。\n\n<!-- more -->\n\n4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别\n\n5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了\n\n6.Obj.wait()，与Obj.notify()`必须要与synchronized(Obj)一起使用`，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制\n\n7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。\n这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。\n    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。\n    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。\n其中wait方法有三个over load方法：\n\nwait()\n\nwait(long)\n\nwait(long,int)\n\nwait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。","slug":"lock","published":1,"updated":"2018-02-10T06:53:50.947Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdjx0gc7001to4l1n67odxrk","content":"<p>1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。</p>\n<p>2.wait，notify以及notifyall<code>只能在同步控制方法或者同步控制块中使用</code>，而sleep可是在任何地方使用。</p>\n<p>3.sleep必须捕获异常，而其他3个则不需要。</p>\n<a id=\"more\"></a>\n<p>4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别</p>\n<p>5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了</p>\n<p>6.Obj.wait()，与Obj.notify()<code>必须要与synchronized(Obj)一起使用</code>，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制</p>\n<p>7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。<br>这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。<br>    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。<br>    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。<br>    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。<br>其中wait方法有三个over load方法：</p>\n<p>wait()</p>\n<p>wait(long)</p>\n<p>wait(long,int)</p>\n<p>wait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。</p>\n","site":{"data":{}},"excerpt":"<p>1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。</p>\n<p>2.wait，notify以及notifyall<code>只能在同步控制方法或者同步控制块中使用</code>，而sleep可是在任何地方使用。</p>\n<p>3.sleep必须捕获异常，而其他3个则不需要。</p>","more":"<p>4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别</p>\n<p>5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了</p>\n<p>6.Obj.wait()，与Obj.notify()<code>必须要与synchronized(Obj)一起使用</code>，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制</p>\n<p>7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。<br>这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。<br>    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。<br>    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。<br>    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。<br>其中wait方法有三个over load方法：</p>\n<p>wait()</p>\n<p>wait(long)</p>\n<p>wait(long,int)</p>\n<p>wait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdjx0gae0005o4l14wtmqayn","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gap000ao4l1iun3z33q"},{"post_id":"cjdjx0ga00000o4l1ho6141tz","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gat000eo4l1coepfr7t"},{"post_id":"cjdjx0gah0006o4l14ts9oi29","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gb4000ho4l1bteofpk0"},{"post_id":"cjdjx0ga60001o4l1idl16mlg","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gb9000mo4l13a0di2hf"},{"post_id":"cjdjx0gat000fo4l1guy76gex","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gbb000po4l1pklqwzu2"},{"post_id":"cjdjx0gad0004o4l1s9fyzw6j","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gbe000to4l1021leti8"},{"post_id":"cjdjx0gb9000no4l1aqwut7z4","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gbg000vo4l1kcja7by7"},{"post_id":"cjdjx0gam0009o4l1pb1m2lde","category_id":"cjdjx0gb6000jo4l1rnio773b","_id":"cjdjx0gbi000zo4l1iktymsj0"},{"post_id":"cjdjx0gbf000uo4l1rus690io","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gbj0012o4l1yzhaw6yf"},{"post_id":"cjdjx0gap000bo4l1zbzznrna","category_id":"cjdjx0gbd000ro4l1bc9csca3","_id":"cjdjx0gbn0016o4l14ph1uz52"},{"post_id":"cjdjx0gbg000wo4l1zumy0tov","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gbq0019o4l1a70zhp4r"},{"post_id":"cjdjx0gbi0010o4l1lspobpqm","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gbt001co4l1hfasfcgq"},{"post_id":"cjdjx0gb5000io4l1hixx78bt","category_id":"cjdjx0gbd000ro4l1bc9csca3","_id":"cjdjx0gbw001go4l13z9rrdy2"},{"post_id":"cjdjx0gbl0013o4l1ok2aqakz","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gbx001io4l1zm569uhj"},{"post_id":"cjdjx0gbo0017o4l1tjiskgyo","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gc0001lo4l1eyevj9xx"},{"post_id":"cjdjx0gbq001ao4l1hpb6ra4p","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gc2001oo4l16mx4io3u"},{"post_id":"cjdjx0gbu001eo4l1347jwz59","category_id":"cjdjx0gb6000jo4l1rnio773b","_id":"cjdjx0gc6001so4l1a96a3pw8"},{"post_id":"cjdjx0gbw001ho4l1l9n3hr27","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gc9001vo4l1smxcgrxt"},{"post_id":"cjdjx0gby001jo4l1qytx9axk","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gcb001yo4l1bo4o0m7p"},{"post_id":"cjdjx0gc1001no4l1qjgm2dzw","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gcc0020o4l1anilrgz1"},{"post_id":"cjdjx0gc3001po4l152w3tfr5","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gcd0022o4l1fuabcbc8"},{"post_id":"cjdjx0gc7001to4l1n67odxrk","category_id":"cjdjx0ga90002o4l1y1tm8z7e","_id":"cjdjx0gce0024o4l1z25lr2gr"}],"PostTag":[{"post_id":"cjdjx0ga00000o4l1ho6141tz","tag_id":"cjdjx0gac0003o4l1jxujbjnu","_id":"cjdjx0gb3000go4l1zimmbk7m"},{"post_id":"cjdjx0ga00000o4l1ho6141tz","tag_id":"cjdjx0gak0008o4l1ecw6u9tl","_id":"cjdjx0gb7000ko4l1sgrjtsqg"},{"post_id":"cjdjx0ga60001o4l1idl16mlg","tag_id":"cjdjx0gac0003o4l1jxujbjnu","_id":"cjdjx0gba000oo4l159p2l2wz"},{"post_id":"cjdjx0gad0004o4l1s9fyzw6j","tag_id":"cjdjx0gac0003o4l1jxujbjnu","_id":"cjdjx0gbj0011o4l18nbt5wn7"},{"post_id":"cjdjx0gad0004o4l1s9fyzw6j","tag_id":"cjdjx0gak0008o4l1ecw6u9tl","_id":"cjdjx0gbm0014o4l1jsw7dmqx"},{"post_id":"cjdjx0gae0005o4l14wtmqayn","tag_id":"cjdjx0gac0003o4l1jxujbjnu","_id":"cjdjx0gbq0018o4l19bah3fcs"},{"post_id":"cjdjx0gae0005o4l14wtmqayn","tag_id":"cjdjx0gbh000xo4l19a6r6anq","_id":"cjdjx0gbs001bo4l1vmttt9p6"},{"post_id":"cjdjx0gah0006o4l14ts9oi29","tag_id":"cjdjx0gbn0015o4l1eliv6dn7","_id":"cjdjx0gbw001fo4l1yhx6otr0"},{"post_id":"cjdjx0gap000bo4l1zbzznrna","tag_id":"cjdjx0gbu001do4l1eqz928oz","_id":"cjdjx0gc0001mo4l1jkkrerds"},{"post_id":"cjdjx0gc1001no4l1qjgm2dzw","tag_id":"cjdjx0gac0003o4l1jxujbjnu","_id":"cjdjx0gc6001ro4l1zyzm4rru"},{"post_id":"cjdjx0gat000fo4l1guy76gex","tag_id":"cjdjx0gac0003o4l1jxujbjnu","_id":"cjdjx0gc9001uo4l1fts46gpx"},{"post_id":"cjdjx0gat000fo4l1guy76gex","tag_id":"cjdjx0gbh000xo4l19a6r6anq","_id":"cjdjx0gcb001xo4l1o33u8kmi"},{"post_id":"cjdjx0gb5000io4l1hixx78bt","tag_id":"cjdjx0gc4001qo4l1thi1z2y2","_id":"cjdjx0gcb001zo4l1tqtptqo8"},{"post_id":"cjdjx0gb9000no4l1aqwut7z4","tag_id":"cjdjx0gca001wo4l1segglfii","_id":"cjdjx0gce0023o4l1tck72f6f"},{"post_id":"cjdjx0gbc000qo4l13by1t2go","tag_id":"cjdjx0gcc0021o4l1e1me430s","_id":"cjdjx0gce0026o4l1okc99blx"},{"post_id":"cjdjx0gbf000uo4l1rus690io","tag_id":"cjdjx0gce0025o4l11di5gtxh","_id":"cjdjx0gcf0028o4l1v3zgf6ni"},{"post_id":"cjdjx0gbg000wo4l1zumy0tov","tag_id":"cjdjx0gcf0027o4l1dreg4qcw","_id":"cjdjx0gcf002ao4l16ftm1kvz"},{"post_id":"cjdjx0gbi0010o4l1lspobpqm","tag_id":"cjdjx0gcf0029o4l174y33z7t","_id":"cjdjx0gcg002co4l11khlf1w2"},{"post_id":"cjdjx0gbl0013o4l1ok2aqakz","tag_id":"cjdjx0gcg002bo4l14ojdmgdy","_id":"cjdjx0gch002eo4l1jxt8tkmq"},{"post_id":"cjdjx0gbo0017o4l1tjiskgyo","tag_id":"cjdjx0gcf0029o4l174y33z7t","_id":"cjdjx0gch002go4l1vj1ksz61"},{"post_id":"cjdjx0gbq001ao4l1hpb6ra4p","tag_id":"cjdjx0gch002fo4l1c0do7g2t","_id":"cjdjx0gci002io4l18vlphk48"},{"post_id":"cjdjx0gbu001eo4l1347jwz59","tag_id":"cjdjx0gch002ho4l1kowdpbbc","_id":"cjdjx0gci002ko4l1pyscgdi0"},{"post_id":"cjdjx0gbw001ho4l1l9n3hr27","tag_id":"cjdjx0gci002jo4l1o9t810h0","_id":"cjdjx0gcj002mo4l1xsb2ums6"},{"post_id":"cjdjx0gby001jo4l1qytx9axk","tag_id":"cjdjx0gcj002lo4l1qy4a4rk9","_id":"cjdjx0gck002oo4l17bmmtdsq"},{"post_id":"cjdjx0gc3001po4l152w3tfr5","tag_id":"cjdjx0gca001wo4l1segglfii","_id":"cjdjx0gck002qo4l1wubxlvpb"},{"post_id":"cjdjx0gc7001to4l1n67odxrk","tag_id":"cjdjx0gch002fo4l1c0do7g2t","_id":"cjdjx0gck002ro4l1dj1bflby"}],"Tag":[{"name":"自定义view","_id":"cjdjx0gac0003o4l1jxujbjnu"},{"name":"paint","_id":"cjdjx0gak0008o4l1ecw6u9tl"},{"name":"canvas","_id":"cjdjx0gbh000xo4l19a6r6anq"},{"name":"touch","_id":"cjdjx0gbn0015o4l1eliv6dn7"},{"name":"git","_id":"cjdjx0gbu001do4l1eqz928oz"},{"name":"hexo","_id":"cjdjx0gc4001qo4l1thi1z2y2"},{"name":"java","_id":"cjdjx0gca001wo4l1segglfii"},{"name":"优化","_id":"cjdjx0gcc0021o4l1e1me430s"},{"name":"matrix","_id":"cjdjx0gce0025o4l11di5gtxh"},{"name":"网络编程","_id":"cjdjx0gcf0027o4l1dreg4qcw"},{"name":"recyclerview","_id":"cjdjx0gcf0029o4l174y33z7t"},{"name":"内存","_id":"cjdjx0gcg002bo4l14ojdmgdy"},{"name":"多线程","_id":"cjdjx0gch002fo4l1c0do7g2t"},{"name":"tip","_id":"cjdjx0gch002ho4l1kowdpbbc"},{"name":"动画","_id":"cjdjx0gci002jo4l1o9t810h0"},{"name":"view","_id":"cjdjx0gcj002lo4l1qy4a4rk9"}]}}