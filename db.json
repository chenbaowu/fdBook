{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/favicon.jpg","path":"images/favicon.jpg","modified":0,"renderable":0},{"_id":"source/images/fd.jpg","path":"images/fd.jpg","modified":0,"renderable":0},{"_id":"themes/yilia/source/main.b3331d.css","path":"main.b3331d.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.445162.js","path":"slider.445162.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.b3331d.js","path":"main.b3331d.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.8d90af.js","path":"mobile.8d90af.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","path":"fonts/iconfont.3a9902.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","path":"fonts/iconfont.6e162c.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","path":"fonts/iconfont.9abe9f.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","path":"fonts/iconfont.d0da7e.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/yilia/.babelrc","hash":"db600d40e93e6d8023737a65d58d3be7370e5e30","modified":1513236383455},{"_id":"themes/yilia/.eslintignore","hash":"ed9d8911ca08c3dd5072c48dd0be4d06f8897730","modified":1513236383457},{"_id":"themes/yilia/.editorconfig","hash":"daaa8757fac18f8735fadd0a37a42c06f421ca14","modified":1513236383456},{"_id":"themes/yilia/.eslintrc.js","hash":"303d25adf02ad65720e537a16a4a137d14bb755f","modified":1513236383458},{"_id":"themes/yilia/.gitignore","hash":"d5fc575329853ff620b50fc62ad4b18fa09a308a","modified":1513236383459},{"_id":"themes/yilia/.gitattributes","hash":"758cfbecfa7919e99abddf3297f37cde7e3d8d4e","modified":1513236383458},{"_id":"themes/yilia/README.md","hash":"8444a63c50d8a7e40bb3f1f10e549a60da94a21f","modified":1513236383461},{"_id":"themes/yilia/_config.yml","hash":"14a8138e9a5f4e4eb670edfe4c141bf60e9de514","modified":1513236383461},{"_id":"themes/yilia/package.json","hash":"ee6aa61f1cb89fd549e3e087c0232207a9c9ee30","modified":1513236383505},{"_id":"themes/yilia/webpack.config.js","hash":"da7657347109ddb4ab8602b219778117254677fe","modified":1513236383575},{"_id":"source/_posts/Paint.md","hash":"ef2b2ecf458b40de89ed92a7463e85be5053151a","modified":1513236383327},{"_id":"source/_posts/Paint_shader.md","hash":"6b0278052c496bb78261c282619a1476915de4f0","modified":1513236383329},{"_id":"source/_posts/Path.md","hash":"135b0a46292fc9c6b9a3f36a938acc4eb22983a9","modified":1513236383330},{"_id":"source/_posts/android-touch.md","hash":"ae1e68f1a91ec2730246b674f94273a5a46b4235","modified":1513236383332},{"_id":"source/_posts/canvas.md","hash":"16d036634366a8cf3ac090b442b35e79c4847d2e","modified":1513236383334},{"_id":"source/_posts/canvas_1.md","hash":"1321aad6b65b194c07dadc9e0a73ce65767e7680","modified":1513236383335},{"_id":"source/_posts/fdbook.md","hash":"e069156d3df09a7f8bdec4b0d097e0fdcbd36d49","modified":1513236383336},{"_id":"source/_posts/git.md","hash":"2aa0f03423a38f038cc493ef7991a5ca5c6669d6","modified":1513236383337},{"_id":"source/_posts/hello-world.md","hash":"ff2e40bd0ed8985dbcf66cd1f7df50704585a605","modified":1513236383339},{"_id":"source/_posts/http.md","hash":"74229647a707ae05c613cb9f988c16ffb35d12c8","modified":1513236383340},{"_id":"source/_posts/java-reference.md","hash":"44cba8853fb8a66be222411ed627a6d4a6d47808","modified":1513236383341},{"_id":"source/_posts/lock.md","hash":"c0395e46ea86853d093e920561070a507d3cdc62","modified":1513236383344},{"_id":"source/_posts/matrix.md","hash":"8430dd1de9ea405fd5816c0464b3163068f78fb8","modified":1513236383345},{"_id":"source/_posts/optimization-ui.md","hash":"0874ee9b855c90b49446a8e666879fa495f17f3e","modified":1513236383346},{"_id":"source/_posts/recyclerview.md","hash":"174c20169ae27746beedec7bee9137a5e4be4005","modified":1513236383348},{"_id":"source/_posts/recyclerviewANM.md","hash":"86f308bd1b652a88a17171cc9ed7f155d92c442a","modified":1513236383349},{"_id":"source/_posts/threadPoolExecutor.md","hash":"ed0f22d0ab62e06aa761e554c40c7e524b5d05cd","modified":1513236383351},{"_id":"source/_posts/tip.md","hash":"47114f9c33b2de75ce17062fe32820e20567482c","modified":1513236383352},{"_id":"source/_posts/view.md","hash":"9fa704a43f79a89275a602fbf2277aa0234970e1","modified":1513236383353},{"_id":"source/_posts/volatitle.md","hash":"961f37c958a3d14fae1d13daee06b4f655ee5536","modified":1513236383355},{"_id":"source/images/favicon.jpg","hash":"e3962f008c1a1fa5ca650d63dc926e15d9dfc484","modified":1513236383356},{"_id":"source/images/fd.jpg","hash":"37d29f858963c0ecb16944a4cf33288cc0d5b953","modified":1513236383357},{"_id":"themes/yilia/languages/default.yml","hash":"f26a34a7983d4bc17c65c7f0f14da598e62ce66d","modified":1513236383463},{"_id":"themes/yilia/languages/nl.yml","hash":"3d82ec703d0b3287739d7cb4750a715ae83bfcb3","modified":1513236383465},{"_id":"themes/yilia/languages/fr.yml","hash":"b4be1c1592a72012e48df2b3ec41cc9685573e50","modified":1513236383464},{"_id":"themes/yilia/languages/no.yml","hash":"ddf2035e920a5ecb9076138c184257d9f51896a7","modified":1513236383466},{"_id":"themes/yilia/languages/ru.yml","hash":"2a476b4c6e04900914c81378941640ac5d58a1f0","modified":1513236383467},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"b057f389c6713010f97d461e48ec959b0b6f3b44","modified":1513236383468},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"f5f0ca88185da7a8457760d84bf221781473bd7c","modified":1513236383469},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1513236383499},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1513236383500},{"_id":"themes/yilia/layout/index.ejs","hash":"ec498c6c0606acde997ce195dad97b267418d980","modified":1513236383500},{"_id":"themes/yilia/layout/layout.ejs","hash":"b471ab706d48e0be3f783eab1c94bf5878ef5a94","modified":1513236383501},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1513236383502},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1513236383503},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1513236383504},{"_id":"themes/yilia/source/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1513236383570},{"_id":"themes/yilia/source/slider.445162.js","hash":"a727717abfd319c5de84b425331f55aa709c9276","modified":1513236383574},{"_id":"themes/yilia/source-src/css.ejs","hash":"cf7eab48d626433120d1ef9697f719a359817018","modified":1513236383506},{"_id":"themes/yilia/source-src/script.ejs","hash":"28abac2426761d7e715b38aadd86ce6549c8ae77","modified":1513236383559},{"_id":"themes/yilia/source/main.b3331d.js","hash":"5fcc25cc1650f4ebe5d29ac9744f6d2d3a8be677","modified":1513236383572},{"_id":"themes/yilia/source/mobile.8d90af.js","hash":"0873195fea8d34db7233dab3591d41558fb7388b","modified":1513236383573},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"61c95c49baa2c1bfd99cf88c55ba205b44bf3d97","modified":1513236383471},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"edc0154b30a4127acda10297bec6aacf754b4ac4","modified":1513236383471},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a4eacc2bc1278095a0ef99f904b0634c78f980eb","modified":1513236383472},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"60351abd878c12b89761a91ff9e194f81443361f","modified":1513236383473},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"59564bb3371cf46a7ebc75383f8d81979c7bbba1","modified":1513236383474},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"f8a42263edeeb3ccf6115cea5f96f551ed1e76e5","modified":1513236383478},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"bac65acc10b1c5bae7ea1655e2d7839370c33110","modified":1513236383479},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"1ccc627d7697e68fddc367c73ac09920457e5b35","modified":1513236383480},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"12ca7d8dba56bc767b9309dda9526dcbaffc1614","modified":1513236383481},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"b69855e07b65117769adc515cb64b803932068c9","modified":1513236383482},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"e2b3f2b3631ef211a4d98d11f0da2d285340f10e","modified":1513236383483},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"11550a418921d330e6553be0569a94ab5a217967","modified":1513236383484},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"ccec1fc70f021cb50ac85b524e7949878ab93a18","modified":1513236383485},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"0ffcb251b79e8a920c9b4cb6bb7a96a808816165","modified":1513236383496},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"cc1c39903aed0a0601d104238d2bbd13ad2a36f3","modified":1513236383497},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1513236383560},{"_id":"themes/yilia/source/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1513236383561},{"_id":"themes/yilia/source/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1513236383563},{"_id":"themes/yilia/source/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1513236383564},{"_id":"themes/yilia/source/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1513236383565},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1513236383566},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1513236383568},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1513236383568},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1513236383569},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"29ba600e98ed55f7af4ade8038272c84cba21188","modified":1513236383507},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"ce227b6f5a9af194fd5d455200630f32c05e151f","modified":1513236383508},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"d6a7dd88404b383b5b94e4c7ec675a410c41f3cc","modified":1513236383509},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"f7388f5c11370ef462f7cb913d8f72edf24ecaf9","modified":1513236383510},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"1577a2336b3ad122f49f60dff2bc1a97d4e7b18b","modified":1513236383511},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"8f82fe898ba1c1bd00c24a7d8270feddc7eba3bc","modified":1513236383512},{"_id":"themes/yilia/source-src/css/article.scss","hash":"55d082fec4c6bb341725567acaa29ce37d50320a","modified":1513236383514},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"2d1c70bb606c0d87e4f68ec2e600e08b27f32b99","modified":1513236383515},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"768e77b775923c53f974a15fe9ab04d0e05198a5","modified":1513236383521},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1513236383526},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1513236383527},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"f53ea8270752b5919ec5d79224d22af91f2eda12","modified":1513236383528},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"40e5aa5056dc0b3b9f51c5b387370b612e265d4e","modified":1513236383529},{"_id":"themes/yilia/source-src/css/left.scss","hash":"80dac621e43581a254d0152d5df901e4d0b01c09","modified":1513236383534},{"_id":"themes/yilia/source-src/css/main.scss","hash":"1bc3240d693f190f86bf5e258cc5846e09be9ec1","modified":1513236383536},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"19f10fd2f0c3377aa4b165b3c2291ecf86dd9351","modified":1513236383537},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"7c24ea86d95c86b82337177559d78ce56d8912e0","modified":1513236383538},{"_id":"themes/yilia/source-src/css/page.scss","hash":"244c4d75c375978ff9edb74acc68825e63c6b235","modified":1513236383539},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"a557a9ed244c82b8b71e9da9de3339d92783499f","modified":1513236383540},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"2495f7e4e3b055735c531f944b5f40a118a351ec","modified":1513236383541},{"_id":"themes/yilia/source-src/css/share.scss","hash":"9d6f6884f40c191882e56a1e1e1192400944a515","modified":1513236383542},{"_id":"themes/yilia/source-src/css/social.scss","hash":"7c4c54bcc4cd0bd69162745ae2a2357dcc54f5cd","modified":1513236383543},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"399744e98e7c67939ed9b23c2670d8baad044eda","modified":1513236383544},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"915c93edd67c5326695cc7dc84b14c5f154dbcc8","modified":1513236383545},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"6932c642bf8191768d7090982a91c8c1f1c4ed1e","modified":1513236383546},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"b81cedbe31accca82e597801186911a7b5e6841c","modified":1513236383547},{"_id":"themes/yilia/source-src/js/Q.js","hash":"e56d9710afa79b31ca6b9fbd845f6d1895f5214b","modified":1513236383549},{"_id":"themes/yilia/source-src/js/anm.js","hash":"d18f6276a352b871390a4112d479b9e58b8cdbbe","modified":1513236383550},{"_id":"themes/yilia/source-src/js/browser.js","hash":"4dc04845cf27f350922b63f1813a9c82e6e33b05","modified":1513236383551},{"_id":"themes/yilia/source-src/js/fix.js","hash":"0b434b658abad220459b1e3ee962ebfa4f8f88ca","modified":1513236383552},{"_id":"themes/yilia/source-src/js/main.js","hash":"93ca570a646c6087821d7b14cb1646bb2a0274f4","modified":1513236383553},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"461c08ffcbc724d74ec7e0ff38e171eefe0f89fd","modified":1513236383553},{"_id":"themes/yilia/source-src/js/report.js","hash":"57680f9a23bd0a1eaafd64ae08cc33e20627ab15","modified":1513236383554},{"_id":"themes/yilia/source-src/js/share.js","hash":"d4ccff8266c37363b3904226f5d035b7db882c61","modified":1513236383555},{"_id":"themes/yilia/source-src/js/slider.js","hash":"707842efee006e3ea9b6765d7460f4ef4f08e41f","modified":1513236383556},{"_id":"themes/yilia/source-src/js/util.js","hash":"3bcdeb95072b85600874424e6929e3e22cfddaa0","modified":1513236383557},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"3e0fd4479a40ddbd1571c6c953df7e23637b61f5","modified":1513236383558},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"eaa2c1cb8165dee6fb10127a0de8dcfcd1799c2e","modified":1513236383495},{"_id":"themes/yilia/layout/_partial/comments/disqus.ejs","hash":"2e5cad68bc59190b4158f4ab1879a222ca49a0d2","modified":1513236383475},{"_id":"themes/yilia/layout/_partial/comments/duoshuo.ejs","hash":"1f9ac8182fe0b867a8f1988888336c40c25894cd","modified":1513236383476},{"_id":"themes/yilia/layout/_partial/comments/youyan.ejs","hash":"0c462bc8920097320812908ef689be3e842287fc","modified":1513236383477},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"f75b236818b6c0ec0e5e6c12a517825d6230d756","modified":1513236383486},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"0a3c55e2660a5c4c83a161fae21a4c0b7e6e5f72","modified":1513236383487},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"aae96de18d48cd3b9b7bf6fed0100e15b53cca97","modified":1513236383488},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"b6a97043f9ec37e571aacacfedcda1d4d75e3c7c","modified":1513236383490},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"f6b4c4eaafb5ac386273354b5f64a26139b7a3b0","modified":1513236383489},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"06a2dd18ac9a43fbc9a59c61e6f795f9326e9927","modified":1513236383491},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2c4e4ca36c9bb4318506c38aca7127f1f44d827f","modified":1513236383492},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"d4a460a35e2112d0c7414fd5e19b3a16093f1caf","modified":1513236383492},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"68d48a415ac4e675e73f660ee27bbaa8a06b1c11","modified":1513236383493},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"1834c3ed8560716e63bb3a50be94cac87fbbeaf3","modified":1513236383516},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"262ffcd88775080b7f511db37f58d2bcb1b2bfc7","modified":1513236383517},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"91db061c9c17628291a005e5bd4936cf9d35a6c4","modified":1513236383518},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"398a49913b4a47d928103562b1ce94520be4026a","modified":1513236383519},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"6e75bdaa46de83094ba0873099c6e7d656a22453","modified":1513236383520},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1513236383523},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1513236383524},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1513236383525},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1513236383526},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1513236383531},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1513236383532},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1513236383533},{"_id":"public/content.json","hash":"5657716fdd848219b583645929d4940b32ba4dde","modified":1513237107368},{"_id":"public/2017/09/23/android-touch/index.html","hash":"f811022909126b002c34e4570f6815ea29f45b7e","modified":1513237107713},{"_id":"public/2017/09/17/tip/index.html","hash":"5b5134d18eb2d19a6342322fbc42812b1b1ce4bc","modified":1513237107713},{"_id":"public/2017/08/27/Path/index.html","hash":"8038128c187de57d896e3c363723c2b1e36b3955","modified":1513237107713},{"_id":"public/2017/08/27/optimization-ui/index.html","hash":"f0cc1bba96f96d5efa33c63cff933604ddda5db0","modified":1513237107713},{"_id":"public/2017/06/04/recyclerviewANM/index.html","hash":"8aceb9ca2b94ccb23a536b95db420dd0fc417aea","modified":1513237107713},{"_id":"public/2017/06/03/recyclerview/index.html","hash":"8ac04aa0b824d92fa09b5cd049843781ef97d238","modified":1513237107714},{"_id":"public/2017/05/22/canvas_1/index.html","hash":"e2e6a25e8eaf0d01eb7251fa7f5d5dec0e37e157","modified":1513237107714},{"_id":"public/2017/05/22/Paint_shader/index.html","hash":"b409e023e738ec1d77de786bf31d87ef8ed473ca","modified":1513237107714},{"_id":"public/2017/05/14/Paint/index.html","hash":"aadc3a582a1715be032e51c038bf453532c3aef4","modified":1513237107714},{"_id":"public/2017/05/14/canvas/index.html","hash":"c86a9b031c16b74389bce4fa5e429dfc4944f525","modified":1513237107714},{"_id":"public/2017/05/14/view/index.html","hash":"a778d3fe84e745ec2d455d556c044d4eb4603f71","modified":1513237107714},{"_id":"public/2017/05/13/matrix/index.html","hash":"fdca130af2eb4070db82585ce5f1230a145c2ca9","modified":1513237107714},{"_id":"public/2017/05/13/git/index.html","hash":"5ca9a2d7f3c448aac005cc8c02cae570f97f058b","modified":1513237107714},{"_id":"public/2017/05/10/http/index.html","hash":"c36e7b8865a14519011a3e8662354b5610e81094","modified":1513237107714},{"_id":"public/2017/05/10/threadPoolExecutor/index.html","hash":"b0aba7fea1e9fa52986d2cad2cc69234928b3dd7","modified":1513237107714},{"_id":"public/2017/05/10/lock/index.html","hash":"bc37c4ae570057f7f371c6f2edef4194deda3994","modified":1513237107714},{"_id":"public/2017/05/10/volatitle/index.html","hash":"b70e828048772b459f0a9db95649a3bd7cfacd68","modified":1513237107715},{"_id":"public/2017/05/09/fdbook/index.html","hash":"d2c5414158e594468fc23a0ea34444fbbec6b404","modified":1513237107715},{"_id":"public/2017/05/09/java-reference/index.html","hash":"c3980e9ba864f6698bda4715d032b420fa3e087f","modified":1513237107715},{"_id":"public/2017/05/09/hello-world/index.html","hash":"9d670684dc354081c0a8e73e2a765948c3d84ce3","modified":1513237107715},{"_id":"public/archives/index.html","hash":"b18e1a773f9a0286ab6c5a4887c85c33c82f1c96","modified":1513237107715},{"_id":"public/archives/page/2/index.html","hash":"5742df42cd83ccc21eb4e5ee89dffef45683cdfe","modified":1513237107715},{"_id":"public/archives/page/3/index.html","hash":"aff8cdb17d50126db58f844e36cfbc7ea7091d29","modified":1513237107715},{"_id":"public/archives/page/4/index.html","hash":"86e52861780e824f780728f06be3e3bbb71c26b4","modified":1513237107715},{"_id":"public/archives/2017/index.html","hash":"b60d6afb51958b7571aafa60f788e0f8b3b8315c","modified":1513237107716},{"_id":"public/archives/2017/page/2/index.html","hash":"5d4b0fe1a714e40656cd522fb61fc276ed0329bf","modified":1513237107716},{"_id":"public/archives/2017/page/3/index.html","hash":"abe70a5700a7f4478b98ad32cccf10ab393e0bd0","modified":1513237107716},{"_id":"public/archives/2017/page/4/index.html","hash":"a6bd632817fcb172913d556ba8fb105f8497003f","modified":1513237107716},{"_id":"public/archives/2017/05/index.html","hash":"41b0c0402e7e7117eefd6d254aa5e38bedb569b2","modified":1513237107716},{"_id":"public/archives/2017/05/page/2/index.html","hash":"5be51d449c9722837b898fe839891ce21f41c170","modified":1513237107716},{"_id":"public/archives/2017/05/page/3/index.html","hash":"26022fca4d42afe1e32861c768229ddaa75c6f7c","modified":1513237107716},{"_id":"public/archives/2017/06/index.html","hash":"5ee626812de5a3b8353efa898e20596ed17f34d8","modified":1513237107716},{"_id":"public/archives/2017/08/index.html","hash":"92a25ca8b001d77b5c0b98c1adc86f1a9fe36c75","modified":1513237107716},{"_id":"public/archives/2017/09/index.html","hash":"79f9c73ac0abf0b5ee85562d4c6bf8019ee43211","modified":1513237107717},{"_id":"public/categories/android/index.html","hash":"748f6a0e66186d1b36ec2dfd1d025a5c4b67700a","modified":1513237107717},{"_id":"public/categories/android/page/2/index.html","hash":"e3d9d95f333ae1fc5eee0599862d1d025c6f6bf6","modified":1513237107717},{"_id":"public/categories/android/page/3/index.html","hash":"fa3f2737a1916db6a255cf78681c5cc12cc40bfb","modified":1513237107717},{"_id":"public/categories/fdbook/index.html","hash":"a78ce36f3f0416d23c4c700bc6bf347cb0ba7e10","modified":1513237107717},{"_id":"public/categories/多学/index.html","hash":"16fd6a7f36c4e3fe637da38a5e4c55d6686ebb32","modified":1513237107717},{"_id":"public/tags/自定义view/index.html","hash":"7da8a490246cdf75341c6bc80ed388fb65d80aa4","modified":1513237107718},{"_id":"public/tags/自定义view/page/2/index.html","hash":"256cf17ffd9892e85ec67d659b91d32adf68cd03","modified":1513237107718},{"_id":"public/tags/paint/index.html","hash":"5c55a0c378806e75d314b29cc76caa69bddf713c","modified":1513237107718},{"_id":"public/tags/touch/index.html","hash":"6b834f86bec6555ce6c4bd9ff4598efa52518cc7","modified":1513237107718},{"_id":"public/tags/canvas/index.html","hash":"a61af3ba5dbf36df0e129ce6343cdfa1c0530d54","modified":1513237107718},{"_id":"public/tags/hexo/index.html","hash":"be19792d1a9c2a1f45b9ef49b7dd8b797f45d8c4","modified":1513237107718},{"_id":"public/tags/git/index.html","hash":"f5b12e493ef470445637393478b81779b30e181a","modified":1513237107718},{"_id":"public/tags/网络编程/index.html","hash":"b4046382cf9b488525310fac4f095d4fa80361f5","modified":1513237107718},{"_id":"public/tags/java/index.html","hash":"ba3d3826997b6565389e19b5d16daad8571541ef","modified":1513237107718},{"_id":"public/tags/多线程/index.html","hash":"192cac795a7373adf0ac1bb2fafb470b7cbec72d","modified":1513237107719},{"_id":"public/tags/matrix/index.html","hash":"043b829b6521f83ce1e5dc5f047f8c6145827a2b","modified":1513237107719},{"_id":"public/tags/优化/index.html","hash":"7092dff7833a2cbf698426c095c3f536ea22189e","modified":1513237107719},{"_id":"public/tags/tip/index.html","hash":"dd00760fb8699d39cc77efae0eec39189a4be9ac","modified":1513237107719},{"_id":"public/index.html","hash":"b2c0e458efc0088700bd5191fc91fa44368dc6fb","modified":1513237107719},{"_id":"public/tags/recyclerview/index.html","hash":"dd4830744e974e18de890e64c6ed011ceba872bf","modified":1513237107719},{"_id":"public/page/2/index.html","hash":"27238b054f1238f39ec05a2c015b96e2436559d3","modified":1513237107719},{"_id":"public/page/3/index.html","hash":"b4f7d49ed50d88e0a4d982c6c2e05b587e78dbf4","modified":1513237107719},{"_id":"public/page/4/index.html","hash":"eaab80d93cb9ababa077de0de54b58e4f731e0d8","modified":1513237107719},{"_id":"public/images/fd.jpg","hash":"37d29f858963c0ecb16944a4cf33288cc0d5b953","modified":1513237107748},{"_id":"public/images/favicon.jpg","hash":"e3962f008c1a1fa5ca650d63dc926e15d9dfc484","modified":1513237107748},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1513237107748},{"_id":"public/fonts/iconfont.3a9902.eot","hash":"51d4e8d333ae7867915037983ea5d4b2ad971930","modified":1513237107748},{"_id":"public/fonts/iconfont.6e162c.woff","hash":"709373d566526ad4bdb330757a3915e3c5e37b66","modified":1513237107748},{"_id":"public/fonts/iconfont.9abe9f.svg","hash":"2853b9d8fecd83e26eb032891785afcdaf8b14e2","modified":1513237107748},{"_id":"public/fonts/iconfont.d0da7e.ttf","hash":"53ea5a5027a2fab93bcdad18cad6dc5f1b728726","modified":1513237107748},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1513237107748},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1513237107749},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1513237107749},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1513237107749},{"_id":"public/main.b3331d.css","hash":"7d0162a4618e8026bd23779f3120c09c83197b9f","modified":1513237107756},{"_id":"public/main.b3331d.js","hash":"0e98e3674c7687ae4ff7bdcecb05e15434c46e0d","modified":1513237107756},{"_id":"public/slider.445162.js","hash":"e21c3c2cf663d7a4fb0d77f43ae1a148553a7cca","modified":1513237107756},{"_id":"public/mobile.8d90af.js","hash":"cf2ab659138db5abc70e3e0d7bc64f50d48e834d","modified":1513237107756}],"Category":[{"name":"android","_id":"cjb66awcv0002kku00505utbh"},{"name":"fdbook","_id":"cjb66awda000jkku05rsdatt6"},{"name":"多学","_id":"cjb66awdd000rkku0nbsm76hj"}],"Data":[],"Page":[],"Post":[{"title":"Paint shader","date":"2017-05-22T13:49:00.000Z","_content":"\n## BitmapShader\n``` bash\n// 3种模式\nShader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充\nShader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺\nShader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺\n```\n<!-- more -->\n\n直接上例子,画一个简单的圆形bitmap\n``` bash\nprivate void init() {\n    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);\n    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式\n\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap\n    mPaint.setShader(shader);\n}\n\n@Override\nprotected void onDraw(Canvas canvas) {\n    super.onDraw(canvas);\n    float x = getWidth() / 2;\n    float y = getHeight() / 2;\n    float radius = Math.min(getWidth(), getHeight()) / 2;\n    canvas.drawCircle(x, y, radius,mPaint); \n}\n```\n![](http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分\n\n##  LinearGradient 线性渐变\n``` bash\n/*\nx0 绘制x轴起始点\ny0 绘制y轴起始点\nx1 绘制x轴结束点\ny1 绘制y轴结束点\ncolor0 起始颜色\ncolor1 结束颜色\ntile 模式\n*/\nLinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);\nmPaint.setShader(shader);\n\n\n/*\ncolors 颜色int值数组\npostions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关\n*/\nfinal int [] colors =  new int [] {Color.MAGENTA,Color.CYAN,Color.RED};\nfinal float [] positions = new float[]{0f,0.50f,1f};\nfinal LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);\n```\n\n## RadialGradient 光束渐变\n``` bash\n/*\ncenterX 渐变中心点的X轴坐标\ncenterY 渐变中心点的Y轴坐标\nradius 渐变区域的半径\n*/\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);\n\nfinal int[] colors = new int[]{Color.YELLOW,Color.BLUE ,Color.RED};\nfinal float[] positions = new float[]{0f, 0.5f ,1f};\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);\n// colors中的元素个数要和positions中的元素个数相等\n```\n\n## SweepGradient 梯度渐变\n``` bash\nSweepGradient(float cx, float cy, int color0, int color1) \nSweepGradient(float cx, float cy, int colors[], float positions[])\n//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转\n```\n\n## 6. ComposeShader 混合渐变\n``` bash\n// 需要关闭硬件加速\nComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)\nComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)\n\n构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode\n前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果\n```","source":"_posts/Paint_shader.md","raw":"---\ntitle: Paint shader\ndate: 2017-05-22 21:49:00\ncategories: android\ntags: [自定义view,paint]\n---\n\n## BitmapShader\n``` bash\n// 3种模式\nShader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充\nShader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺\nShader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺\n```\n<!-- more -->\n\n直接上例子,画一个简单的圆形bitmap\n``` bash\nprivate void init() {\n    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);\n    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式\n\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap\n    mPaint.setShader(shader);\n}\n\n@Override\nprotected void onDraw(Canvas canvas) {\n    super.onDraw(canvas);\n    float x = getWidth() / 2;\n    float y = getHeight() / 2;\n    float radius = Math.min(getWidth(), getHeight()) / 2;\n    canvas.drawCircle(x, y, radius,mPaint); \n}\n```\n![](http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分\n\n##  LinearGradient 线性渐变\n``` bash\n/*\nx0 绘制x轴起始点\ny0 绘制y轴起始点\nx1 绘制x轴结束点\ny1 绘制y轴结束点\ncolor0 起始颜色\ncolor1 结束颜色\ntile 模式\n*/\nLinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);\nmPaint.setShader(shader);\n\n\n/*\ncolors 颜色int值数组\npostions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关\n*/\nfinal int [] colors =  new int [] {Color.MAGENTA,Color.CYAN,Color.RED};\nfinal float [] positions = new float[]{0f,0.50f,1f};\nfinal LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);\n```\n\n## RadialGradient 光束渐变\n``` bash\n/*\ncenterX 渐变中心点的X轴坐标\ncenterY 渐变中心点的Y轴坐标\nradius 渐变区域的半径\n*/\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);\n\nfinal int[] colors = new int[]{Color.YELLOW,Color.BLUE ,Color.RED};\nfinal float[] positions = new float[]{0f, 0.5f ,1f};\nfinal RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);\n// colors中的元素个数要和positions中的元素个数相等\n```\n\n## SweepGradient 梯度渐变\n``` bash\nSweepGradient(float cx, float cy, int color0, int color1) \nSweepGradient(float cx, float cy, int colors[], float positions[])\n//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转\n```\n\n## 6. ComposeShader 混合渐变\n``` bash\n// 需要关闭硬件加速\nComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)\nComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)\n\n构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode\n前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果\n```","slug":"Paint_shader","published":1,"updated":"2017-12-14T07:26:23.329Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awcm0000kku04qubdsaw","content":"<h2 id=\"BitmapShader\"><a href=\"#BitmapShader\" class=\"headerlink\" title=\"BitmapShader\"></a>BitmapShader</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 3种模式</div><div class=\"line\">Shader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充</div><div class=\"line\">Shader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺</div><div class=\"line\">Shader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>直接上例子,画一个简单的圆形bitmap<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</div><div class=\"line\">    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class=\"line\">    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);</div><div class=\"line\">    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式</div><div class=\"line\">\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap</div><div class=\"line\">    mPaint.setShader(shader);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    super.onDraw(canvas);</div><div class=\"line\">    <span class=\"built_in\">float</span> x = getWidth() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> y = getHeight() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> radius = Math.min(getWidth(), getHeight()) / 2;</div><div class=\"line\">    canvas.drawCircle(x, y, radius,mPaint); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分</p>\n<h2 id=\"LinearGradient-线性渐变\"><a href=\"#LinearGradient-线性渐变\" class=\"headerlink\" title=\"LinearGradient 线性渐变\"></a>LinearGradient 线性渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">x0 绘制x轴起始点</div><div class=\"line\">y0 绘制y轴起始点</div><div class=\"line\">x1 绘制x轴结束点</div><div class=\"line\">y1 绘制y轴结束点</div><div class=\"line\">color0 起始颜色</div><div class=\"line\">color1 结束颜色</div><div class=\"line\">tile 模式</div><div class=\"line\">*/</div><div class=\"line\">LinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);</div><div class=\"line\">mPaint.setShader(shader);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">colors 颜色int值数组</div><div class=\"line\">postions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关</div><div class=\"line\">*/</div><div class=\"line\">final int [] colors =  new int [] &#123;Color.MAGENTA,Color.CYAN,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span> [] positions = new <span class=\"built_in\">float</span>[]&#123;0f,0.50f,1f&#125;;</div><div class=\"line\">final LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);</div></pre></td></tr></table></figure>\n<h2 id=\"RadialGradient-光束渐变\"><a href=\"#RadialGradient-光束渐变\" class=\"headerlink\" title=\"RadialGradient 光束渐变\"></a>RadialGradient 光束渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">centerX 渐变中心点的X轴坐标</div><div class=\"line\">centerY 渐变中心点的Y轴坐标</div><div class=\"line\">radius 渐变区域的半径</div><div class=\"line\">*/</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);</div><div class=\"line\"></div><div class=\"line\">final int[] colors = new int[]&#123;Color.YELLOW,Color.BLUE ,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span>[] positions = new <span class=\"built_in\">float</span>[]&#123;0f, 0.5f ,1f&#125;;</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);</div><div class=\"line\">// colors中的元素个数要和positions中的元素个数相等</div></pre></td></tr></table></figure>\n<h2 id=\"SweepGradient-梯度渐变\"><a href=\"#SweepGradient-梯度渐变\" class=\"headerlink\" title=\"SweepGradient 梯度渐变\"></a>SweepGradient 梯度渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int color0, int color1) </div><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int colors[], <span class=\"built_in\">float</span> positions[])</div><div class=\"line\">//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转</div></pre></td></tr></table></figure>\n<h2 id=\"6-ComposeShader-混合渐变\"><a href=\"#6-ComposeShader-混合渐变\" class=\"headerlink\" title=\"6. ComposeShader 混合渐变\"></a>6. ComposeShader 混合渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 需要关闭硬件加速</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)</div><div class=\"line\"></div><div class=\"line\">构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode</div><div class=\"line\">前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"BitmapShader\"><a href=\"#BitmapShader\" class=\"headerlink\" title=\"BitmapShader\"></a>BitmapShader</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 3种模式</div><div class=\"line\">Shader.TileMode.CLAMP：当图片小于绘制尺寸时要进行边界拉伸来填充</div><div class=\"line\">Shader.TileMode.REPEAT：当图片小于绘制尺寸时重复平铺</div><div class=\"line\">Shader.TileMode.MIRROR：当图片小于绘制尺寸时镜像平铺</div></pre></td></tr></table></figure>","more":"<p>直接上例子,画一个简单的圆形bitmap<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void <span class=\"function\"><span class=\"title\">init</span></span>() &#123;</div><div class=\"line\">    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);</div><div class=\"line\">    final Bitmap mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.test);</div><div class=\"line\">    final BitmapShader shader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); // 分x轴，Y轴的重复模式</div><div class=\"line\">\t//  shader.setLocalMatrix(Matrix); // 可以用Matrix来缩放bitmap</div><div class=\"line\">    mPaint.setShader(shader);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    super.onDraw(canvas);</div><div class=\"line\">    <span class=\"built_in\">float</span> x = getWidth() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> y = getHeight() / 2;</div><div class=\"line\">    <span class=\"built_in\">float</span> radius = Math.min(getWidth(), getHeight()) / 2;</div><div class=\"line\">    canvas.drawCircle(x, y, radius,mPaint); </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/2086682-417b1887d27cd820.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<p>实际上就是把bitmap绑定在paint上，通过canvas画出你想要的部分</p>\n<h2 id=\"LinearGradient-线性渐变\"><a href=\"#LinearGradient-线性渐变\" class=\"headerlink\" title=\"LinearGradient 线性渐变\"></a>LinearGradient 线性渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">x0 绘制x轴起始点</div><div class=\"line\">y0 绘制y轴起始点</div><div class=\"line\">x1 绘制x轴结束点</div><div class=\"line\">y1 绘制y轴结束点</div><div class=\"line\">color0 起始颜色</div><div class=\"line\">color1 结束颜色</div><div class=\"line\">tile 模式</div><div class=\"line\">*/</div><div class=\"line\">LinearGradient shader = new LinearGradient(0, 0, 600, 600, Color.RED, Color.YELLOW, Shader.TileMode.REPEAT);</div><div class=\"line\">mPaint.setShader(shader);</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">/*</div><div class=\"line\">colors 颜色int值数组</div><div class=\"line\">postions 数组中的值有效范围是0f~1f，渐变结束所在区域的比例，1f的结束位置，与x1,y1有关</div><div class=\"line\">*/</div><div class=\"line\">final int [] colors =  new int [] &#123;Color.MAGENTA,Color.CYAN,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span> [] positions = new <span class=\"built_in\">float</span>[]&#123;0f,0.50f,1f&#125;;</div><div class=\"line\">final LinearGradient shader = new LinearGradient(0, 0, 600, 600,colors ,positions ,Shader.TileMode.REPEAT);</div></pre></td></tr></table></figure>\n<h2 id=\"RadialGradient-光束渐变\"><a href=\"#RadialGradient-光束渐变\" class=\"headerlink\" title=\"RadialGradient 光束渐变\"></a>RadialGradient 光束渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">/*</div><div class=\"line\">centerX 渐变中心点的X轴坐标</div><div class=\"line\">centerY 渐变中心点的Y轴坐标</div><div class=\"line\">radius 渐变区域的半径</div><div class=\"line\">*/</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,Color.RED,Color.YELLOW, Shader.TileMode.CLAMP);</div><div class=\"line\"></div><div class=\"line\">final int[] colors = new int[]&#123;Color.YELLOW,Color.BLUE ,Color.RED&#125;;</div><div class=\"line\">final <span class=\"built_in\">float</span>[] positions = new <span class=\"built_in\">float</span>[]&#123;0f, 0.5f ,1f&#125;;</div><div class=\"line\">final RadialGradient shader = new RadialGradient(300f,300f,300,colors,positions, Shader.TileMode.CLAMP);</div><div class=\"line\">// colors中的元素个数要和positions中的元素个数相等</div></pre></td></tr></table></figure>\n<h2 id=\"SweepGradient-梯度渐变\"><a href=\"#SweepGradient-梯度渐变\" class=\"headerlink\" title=\"SweepGradient 梯度渐变\"></a>SweepGradient 梯度渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int color0, int color1) </div><div class=\"line\">SweepGradient(<span class=\"built_in\">float</span> cx, <span class=\"built_in\">float</span> cy, int colors[], <span class=\"built_in\">float</span> positions[])</div><div class=\"line\">//cx,cy是旋转点的x,y轴坐标，渐变过程总是顺时针方向旋转</div></pre></td></tr></table></figure>\n<h2 id=\"6-ComposeShader-混合渐变\"><a href=\"#6-ComposeShader-混合渐变\" class=\"headerlink\" title=\"6. ComposeShader 混合渐变\"></a>6. ComposeShader 混合渐变</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 需要关闭硬件加速</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, PorterDuff.Mode mode)</div><div class=\"line\">ComposeShader(Shader shaderA, Shader shaderB, Xfermode mode)</div><div class=\"line\"></div><div class=\"line\">构造方法中，前两个参数相同，都是需要一个着色器，差别在于第三个参数。第一个构造方法需要一个PorterDuff.Mode，而第二个构造构造方法需要PorterDuffXfermode</div><div class=\"line\">前面的三种的渐变，都是一种单一的渐变，ComposeShader可以把前面两种渐变混合进一种渐变效果</div></pre></td></tr></table></figure>"},{"title":"Path","date":"2017-08-27T07:13:51.000Z","_content":"\n## whant is path\n\nPath封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，\n也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)\n\n<!-- more -->\n\n## api\n\n|作用\t\t  \t\t|相关方法\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t| :----: |\n|移动起点\t  \t\t|moveTo\t\t        |移动下一次操作的起点位置\n|设置终点\t  \t\t|setLastPoint\t\t|重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同\n|连接直线\t  \t\t|lineTo\t\t\t\t|添加上一个点到当前点之间的直线到Path\n|闭合路径\t  \t\t|close\t\t\t\t|连接第一个点连接到最后一个点，形成一个闭合区域\n|添加内容\t  \t\t|addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo  |添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)\n|是否为空\t  \t\t|isEmpty\t\t\t|判断Path是否为空\n|是否为矩形\t  \t\t|isRect\t\t\t\t|判断path是否是一个矩形\n|替换路径\t  \t\t|set\t\t\t\t|用新的路径替换到当前路径所有内容\n|偏移路径\t  \t\t|offset\t\t\t\t|对当前路径之前的操作进行偏移(不会影响之后的操作)\n|贝塞尔曲线\t  \t\t|quadTo, cubicTo\t|分别为二次和三次贝塞尔曲线的方法\n|rXxx方法\t  \t\t|rMoveTo, rLineTo, rQuadTo, rCubicTo\t\t\t\t\t\t\t\t|不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)\n|填充模式\t  \t\t|setFillType, getFillType, isInverseFillType, toggleInverseFillType |设置,获取,判断和切换填充模式\n|提示方法\t  \t\t|incReserve\t\t\t|提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)\n|布尔操作(API19)\t|op\t\t\t\t\t|对两个Path进行布尔运算(即取交集、并集等操作)\n|计算边界\t        |computeBounds\t\t|计算Path的边界\n|重置路径\t        |reset, rewind\t\t|清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType\n|矩阵操作\t\t\t|transform\t\t\t|矩阵变换\n\n## moveTo 和 setLastPoint\n\nmoveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点\n\n## addXxx与arcTo\n\n``` bash\n// 第一类(基本形状)\n// 圆形\npublic void addCircle (float x, float y, float radius, Path.Direction dir)\n// 椭圆\npublic void addOval (RectF oval, Path.Direction dir)\n// 矩形\npublic void addRect (float left, float top, float right, float bottom, Path.Direction dir)\npublic void addRect (RectF rect, Path.Direction dir)\n// 圆角矩形\npublic void addRoundRect (RectF rect, float[] radii, Path.Direction dir)\npublic void addRoundRect (RectF rect, float rx, float ry, Path.Direction dir) \n\n// 第二类(Path)\n// path\npublic void addPath (Path src)\npublic void addPath (Path src, float dx, float dy)\npublic void addPath (Path src, Matrix matrix)\n\naddArc\t添加一个圆弧到path\t直接添加一个圆弧到path中\narcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点\n```\n\n## rXxx\n\nrXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。\n比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ， \n使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示\n\n## 贝塞尔曲线\n\n数据点\t确定曲线的起始和结束位置\n控制点\t确定曲线的弯曲程度\n\n一阶曲线其实就是前面讲解过的lineTo\n二阶曲线对应的方法是quadTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835406060)\n三阶曲线对应的方法是cubicTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835375418)\n\n## PathMeasure\n\n### api\n\n| 返回值\t|方法名\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|释义\n| --------  | \t-----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n| void\t\t|setPath(Path path, boolean forceClosed)\t\t\t\t\t\t\t\t\t|关联一个Path\n| boolean\t|isClosed()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|是否闭合\n| float\t\t|getLength()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|获取Path的长度\n| boolean\t|nextContour()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|跳转到下一个轮廓\n| boolean\t|getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)\t|截取片段\n| boolean\t|getPosTan(float distance, float[] pos, float[] tan)\t\t\t\t\t\t|获取指定长度的位置坐标及该点切线值\n| boolean\t|getMatrix(float distance, Matrix matrix, int flags)\t\t\t\t\t\t|获取指定长度的位置坐标及该点Matrix\n\n### 构造函数\n\n``` bash\nPathMeasure ()\nPathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 true,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)\n```\n\n### getSegment\n\n``` bash\nboolean getSegment (float startD, float stopD, Path dst, boolean startWithMoveTo)\n```\n\n|参数\t\t\t\t|作用\t\t\t\t\t\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t\t\t\t\t| :----: |\n|返回值(boolean)\t|判断截取是否成功\t\t\t\t\t|true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容\n|startD\t\t\t\t|开始截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|stopD\t\t\t\t|结束截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|dst\t\t\t\t|截取的 Path 将会添加到 dst 中\t\t|注意: 是添加，而不是替换\n|startWithMoveTo\t|起始点是否使用 moveTo\t\t\t\t|用于保证截取的 Path 第一个点位置不变\n\n### nextContour\n\n我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，\n而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。\n\n## FillType \n\n|模式\t\t\t\t|简介\n| --------  \t\t| :----: |  \t\t\t\t\t\t\n|EVEN_ODD\t\t\t|奇偶规则\n|INVERSE_EVEN_ODD\t|反奇偶规则\n|WINDING\t\t\t|非零环绕数规则\n|INVERSE_WINDING\t|反非零环绕数规则\n\n## 布尔操作\n\n|逻辑名称\t\t\t\t|类比\t\t|说明\t\n| --------  \t\t\t| \t-----:  | :----: |\n|DIFFERENCE\t\t\t\t|差集\t\t|Path1中减去Path2后剩下的部分\t\n|REVERSE_DIFFERENCE\t\t|差集\t\t|Path2中减去Path1后剩下的部分\t\n|INTERSECT\t\t\t\t|交集\t\t|Path1与Path2相交的部分\t\n|UNION\t\t\t\t\t|并集\t\t|包含全部Path1和Path2\t\n|XOR\t\t\t\t\t|异或\t\t|包含Path1与Path2但不包括两者相交的部分\n\t\n``` bash\n 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。\npath1.op(path2, Path.Op.DIFFERENCE);\n\n// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。\npath3.op(path1, path2, Path.Op.DIFFERENCE)\n\n这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：\nvoid computeBounds (RectF bounds, boolean exact)\n```\n\n\n","source":"_posts/Path.md","raw":"---\ntitle: Path\ndate: 2017-08-27 15:13:51\ntags: 自定义view\ncategories: android\n---\n\n## whant is path\n\nPath封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，\n也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)\n\n<!-- more -->\n\n## api\n\n|作用\t\t  \t\t|相关方法\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t| :----: |\n|移动起点\t  \t\t|moveTo\t\t        |移动下一次操作的起点位置\n|设置终点\t  \t\t|setLastPoint\t\t|重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同\n|连接直线\t  \t\t|lineTo\t\t\t\t|添加上一个点到当前点之间的直线到Path\n|闭合路径\t  \t\t|close\t\t\t\t|连接第一个点连接到最后一个点，形成一个闭合区域\n|添加内容\t  \t\t|addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo  |添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)\n|是否为空\t  \t\t|isEmpty\t\t\t|判断Path是否为空\n|是否为矩形\t  \t\t|isRect\t\t\t\t|判断path是否是一个矩形\n|替换路径\t  \t\t|set\t\t\t\t|用新的路径替换到当前路径所有内容\n|偏移路径\t  \t\t|offset\t\t\t\t|对当前路径之前的操作进行偏移(不会影响之后的操作)\n|贝塞尔曲线\t  \t\t|quadTo, cubicTo\t|分别为二次和三次贝塞尔曲线的方法\n|rXxx方法\t  \t\t|rMoveTo, rLineTo, rQuadTo, rCubicTo\t\t\t\t\t\t\t\t|不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)\n|填充模式\t  \t\t|setFillType, getFillType, isInverseFillType, toggleInverseFillType |设置,获取,判断和切换填充模式\n|提示方法\t  \t\t|incReserve\t\t\t|提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)\n|布尔操作(API19)\t|op\t\t\t\t\t|对两个Path进行布尔运算(即取交集、并集等操作)\n|计算边界\t        |computeBounds\t\t|计算Path的边界\n|重置路径\t        |reset, rewind\t\t|清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType\n|矩阵操作\t\t\t|transform\t\t\t|矩阵变换\n\n## moveTo 和 setLastPoint\n\nmoveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点\n\n## addXxx与arcTo\n\n``` bash\n// 第一类(基本形状)\n// 圆形\npublic void addCircle (float x, float y, float radius, Path.Direction dir)\n// 椭圆\npublic void addOval (RectF oval, Path.Direction dir)\n// 矩形\npublic void addRect (float left, float top, float right, float bottom, Path.Direction dir)\npublic void addRect (RectF rect, Path.Direction dir)\n// 圆角矩形\npublic void addRoundRect (RectF rect, float[] radii, Path.Direction dir)\npublic void addRoundRect (RectF rect, float rx, float ry, Path.Direction dir) \n\n// 第二类(Path)\n// path\npublic void addPath (Path src)\npublic void addPath (Path src, float dx, float dy)\npublic void addPath (Path src, Matrix matrix)\n\naddArc\t添加一个圆弧到path\t直接添加一个圆弧到path中\narcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点\n```\n\n## rXxx\n\nrXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。\n比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ， \n使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示\n\n## 贝塞尔曲线\n\n数据点\t确定曲线的起始和结束位置\n控制点\t确定曲线的弯曲程度\n\n一阶曲线其实就是前面讲解过的lineTo\n二阶曲线对应的方法是quadTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835406060)\n三阶曲线对应的方法是cubicTo\n![](http://photo.163.com/1534598088@qq.com/#m=2&aid=310136082&pid=9835375418)\n\n## PathMeasure\n\n### api\n\n| 返回值\t|方法名\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|释义\n| --------  | \t-----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n| void\t\t|setPath(Path path, boolean forceClosed)\t\t\t\t\t\t\t\t\t|关联一个Path\n| boolean\t|isClosed()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|是否闭合\n| float\t\t|getLength()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|获取Path的长度\n| boolean\t|nextContour()\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|跳转到下一个轮廓\n| boolean\t|getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)\t|截取片段\n| boolean\t|getPosTan(float distance, float[] pos, float[] tan)\t\t\t\t\t\t|获取指定长度的位置坐标及该点切线值\n| boolean\t|getMatrix(float distance, Matrix matrix, int flags)\t\t\t\t\t\t|获取指定长度的位置坐标及该点Matrix\n\n### 构造函数\n\n``` bash\nPathMeasure ()\nPathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 true,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)\n```\n\n### getSegment\n\n``` bash\nboolean getSegment (float startD, float stopD, Path dst, boolean startWithMoveTo)\n```\n\n|参数\t\t\t\t|作用\t\t\t\t\t\t\t\t|备注\n| --------  \t\t| \t-----:   \t\t\t\t\t\t| :----: |\n|返回值(boolean)\t|判断截取是否成功\t\t\t\t\t|true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容\n|startD\t\t\t\t|开始截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|stopD\t\t\t\t|结束截取位置距离 Path 起点的长度\t|取值范围: 0 <= startD < stopD <= Path总长度\n|dst\t\t\t\t|截取的 Path 将会添加到 dst 中\t\t|注意: 是添加，而不是替换\n|startWithMoveTo\t|起始点是否使用 moveTo\t\t\t\t|用于保证截取的 Path 第一个点位置不变\n\n### nextContour\n\n我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，\n而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。\n\n## FillType \n\n|模式\t\t\t\t|简介\n| --------  \t\t| :----: |  \t\t\t\t\t\t\n|EVEN_ODD\t\t\t|奇偶规则\n|INVERSE_EVEN_ODD\t|反奇偶规则\n|WINDING\t\t\t|非零环绕数规则\n|INVERSE_WINDING\t|反非零环绕数规则\n\n## 布尔操作\n\n|逻辑名称\t\t\t\t|类比\t\t|说明\t\n| --------  \t\t\t| \t-----:  | :----: |\n|DIFFERENCE\t\t\t\t|差集\t\t|Path1中减去Path2后剩下的部分\t\n|REVERSE_DIFFERENCE\t\t|差集\t\t|Path2中减去Path1后剩下的部分\t\n|INTERSECT\t\t\t\t|交集\t\t|Path1与Path2相交的部分\t\n|UNION\t\t\t\t\t|并集\t\t|包含全部Path1和Path2\t\n|XOR\t\t\t\t\t|异或\t\t|包含Path1与Path2但不包括两者相交的部分\n\t\n``` bash\n 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。\npath1.op(path2, Path.Op.DIFFERENCE);\n\n// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。\npath3.op(path1, path2, Path.Op.DIFFERENCE)\n\n这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：\nvoid computeBounds (RectF bounds, boolean exact)\n```\n\n\n","slug":"Path","published":1,"updated":"2017-12-14T07:26:23.330Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awct0001kku0phqip7q5","content":"<h2 id=\"whant-is-path\"><a href=\"#whant-is-path\" class=\"headerlink\" title=\"whant is path\"></a>whant is path</h2><p>Path封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，<br>也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)</p>\n<a id=\"more\"></a>\n<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><table>\n<thead>\n<tr>\n<th>作用</th>\n<th style=\"text-align:right\">相关方法</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移动起点</td>\n<td style=\"text-align:right\">moveTo</td>\n<td style=\"text-align:center\">移动下一次操作的起点位置</td>\n</tr>\n<tr>\n<td>设置终点</td>\n<td style=\"text-align:right\">setLastPoint</td>\n<td style=\"text-align:center\">重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同</td>\n</tr>\n<tr>\n<td>连接直线</td>\n<td style=\"text-align:right\">lineTo</td>\n<td style=\"text-align:center\">添加上一个点到当前点之间的直线到Path</td>\n</tr>\n<tr>\n<td>闭合路径</td>\n<td style=\"text-align:right\">close</td>\n<td style=\"text-align:center\">连接第一个点连接到最后一个点，形成一个闭合区域</td>\n</tr>\n<tr>\n<td>添加内容</td>\n<td style=\"text-align:right\">addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo</td>\n<td style=\"text-align:center\">添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)</td>\n</tr>\n<tr>\n<td>是否为空</td>\n<td style=\"text-align:right\">isEmpty</td>\n<td style=\"text-align:center\">判断Path是否为空</td>\n</tr>\n<tr>\n<td>是否为矩形</td>\n<td style=\"text-align:right\">isRect</td>\n<td style=\"text-align:center\">判断path是否是一个矩形</td>\n</tr>\n<tr>\n<td>替换路径</td>\n<td style=\"text-align:right\">set</td>\n<td style=\"text-align:center\">用新的路径替换到当前路径所有内容</td>\n</tr>\n<tr>\n<td>偏移路径</td>\n<td style=\"text-align:right\">offset</td>\n<td style=\"text-align:center\">对当前路径之前的操作进行偏移(不会影响之后的操作)</td>\n</tr>\n<tr>\n<td>贝塞尔曲线</td>\n<td style=\"text-align:right\">quadTo, cubicTo</td>\n<td style=\"text-align:center\">分别为二次和三次贝塞尔曲线的方法</td>\n</tr>\n<tr>\n<td>rXxx方法</td>\n<td style=\"text-align:right\">rMoveTo, rLineTo, rQuadTo, rCubicTo</td>\n<td style=\"text-align:center\">不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</td>\n</tr>\n<tr>\n<td>填充模式</td>\n<td style=\"text-align:right\">setFillType, getFillType, isInverseFillType, toggleInverseFillType</td>\n<td style=\"text-align:center\">设置,获取,判断和切换填充模式</td>\n</tr>\n<tr>\n<td>提示方法</td>\n<td style=\"text-align:right\">incReserve</td>\n<td style=\"text-align:center\">提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)</td>\n</tr>\n<tr>\n<td>布尔操作(API19)</td>\n<td style=\"text-align:right\">op</td>\n<td style=\"text-align:center\">对两个Path进行布尔运算(即取交集、并集等操作)</td>\n</tr>\n<tr>\n<td>计算边界</td>\n<td style=\"text-align:right\">computeBounds</td>\n<td style=\"text-align:center\">计算Path的边界</td>\n</tr>\n<tr>\n<td>重置路径</td>\n<td style=\"text-align:right\">reset, rewind</td>\n<td style=\"text-align:center\">清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType</td>\n</tr>\n<tr>\n<td>矩阵操作</td>\n<td style=\"text-align:right\">transform</td>\n<td style=\"text-align:center\">矩阵变换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"moveTo-和-setLastPoint\"><a href=\"#moveTo-和-setLastPoint\" class=\"headerlink\" title=\"moveTo 和 setLastPoint\"></a>moveTo 和 setLastPoint</h2><p>moveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点</p>\n<h2 id=\"addXxx与arcTo\"><a href=\"#addXxx与arcTo\" class=\"headerlink\" title=\"addXxx与arcTo\"></a>addXxx与arcTo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一类(基本形状)</div><div class=\"line\">// 圆形</div><div class=\"line\">public void addCircle (<span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, <span class=\"built_in\">float</span> radius, Path.Direction dir)</div><div class=\"line\">// 椭圆</div><div class=\"line\">public void addOval (RectF oval, Path.Direction dir)</div><div class=\"line\">// 矩形</div><div class=\"line\">public void addRect (<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, Path.Direction dir)</div><div class=\"line\">public void addRect (RectF rect, Path.Direction dir)</div><div class=\"line\">// 圆角矩形</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span>[] radii, Path.Direction dir)</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span> rx, <span class=\"built_in\">float</span> ry, Path.Direction dir) </div><div class=\"line\"></div><div class=\"line\">// 第二类(Path)</div><div class=\"line\">// path</div><div class=\"line\">public void addPath (Path src)</div><div class=\"line\">public void addPath (Path src, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy)</div><div class=\"line\">public void addPath (Path src, Matrix matrix)</div><div class=\"line\"></div><div class=\"line\">addArc\t添加一个圆弧到path\t直接添加一个圆弧到path中</div><div class=\"line\">arcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点</div></pre></td></tr></table></figure>\n<h2 id=\"rXxx\"><a href=\"#rXxx\" class=\"headerlink\" title=\"rXxx\"></a>rXxx</h2><p>rXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。<br>比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ，<br>使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示</p>\n<h2 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h2><p>数据点    确定曲线的起始和结束位置<br>控制点    确定曲线的弯曲程度</p>\n<p>一阶曲线其实就是前面讲解过的lineTo<br>二阶曲线对应的方法是quadTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835406060\" alt=\"\"><br>三阶曲线对应的方法是cubicTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835375418\" alt=\"\"></p>\n<h2 id=\"PathMeasure\"><a href=\"#PathMeasure\" class=\"headerlink\" title=\"PathMeasure\"></a>PathMeasure</h2><h3 id=\"api-1\"><a href=\"#api-1\" class=\"headerlink\" title=\"api\"></a>api</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th style=\"text-align:right\">方法名</th>\n<th style=\"text-align:center\">释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void</td>\n<td style=\"text-align:right\">setPath(Path path, boolean forceClosed)</td>\n<td style=\"text-align:center\">关联一个Path</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">isClosed()</td>\n<td style=\"text-align:center\">是否闭合</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:right\">getLength()</td>\n<td style=\"text-align:center\">获取Path的长度</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">nextContour()</td>\n<td style=\"text-align:center\">跳转到下一个轮廓</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</td>\n<td style=\"text-align:center\">截取片段</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getPosTan(float distance, float[] pos, float[] tan)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点切线值</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getMatrix(float distance, Matrix matrix, int flags)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点Matrix</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PathMeasure ()</div><div class=\"line\">PathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 <span class=\"literal\">true</span>,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)</div></pre></td></tr></table></figure>\n<h3 id=\"getSegment\"><a href=\"#getSegment\" class=\"headerlink\" title=\"getSegment\"></a>getSegment</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean getSegment (<span class=\"built_in\">float</span> startD, <span class=\"built_in\">float</span> stopD, Path dst, boolean startWithMoveTo)</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">作用</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>返回值(boolean)</td>\n<td style=\"text-align:right\">判断截取是否成功</td>\n<td style=\"text-align:center\">true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容</td>\n</tr>\n<tr>\n<td>startD</td>\n<td style=\"text-align:right\">开始截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>stopD</td>\n<td style=\"text-align:right\">结束截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>dst</td>\n<td style=\"text-align:right\">截取的 Path 将会添加到 dst 中</td>\n<td style=\"text-align:center\">注意: 是添加，而不是替换</td>\n</tr>\n<tr>\n<td>startWithMoveTo</td>\n<td style=\"text-align:right\">起始点是否使用 moveTo</td>\n<td style=\"text-align:center\">用于保证截取的 Path 第一个点位置不变</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nextContour\"><a href=\"#nextContour\" class=\"headerlink\" title=\"nextContour\"></a>nextContour</h3><p>我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，<br>而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。</p>\n<h2 id=\"FillType\"><a href=\"#FillType\" class=\"headerlink\" title=\"FillType\"></a>FillType</h2><table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EVEN_ODD</td>\n<td style=\"text-align:center\">奇偶规则</td>\n</tr>\n<tr>\n<td>INVERSE_EVEN_ODD</td>\n<td style=\"text-align:center\">反奇偶规则</td>\n</tr>\n<tr>\n<td>WINDING</td>\n<td style=\"text-align:center\">非零环绕数规则</td>\n</tr>\n<tr>\n<td>INVERSE_WINDING</td>\n<td style=\"text-align:center\">反非零环绕数规则</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"布尔操作\"><a href=\"#布尔操作\" class=\"headerlink\" title=\"布尔操作\"></a>布尔操作</h2><table>\n<thead>\n<tr>\n<th>逻辑名称</th>\n<th style=\"text-align:right\">类比</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path1中减去Path2后剩下的部分    </td>\n</tr>\n<tr>\n<td>REVERSE_DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path2中减去Path1后剩下的部分    </td>\n</tr>\n<tr>\n<td>INTERSECT</td>\n<td style=\"text-align:right\">交集</td>\n<td style=\"text-align:center\">Path1与Path2相交的部分    </td>\n</tr>\n<tr>\n<td>UNION</td>\n<td style=\"text-align:right\">并集</td>\n<td style=\"text-align:center\">包含全部Path1和Path2    </td>\n</tr>\n<tr>\n<td>XOR</td>\n<td style=\"text-align:right\">异或</td>\n<td style=\"text-align:center\">包含Path1与Path2但不包括两者相交的部分</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。</div><div class=\"line\">path1.op(path2, Path.Op.DIFFERENCE);</div><div class=\"line\"></div><div class=\"line\">// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。</div><div class=\"line\">path3.op(path1, path2, Path.Op.DIFFERENCE)</div><div class=\"line\"></div><div class=\"line\">这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：</div><div class=\"line\">void computeBounds (RectF bounds, boolean exact)</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"whant-is-path\"><a href=\"#whant-is-path\" class=\"headerlink\" title=\"whant is path\"></a>whant is path</h2><p>Path封装了由直线和曲线(二次，三次贝塞尔曲线)构成的几何路径。你能用Canvas中的drawPath来把这条路径画出来(同样支持Paint的不同绘制模式)，<br>也可以用于剪裁画布和根据路径绘制文字。我们有时会用Path来描述一个图像的轮廓，所以也会称为轮廓线(轮廓线仅是Path的一种使用方法，两者并不等价)</p>","more":"<h2 id=\"api\"><a href=\"#api\" class=\"headerlink\" title=\"api\"></a>api</h2><table>\n<thead>\n<tr>\n<th>作用</th>\n<th style=\"text-align:right\">相关方法</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>移动起点</td>\n<td style=\"text-align:right\">moveTo</td>\n<td style=\"text-align:center\">移动下一次操作的起点位置</td>\n</tr>\n<tr>\n<td>设置终点</td>\n<td style=\"text-align:right\">setLastPoint</td>\n<td style=\"text-align:center\">重置当前path中最后一个点位置，如果在绘制之前调用，效果和moveTo相同</td>\n</tr>\n<tr>\n<td>连接直线</td>\n<td style=\"text-align:right\">lineTo</td>\n<td style=\"text-align:center\">添加上一个点到当前点之间的直线到Path</td>\n</tr>\n<tr>\n<td>闭合路径</td>\n<td style=\"text-align:right\">close</td>\n<td style=\"text-align:center\">连接第一个点连接到最后一个点，形成一个闭合区域</td>\n</tr>\n<tr>\n<td>添加内容</td>\n<td style=\"text-align:right\">addRect, addRoundRect, addOval, addCircle, addPath, addArc, arcTo</td>\n<td style=\"text-align:center\">添加(矩形， 圆角矩形， 椭圆， 圆， 路径， 圆弧) 到当前Path (注意addArc和arcTo的区别)</td>\n</tr>\n<tr>\n<td>是否为空</td>\n<td style=\"text-align:right\">isEmpty</td>\n<td style=\"text-align:center\">判断Path是否为空</td>\n</tr>\n<tr>\n<td>是否为矩形</td>\n<td style=\"text-align:right\">isRect</td>\n<td style=\"text-align:center\">判断path是否是一个矩形</td>\n</tr>\n<tr>\n<td>替换路径</td>\n<td style=\"text-align:right\">set</td>\n<td style=\"text-align:center\">用新的路径替换到当前路径所有内容</td>\n</tr>\n<tr>\n<td>偏移路径</td>\n<td style=\"text-align:right\">offset</td>\n<td style=\"text-align:center\">对当前路径之前的操作进行偏移(不会影响之后的操作)</td>\n</tr>\n<tr>\n<td>贝塞尔曲线</td>\n<td style=\"text-align:right\">quadTo, cubicTo</td>\n<td style=\"text-align:center\">分别为二次和三次贝塞尔曲线的方法</td>\n</tr>\n<tr>\n<td>rXxx方法</td>\n<td style=\"text-align:right\">rMoveTo, rLineTo, rQuadTo, rCubicTo</td>\n<td style=\"text-align:center\">不带r的方法是基于原点的坐标系(偏移量)， rXxx方法是基于当前点坐标系(偏移量)</td>\n</tr>\n<tr>\n<td>填充模式</td>\n<td style=\"text-align:right\">setFillType, getFillType, isInverseFillType, toggleInverseFillType</td>\n<td style=\"text-align:center\">设置,获取,判断和切换填充模式</td>\n</tr>\n<tr>\n<td>提示方法</td>\n<td style=\"text-align:right\">incReserve</td>\n<td style=\"text-align:center\">提示Path还有多少个点等待加入(这个方法貌似会让Path优化存储结构)</td>\n</tr>\n<tr>\n<td>布尔操作(API19)</td>\n<td style=\"text-align:right\">op</td>\n<td style=\"text-align:center\">对两个Path进行布尔运算(即取交集、并集等操作)</td>\n</tr>\n<tr>\n<td>计算边界</td>\n<td style=\"text-align:right\">computeBounds</td>\n<td style=\"text-align:center\">计算Path的边界</td>\n</tr>\n<tr>\n<td>重置路径</td>\n<td style=\"text-align:right\">reset, rewind</td>\n<td style=\"text-align:center\">清除Path中的内容 . 不保留内部数据结构，但会保留FillType ;会保留内部的数据结构，但不保留FillType</td>\n</tr>\n<tr>\n<td>矩阵操作</td>\n<td style=\"text-align:right\">transform</td>\n<td style=\"text-align:center\">矩阵变换</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"moveTo-和-setLastPoint\"><a href=\"#moveTo-和-setLastPoint\" class=\"headerlink\" title=\"moveTo 和 setLastPoint\"></a>moveTo 和 setLastPoint</h2><p>moveTo只改变下次操作的起点,setLastPoint是重置上一次操作的最后一个点</p>\n<h2 id=\"addXxx与arcTo\"><a href=\"#addXxx与arcTo\" class=\"headerlink\" title=\"addXxx与arcTo\"></a>addXxx与arcTo</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一类(基本形状)</div><div class=\"line\">// 圆形</div><div class=\"line\">public void addCircle (<span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, <span class=\"built_in\">float</span> radius, Path.Direction dir)</div><div class=\"line\">// 椭圆</div><div class=\"line\">public void addOval (RectF oval, Path.Direction dir)</div><div class=\"line\">// 矩形</div><div class=\"line\">public void addRect (<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, Path.Direction dir)</div><div class=\"line\">public void addRect (RectF rect, Path.Direction dir)</div><div class=\"line\">// 圆角矩形</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span>[] radii, Path.Direction dir)</div><div class=\"line\">public void addRoundRect (RectF rect, <span class=\"built_in\">float</span> rx, <span class=\"built_in\">float</span> ry, Path.Direction dir) </div><div class=\"line\"></div><div class=\"line\">// 第二类(Path)</div><div class=\"line\">// path</div><div class=\"line\">public void addPath (Path src)</div><div class=\"line\">public void addPath (Path src, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy)</div><div class=\"line\">public void addPath (Path src, Matrix matrix)</div><div class=\"line\"></div><div class=\"line\">addArc\t添加一个圆弧到path\t直接添加一个圆弧到path中</div><div class=\"line\">arcTo\t添加一个圆弧到path\t添加一个圆弧到path，如果圆弧的起点和上次最后一个坐标点不相同，就连接两个点</div></pre></td></tr></table></figure>\n<h2 id=\"rXxx\"><a href=\"#rXxx\" class=\"headerlink\" title=\"rXxx\"></a>rXxx</h2><p>rXxx方法的坐标使用的是相对位置(基于当前点的位移)，而之前方法的坐标是绝对位置(基于当前坐标系的坐标)。<br>比如，path.moveTo(100,100);path.rLineTo(100,200);在使用rLineTo之前，当前点的位置在 (100,100) ，<br>使用了 rLineTo(100,200) 之后，下一个点的位置是在当前点的基础上加上偏移量得到的，即 (100+100, 100+200) 这个位置，故最终结果如上所示</p>\n<h2 id=\"贝塞尔曲线\"><a href=\"#贝塞尔曲线\" class=\"headerlink\" title=\"贝塞尔曲线\"></a>贝塞尔曲线</h2><p>数据点    确定曲线的起始和结束位置<br>控制点    确定曲线的弯曲程度</p>\n<p>一阶曲线其实就是前面讲解过的lineTo<br>二阶曲线对应的方法是quadTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835406060\" alt=\"\"><br>三阶曲线对应的方法是cubicTo<br><img src=\"http://photo.163.com/1534598088@qq.com/#m=2&amp;aid=310136082&amp;pid=9835375418\" alt=\"\"></p>\n<h2 id=\"PathMeasure\"><a href=\"#PathMeasure\" class=\"headerlink\" title=\"PathMeasure\"></a>PathMeasure</h2><h3 id=\"api-1\"><a href=\"#api-1\" class=\"headerlink\" title=\"api\"></a>api</h3><table>\n<thead>\n<tr>\n<th>返回值</th>\n<th style=\"text-align:right\">方法名</th>\n<th style=\"text-align:center\">释义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>void</td>\n<td style=\"text-align:right\">setPath(Path path, boolean forceClosed)</td>\n<td style=\"text-align:center\">关联一个Path</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">isClosed()</td>\n<td style=\"text-align:center\">是否闭合</td>\n</tr>\n<tr>\n<td>float</td>\n<td style=\"text-align:right\">getLength()</td>\n<td style=\"text-align:center\">获取Path的长度</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">nextContour()</td>\n<td style=\"text-align:center\">跳转到下一个轮廓</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo)</td>\n<td style=\"text-align:center\">截取片段</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getPosTan(float distance, float[] pos, float[] tan)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点切线值</td>\n</tr>\n<tr>\n<td>boolean</td>\n<td style=\"text-align:right\">getMatrix(float distance, Matrix matrix, int flags)</td>\n<td style=\"text-align:center\">获取指定长度的位置坐标及该点Matrix</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">PathMeasure ()</div><div class=\"line\">PathMeasure (Path path, boolean forceClosed) // 第二个参数是用来确保 Path 闭合，如果设置为 <span class=\"literal\">true</span>,则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)</div></pre></td></tr></table></figure>\n<h3 id=\"getSegment\"><a href=\"#getSegment\" class=\"headerlink\" title=\"getSegment\"></a>getSegment</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean getSegment (<span class=\"built_in\">float</span> startD, <span class=\"built_in\">float</span> stopD, Path dst, boolean startWithMoveTo)</div></pre></td></tr></table></figure>\n<table>\n<thead>\n<tr>\n<th>参数</th>\n<th style=\"text-align:right\">作用</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>返回值(boolean)</td>\n<td style=\"text-align:right\">判断截取是否成功</td>\n<td style=\"text-align:center\">true 表示截取成功，结果存入dst中，false 截取失败，不会改变dst中内容</td>\n</tr>\n<tr>\n<td>startD</td>\n<td style=\"text-align:right\">开始截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>stopD</td>\n<td style=\"text-align:right\">结束截取位置距离 Path 起点的长度</td>\n<td style=\"text-align:center\">取值范围: 0 &lt;= startD &lt; stopD &lt;= Path总长度</td>\n</tr>\n<tr>\n<td>dst</td>\n<td style=\"text-align:right\">截取的 Path 将会添加到 dst 中</td>\n<td style=\"text-align:center\">注意: 是添加，而不是替换</td>\n</tr>\n<tr>\n<td>startWithMoveTo</td>\n<td style=\"text-align:right\">起始点是否使用 moveTo</td>\n<td style=\"text-align:center\">用于保证截取的 Path 第一个点位置不变</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"nextContour\"><a href=\"#nextContour\" class=\"headerlink\" title=\"nextContour\"></a>nextContour</h3><p>我们知道 Path 可以由多条曲线构成，但不论是 getLength , getgetSegment 或者是其它方法，都只会在其中第一条线段上运行，<br>而这个 nextContour 就是用于跳转到下一条曲线到方法，如果跳转成功，则返回 true， 如果跳转失败，则返回 false。</p>\n<h2 id=\"FillType\"><a href=\"#FillType\" class=\"headerlink\" title=\"FillType\"></a>FillType</h2><table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>EVEN_ODD</td>\n<td style=\"text-align:center\">奇偶规则</td>\n</tr>\n<tr>\n<td>INVERSE_EVEN_ODD</td>\n<td style=\"text-align:center\">反奇偶规则</td>\n</tr>\n<tr>\n<td>WINDING</td>\n<td style=\"text-align:center\">非零环绕数规则</td>\n</tr>\n<tr>\n<td>INVERSE_WINDING</td>\n<td style=\"text-align:center\">反非零环绕数规则</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"布尔操作\"><a href=\"#布尔操作\" class=\"headerlink\" title=\"布尔操作\"></a>布尔操作</h2><table>\n<thead>\n<tr>\n<th>逻辑名称</th>\n<th style=\"text-align:right\">类比</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path1中减去Path2后剩下的部分    </td>\n</tr>\n<tr>\n<td>REVERSE_DIFFERENCE</td>\n<td style=\"text-align:right\">差集</td>\n<td style=\"text-align:center\">Path2中减去Path1后剩下的部分    </td>\n</tr>\n<tr>\n<td>INTERSECT</td>\n<td style=\"text-align:right\">交集</td>\n<td style=\"text-align:center\">Path1与Path2相交的部分    </td>\n</tr>\n<tr>\n<td>UNION</td>\n<td style=\"text-align:right\">并集</td>\n<td style=\"text-align:center\">包含全部Path1和Path2    </td>\n</tr>\n<tr>\n<td>XOR</td>\n<td style=\"text-align:right\">异或</td>\n<td style=\"text-align:center\">包含Path1与Path2但不包括两者相交的部分</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"> 对 path1 和 path2 执行布尔运算，运算方式由第二个参数指定，运算结果存入到path1中。</div><div class=\"line\">path1.op(path2, Path.Op.DIFFERENCE);</div><div class=\"line\"></div><div class=\"line\">// 对 path1 和 path2 执行布尔运算，运算方式由第三个参数指定，运算结果存入到path3中。</div><div class=\"line\">path3.op(path1, path2, Path.Op.DIFFERENCE)</div><div class=\"line\"></div><div class=\"line\">这个方法主要作用是计算Path所占用的空间以及所在位置,方法如下：</div><div class=\"line\">void computeBounds (RectF bounds, boolean exact)</div></pre></td></tr></table></figure>"},{"title":"Paint 详解","date":"2017-05-14T07:22:26.000Z","_content":"\n## api合集\n``` bash\nvoid reset();\nvoid set(Paint src);\nvoid setCompatibilityScaling(float factor);\nvoid setBidiFlags(int flags);\nvoid setFlags(int flags);\nvoid setHinting(int mode);\n//是否抗锯齿\nvoid setAntiAlias(boolean aa);\n//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  \nvoid setDither(boolean dither);\n//设置线性文本\nvoid setLinearText(boolean linearText);\n//设置该项为true，将有助于文本在LCD屏幕上的显示效果  \nvoid setSubpixelText(boolean subpixelText);\n//设置下划线\nvoid setUnderlineText(boolean underlineText);\n//设置带有删除线的效果 \nvoid setStrikeThruText(boolean strikeThruText);\n//设置伪粗体文本，设置在小字体上效果会非常差  \nvoid setFakeBoldText(boolean fakeBoldText);\n//如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作\n//加快显示速度，本设置项依赖于dither和xfermode的设置  \nvoid setFilterBitmap(boolean filter);\n//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE\n//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  \nvoid setStyle(Style style);\n //设置颜色值\nvoid setColor(int color);\n//设置透明图0~255，要在setColor后面设置才生效\nvoid setAlpha(int a);   \n//设置RGB及透明度\nvoid setARGB(int a, int r, int g, int b);  \n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  \nvoid setStrokeWidth(float width);\nvoid setStrokeMiter(float miter);\n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式\nvoid setStrokeCap(Cap cap);\n//设置绘制时各图形的结合方式，如平滑效果等  \nvoid setStrokeJoin(Join join);\n//设置图像效果，使用Shader可以绘制出各种渐变效果  \nShader setShader(Shader shader);\n//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 \nColorFilter setColorFilter(ColorFilter filter);\n//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 \nXfermode setXfermode(Xfermode xfermode);\n//设置绘制路径的效果，如点画线等 \nPathEffect setPathEffect(PathEffect effect);\n//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  \nMaskFilter setMaskFilter(MaskFilter maskfilter);\n//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  \nTypeface setTypeface(Typeface typeface);\n//设置光栅化\nRasterizer setRasterizer(Rasterizer rasterizer);\n//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色\n//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\nvoid setShadowLayer(float radius, float dx, float dy, int color);\n//设置文本对齐\nvoid setTextAlign(Align align);\n//设置字体大小\nvoid setTextSize(float textSize);\n//设置文本缩放倍数，1.0f为原始\nvoid setTextScaleX(float scaleX);\n//设置斜体文字，skewX为倾斜弧度  \nvoid setTextSkewX(float skewX);\n//下面几个就是测量字体的长度了\nmeasureText(String text)，measureText(CharSequence text, int start, int end)\n//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高\ngetTextBounds(String text, int start, int end, Rect bounds) \n```\n<!-- more -->\n\n## 挑几个说说\n\nsetStyle()\nPaint.Style.FILL：填充内部\nPaint.Style.FILL_AND_STROKE  ：填充内部和描边\nPaint.Style.STROKE  ：描边\n\nsetStrokeCap()\nPaint.Cap.ROUND :\nPaint.Cap.SQUARE :\nPaint.Cap.BUTT :\n![](http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png)\n\nsetStrokeJoin()\nPaint.Join.ROUND :\nPaint.Join.BEVEL :\nPaint.Join.MITER :\n![](http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png)\n\n### PorterDuffXfermode : Paint.setXfermode(xfermode)\n图片混合模式，十分实用的api\n``` bash\nprivate static final Xfermode[] sModes = {\n    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼\n    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) };   //显示持有图像，重合的会变白\n```\n上个小例子,画一个带有白色边的黄色实心小圆\n``` bash\n\n```\n\n","source":"_posts/Paint.md","raw":"---\ntitle: Paint 详解\ndate: 2017-05-14 15:22:26\ncategories: android\ntags: [自定义view,paint]\n---\n\n## api合集\n``` bash\nvoid reset();\nvoid set(Paint src);\nvoid setCompatibilityScaling(float factor);\nvoid setBidiFlags(int flags);\nvoid setFlags(int flags);\nvoid setHinting(int mode);\n//是否抗锯齿\nvoid setAntiAlias(boolean aa);\n//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  \nvoid setDither(boolean dither);\n//设置线性文本\nvoid setLinearText(boolean linearText);\n//设置该项为true，将有助于文本在LCD屏幕上的显示效果  \nvoid setSubpixelText(boolean subpixelText);\n//设置下划线\nvoid setUnderlineText(boolean underlineText);\n//设置带有删除线的效果 \nvoid setStrikeThruText(boolean strikeThruText);\n//设置伪粗体文本，设置在小字体上效果会非常差  \nvoid setFakeBoldText(boolean fakeBoldText);\n//如果该项设置为true，则图像在动画进行中会滤掉对Bitmap图像的优化操作\n//加快显示速度，本设置项依赖于dither和xfermode的设置  \nvoid setFilterBitmap(boolean filter);\n//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE\n//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  \nvoid setStyle(Style style);\n //设置颜色值\nvoid setColor(int color);\n//设置透明图0~255，要在setColor后面设置才生效\nvoid setAlpha(int a);   \n//设置RGB及透明度\nvoid setARGB(int a, int r, int g, int b);  \n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  \nvoid setStrokeWidth(float width);\nvoid setStrokeMiter(float miter);\n//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式\nvoid setStrokeCap(Cap cap);\n//设置绘制时各图形的结合方式，如平滑效果等  \nvoid setStrokeJoin(Join join);\n//设置图像效果，使用Shader可以绘制出各种渐变效果  \nShader setShader(Shader shader);\n//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 \nColorFilter setColorFilter(ColorFilter filter);\n//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 \nXfermode setXfermode(Xfermode xfermode);\n//设置绘制路径的效果，如点画线等 \nPathEffect setPathEffect(PathEffect effect);\n//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  \nMaskFilter setMaskFilter(MaskFilter maskfilter);\n//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  \nTypeface setTypeface(Typeface typeface);\n//设置光栅化\nRasterizer setRasterizer(Rasterizer rasterizer);\n//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色\n//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);\nvoid setShadowLayer(float radius, float dx, float dy, int color);\n//设置文本对齐\nvoid setTextAlign(Align align);\n//设置字体大小\nvoid setTextSize(float textSize);\n//设置文本缩放倍数，1.0f为原始\nvoid setTextScaleX(float scaleX);\n//设置斜体文字，skewX为倾斜弧度  \nvoid setTextSkewX(float skewX);\n//下面几个就是测量字体的长度了\nmeasureText(String text)，measureText(CharSequence text, int start, int end)\n//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高\ngetTextBounds(String text, int start, int end, Rect bounds) \n```\n<!-- more -->\n\n## 挑几个说说\n\nsetStyle()\nPaint.Style.FILL：填充内部\nPaint.Style.FILL_AND_STROKE  ：填充内部和描边\nPaint.Style.STROKE  ：描边\n\nsetStrokeCap()\nPaint.Cap.ROUND :\nPaint.Cap.SQUARE :\nPaint.Cap.BUTT :\n![](http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png)\n\nsetStrokeJoin()\nPaint.Join.ROUND :\nPaint.Join.BEVEL :\nPaint.Join.MITER :\n![](http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png)\n\n### PorterDuffXfermode : Paint.setXfermode(xfermode)\n图片混合模式，十分实用的api\n``` bash\nprivate static final Xfermode[] sModes = {\n    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者\n    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像\n    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像\n    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效\n    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼\n    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) };   //显示持有图像，重合的会变白\n```\n上个小例子,画一个带有白色边的黄色实心小圆\n``` bash\n\n```\n\n","slug":"Paint","published":1,"updated":"2017-12-14T07:26:23.327Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awcx0004kku0rhglqwaf","content":"<h2 id=\"api合集\"><a href=\"#api合集\" class=\"headerlink\" title=\"api合集\"></a>api合集</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">void reset();</div><div class=\"line\">void <span class=\"built_in\">set</span>(Paint src);</div><div class=\"line\">void <span class=\"built_in\">set</span>CompatibilityScaling(<span class=\"built_in\">float</span> factor);</div><div class=\"line\">void <span class=\"built_in\">set</span>BidiFlags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Flags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Hinting(int mode);</div><div class=\"line\">//是否抗锯齿</div><div class=\"line\">void <span class=\"built_in\">set</span>AntiAlias(boolean aa);</div><div class=\"line\">//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  </div><div class=\"line\">void <span class=\"built_in\">set</span>Dither(boolean dither);</div><div class=\"line\">//设置线性文本</div><div class=\"line\">void <span class=\"built_in\">set</span>LinearText(boolean linearText);</div><div class=\"line\">//设置该项为<span class=\"literal\">true</span>，将有助于文本在LCD屏幕上的显示效果  </div><div class=\"line\">void <span class=\"built_in\">set</span>SubpixelText(boolean subpixelText);</div><div class=\"line\">//设置下划线</div><div class=\"line\">void <span class=\"built_in\">set</span>UnderlineText(boolean underlineText);</div><div class=\"line\">//设置带有删除线的效果 </div><div class=\"line\">void <span class=\"built_in\">set</span>StrikeThruText(boolean strikeThruText);</div><div class=\"line\">//设置伪粗体文本，设置在小字体上效果会非常差  </div><div class=\"line\">void <span class=\"built_in\">set</span>FakeBoldText(boolean fakeBoldText);</div><div class=\"line\">//如果该项设置为<span class=\"literal\">true</span>，则图像在动画进行中会滤掉对Bitmap图像的优化操作</div><div class=\"line\">//加快显示速度，本设置项依赖于dither和xfermode的设置  </div><div class=\"line\">void <span class=\"built_in\">set</span>FilterBitmap(boolean filter);</div><div class=\"line\">//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE</div><div class=\"line\">//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  </div><div class=\"line\">void <span class=\"built_in\">set</span>Style(Style style);</div><div class=\"line\"> //设置颜色值</div><div class=\"line\">void <span class=\"built_in\">set</span>Color(int color);</div><div class=\"line\">//设置透明图0~255，要在<span class=\"built_in\">set</span>Color后面设置才生效</div><div class=\"line\">void <span class=\"built_in\">set</span>Alpha(int a);   </div><div class=\"line\">//设置RGB及透明度</div><div class=\"line\">void <span class=\"built_in\">set</span>ARGB(int a, int r, int g, int b);  </div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeWidth(<span class=\"built_in\">float</span> width);</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeMiter(<span class=\"built_in\">float</span> miter);</div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeCap(Cap <span class=\"built_in\">cap</span>);</div><div class=\"line\">//设置绘制时各图形的结合方式，如平滑效果等  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeJoin(Join join);</div><div class=\"line\">//设置图像效果，使用Shader可以绘制出各种渐变效果  </div><div class=\"line\">Shader <span class=\"built_in\">set</span>Shader(Shader shader);</div><div class=\"line\">//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 </div><div class=\"line\">ColorFilter <span class=\"built_in\">set</span>ColorFilter(ColorFilter filter);</div><div class=\"line\">//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 </div><div class=\"line\">Xfermode <span class=\"built_in\">set</span>Xfermode(Xfermode xfermode);</div><div class=\"line\">//设置绘制路径的效果，如点画线等 </div><div class=\"line\">PathEffect <span class=\"built_in\">set</span>PathEffect(PathEffect effect);</div><div class=\"line\">//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  </div><div class=\"line\">MaskFilter <span class=\"built_in\">set</span>MaskFilter(MaskFilter maskfilter);</div><div class=\"line\">//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  </div><div class=\"line\">Typeface <span class=\"built_in\">set</span>Typeface(Typeface typeface);</div><div class=\"line\">//设置光栅化</div><div class=\"line\">Rasterizer <span class=\"built_in\">set</span>Rasterizer(Rasterizer rasterizer);</div><div class=\"line\">//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色</div><div class=\"line\">//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class=\"line\">void <span class=\"built_in\">set</span>ShadowLayer(<span class=\"built_in\">float</span> radius, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy, int color);</div><div class=\"line\">//设置文本对齐</div><div class=\"line\">void <span class=\"built_in\">set</span>TextAlign(Align align);</div><div class=\"line\">//设置字体大小</div><div class=\"line\">void <span class=\"built_in\">set</span>TextSize(<span class=\"built_in\">float</span> textSize);</div><div class=\"line\">//设置文本缩放倍数，1.0f为原始</div><div class=\"line\">void <span class=\"built_in\">set</span>TextScaleX(<span class=\"built_in\">float</span> scaleX);</div><div class=\"line\">//设置斜体文字，skewX为倾斜弧度  </div><div class=\"line\">void <span class=\"built_in\">set</span>TextSkewX(<span class=\"built_in\">float</span> skewX);</div><div class=\"line\">//下面几个就是测量字体的长度了</div><div class=\"line\">measureText(String text)，measureText(CharSequence text, int start, int end)</div><div class=\"line\">//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</div><div class=\"line\">getTextBounds(String text, int start, int end, Rect bounds)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"挑几个说说\"><a href=\"#挑几个说说\" class=\"headerlink\" title=\"挑几个说说\"></a>挑几个说说</h2><p>setStyle()<br>Paint.Style.FILL：填充内部<br>Paint.Style.FILL_AND_STROKE  ：填充内部和描边<br>Paint.Style.STROKE  ：描边</p>\n<p>setStrokeCap()<br>Paint.Cap.ROUND :<br>Paint.Cap.SQUARE :<br>Paint.Cap.BUTT :<br><img src=\"http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png\" alt=\"\"></p>\n<p>setStrokeJoin()<br>Paint.Join.ROUND :<br>Paint.Join.BEVEL :<br>Paint.Join.MITER :<br><img src=\"http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png\" alt=\"\"></p>\n<h3 id=\"PorterDuffXfermode-Paint-setXfermode-xfermode\"><a href=\"#PorterDuffXfermode-Paint-setXfermode-xfermode\" class=\"headerlink\" title=\"PorterDuffXfermode : Paint.setXfermode(xfermode)\"></a>PorterDuffXfermode : Paint.setXfermode(xfermode)</h3><p>图片混合模式，十分实用的api<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final Xfermode[] sModes = &#123;</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) &#125;;   //显示持有图像，重合的会变白</div></pre></td></tr></table></figure></p>\n<p>上个小例子,画一个带有白色边的黄色实心小圆<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"api合集\"><a href=\"#api合集\" class=\"headerlink\" title=\"api合集\"></a>api合集</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\">void reset();</div><div class=\"line\">void <span class=\"built_in\">set</span>(Paint src);</div><div class=\"line\">void <span class=\"built_in\">set</span>CompatibilityScaling(<span class=\"built_in\">float</span> factor);</div><div class=\"line\">void <span class=\"built_in\">set</span>BidiFlags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Flags(int flags);</div><div class=\"line\">void <span class=\"built_in\">set</span>Hinting(int mode);</div><div class=\"line\">//是否抗锯齿</div><div class=\"line\">void <span class=\"built_in\">set</span>AntiAlias(boolean aa);</div><div class=\"line\">//设定是否使用图像抖动处理，会使绘制出来的图片颜色更加平滑和饱满，图像更加清晰  </div><div class=\"line\">void <span class=\"built_in\">set</span>Dither(boolean dither);</div><div class=\"line\">//设置线性文本</div><div class=\"line\">void <span class=\"built_in\">set</span>LinearText(boolean linearText);</div><div class=\"line\">//设置该项为<span class=\"literal\">true</span>，将有助于文本在LCD屏幕上的显示效果  </div><div class=\"line\">void <span class=\"built_in\">set</span>SubpixelText(boolean subpixelText);</div><div class=\"line\">//设置下划线</div><div class=\"line\">void <span class=\"built_in\">set</span>UnderlineText(boolean underlineText);</div><div class=\"line\">//设置带有删除线的效果 </div><div class=\"line\">void <span class=\"built_in\">set</span>StrikeThruText(boolean strikeThruText);</div><div class=\"line\">//设置伪粗体文本，设置在小字体上效果会非常差  </div><div class=\"line\">void <span class=\"built_in\">set</span>FakeBoldText(boolean fakeBoldText);</div><div class=\"line\">//如果该项设置为<span class=\"literal\">true</span>，则图像在动画进行中会滤掉对Bitmap图像的优化操作</div><div class=\"line\">//加快显示速度，本设置项依赖于dither和xfermode的设置  </div><div class=\"line\">void <span class=\"built_in\">set</span>FilterBitmap(boolean filter);</div><div class=\"line\">//设置画笔风格，空心或者实心 FILL，FILL_OR_STROKE，或STROKE</div><div class=\"line\">//Paint.Style.STROKE 表示当前只绘制图形的轮廓，而Paint.Style.FILL表示填充图形。  </div><div class=\"line\">void <span class=\"built_in\">set</span>Style(Style style);</div><div class=\"line\"> //设置颜色值</div><div class=\"line\">void <span class=\"built_in\">set</span>Color(int color);</div><div class=\"line\">//设置透明图0~255，要在<span class=\"built_in\">set</span>Color后面设置才生效</div><div class=\"line\">void <span class=\"built_in\">set</span>Alpha(int a);   </div><div class=\"line\">//设置RGB及透明度</div><div class=\"line\">void <span class=\"built_in\">set</span>ARGB(int a, int r, int g, int b);  </div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷的粗细度  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeWidth(<span class=\"built_in\">float</span> width);</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeMiter(<span class=\"built_in\">float</span> miter);</div><div class=\"line\">//当画笔样式为STROKE或FILL_OR_STROKE时，设置笔刷末端的图形样式</div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeCap(Cap <span class=\"built_in\">cap</span>);</div><div class=\"line\">//设置绘制时各图形的结合方式，如平滑效果等  </div><div class=\"line\">void <span class=\"built_in\">set</span>StrokeJoin(Join join);</div><div class=\"line\">//设置图像效果，使用Shader可以绘制出各种渐变效果  </div><div class=\"line\">Shader <span class=\"built_in\">set</span>Shader(Shader shader);</div><div class=\"line\">//设置颜色过滤器，可以在绘制颜色时实现不用颜色的变换效果 </div><div class=\"line\">ColorFilter <span class=\"built_in\">set</span>ColorFilter(ColorFilter filter);</div><div class=\"line\">//设置图形重叠时的处理方式，如合并，取交集或并集，经常用来制作橡皮的擦除效果 </div><div class=\"line\">Xfermode <span class=\"built_in\">set</span>Xfermode(Xfermode xfermode);</div><div class=\"line\">//设置绘制路径的效果，如点画线等 </div><div class=\"line\">PathEffect <span class=\"built_in\">set</span>PathEffect(PathEffect effect);</div><div class=\"line\">//设置MaskFilter，可以用不同的MaskFilter实现滤镜的效果，如滤化，立体等  </div><div class=\"line\">MaskFilter <span class=\"built_in\">set</span>MaskFilter(MaskFilter maskfilter);</div><div class=\"line\">//设置Typeface对象，即字体风格，包括粗体，斜体以及衬线体，非衬线体等  </div><div class=\"line\">Typeface <span class=\"built_in\">set</span>Typeface(Typeface typeface);</div><div class=\"line\">//设置光栅化</div><div class=\"line\">Rasterizer <span class=\"built_in\">set</span>Rasterizer(Rasterizer rasterizer);</div><div class=\"line\">//在图形下面设置阴影层，产生阴影效果，radius为阴影的角度，dx和dy为阴影在x轴和y轴上的距离，color为阴影的颜色</div><div class=\"line\">//注意：在Android4.0以上默认开启硬件加速，有些图形的阴影无法显示。关闭View的硬件加速 view.setLayerType(View.LAYER_TYPE_SOFTWARE, null);</div><div class=\"line\">void <span class=\"built_in\">set</span>ShadowLayer(<span class=\"built_in\">float</span> radius, <span class=\"built_in\">float</span> dx, <span class=\"built_in\">float</span> dy, int color);</div><div class=\"line\">//设置文本对齐</div><div class=\"line\">void <span class=\"built_in\">set</span>TextAlign(Align align);</div><div class=\"line\">//设置字体大小</div><div class=\"line\">void <span class=\"built_in\">set</span>TextSize(<span class=\"built_in\">float</span> textSize);</div><div class=\"line\">//设置文本缩放倍数，1.0f为原始</div><div class=\"line\">void <span class=\"built_in\">set</span>TextScaleX(<span class=\"built_in\">float</span> scaleX);</div><div class=\"line\">//设置斜体文字，skewX为倾斜弧度  </div><div class=\"line\">void <span class=\"built_in\">set</span>TextSkewX(<span class=\"built_in\">float</span> skewX);</div><div class=\"line\">//下面几个就是测量字体的长度了</div><div class=\"line\">measureText(String text)，measureText(CharSequence text, int start, int end)</div><div class=\"line\">//得到文本的边界，上下左右，提取到bounds中，可以通过这计算文本的宽和高</div><div class=\"line\">getTextBounds(String text, int start, int end, Rect bounds)</div></pre></td></tr></table></figure>","more":"<h2 id=\"挑几个说说\"><a href=\"#挑几个说说\" class=\"headerlink\" title=\"挑几个说说\"></a>挑几个说说</h2><p>setStyle()<br>Paint.Style.FILL：填充内部<br>Paint.Style.FILL_AND_STROKE  ：填充内部和描边<br>Paint.Style.STROKE  ：描边</p>\n<p>setStrokeCap()<br>Paint.Cap.ROUND :<br>Paint.Cap.SQUARE :<br>Paint.Cap.BUTT :<br><img src=\"http://img2.ph.126.net/qQ5AJEYSZJMKe-zHbV05Dw==/6632084813957888759.png\" alt=\"\"></p>\n<p>setStrokeJoin()<br>Paint.Join.ROUND :<br>Paint.Join.BEVEL :<br>Paint.Join.MITER :<br><img src=\"http://img1.ph.126.net/Ej_f2s_G08eWgW1QywoMlA==/6632581793210969410.png\" alt=\"\"></p>\n<h3 id=\"PorterDuffXfermode-Paint-setXfermode-xfermode\"><a href=\"#PorterDuffXfermode-Paint-setXfermode-xfermode\" class=\"headerlink\" title=\"PorterDuffXfermode : Paint.setXfermode(xfermode)\"></a>PorterDuffXfermode : Paint.setXfermode(xfermode)</h3><p>图片混合模式，十分实用的api<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">private static final Xfermode[] sModes = &#123;</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.CLEAR),      //清空所有，要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC),        //显示前都图像，不显示后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST),        //显示后者图像，不显示前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER),   //后者叠于前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OVER),   //前者叠于后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_IN),     //显示相交的区域，但图像为后者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_IN),     //显示相交的区域，但图像为前者</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_OUT),    //显示后者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_OUT),    //显示前者不重叠的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP),   //显示前者图像，与后者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DST_ATOP),   //显示后者图像，与前者重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.XOR),        //显示持有不重合的图像</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.DARKEN),     //后者叠于前者上，后者与前者重叠的部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.LIGHTEN),    //前者叠于前者，前者与后者重叠部份透明。要闭硬件加速，否则无效</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.MULTIPLY),   //显示重合的图像，且颜色会合拼</div><div class=\"line\">    new PorterDuffXfermode(PorterDuff.Mode.SCREEN) &#125;;   //显示持有图像，重合的会变白</div></pre></td></tr></table></figure></p>\n<p>上个小例子,画一个带有白色边的黄色实心小圆<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"></div></pre></td></tr></table></figure></p>"},{"title":"android_touch","date":"2017-09-23T07:22:41.000Z","_content":"\n# android 事件机制全解\n\n一个点击事件产生后，传递顺序是：Activity（Window） -> ViewGroup -> View\n\n默认情况下（没有自己重写派发拦截）从Activity A—->ViewGroup B—>View C，从上往下调用dispatchTouchEvent()\n再由View C—>ViewGroup B —>Activity A，从下往上调用onTouchEvent()\n\n<!-- more -->\n\n![](http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 事件传递方法 （执行顺序如下）\n\n### 事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\n\n当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用\n\n返回值\nsuper：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）\n\n|对象\t\t\t|返回方法\t\t\t\t\t\t|说明\t\n| --------  \t| \t-----:   \t\t\t\t\t| :----: |\n|Activity\t\t|super.dispatchTouchEvent()\t\t|即调用父类ViewGroup的dispatchTouchEvent()\t\n|ViewGroup\t\t|onIntercepTouchEvent()\t\t\t|即调用自身的onIntercepTouchEvent()\t\n|View\t\t\t|onTouchEvent（）\t\t\t\t|即调用自身的onTouchEvent（）\t\n\t\ntrue：消费事件，即事件不继续往下传递\nfalse：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理\n\n### 事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\n\n调用时刻 在ViewGroup的dispatchTouchEvent()内部调用\n\n返回值\nture ：调用自身的onTouchEvent（）\nsuper | false : 调用子类的dispatchTouchEvent()\n\n### 事件处理 onTouchEvent()\n\n| 事件  \t\t\t\t| 简介\t | \n| --------  \t\t\t| :----: |\n|ACTION_DOWN\t\t\t|手指 初次接触到屏幕 时触发。\n|ACTION_MOVE    \t\t|\t手指 在屏幕上滑动 时触发，会多次触发。\n|ACTION_UP      \t\t|\t手指 离开屏幕 时触发。\n|ACTION_CANCEL\t\t\t|事件 被上层拦截 时触发。\n|ACTION_OUTSIDE\t\t\t|手指 不在控件区域 时触发。\n|ACTION_POINTER_DOWN\t|有非主要的手指按下(即按下之前已经有手指在屏幕上)。\n|ACTION_POINTER_UP\t\t|有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。\n|getAction()\t\t\t|获取事件类型。\n|getX()\t\t\t\t\t|获得触摸点在当前 View 的 X 轴坐标。\n|getY()\t\t\t\t\t|获得触摸点在当前 View 的 Y 轴坐标。\n|getRawX()\t\t\t\t|获得触摸点在整个屏幕的 X 轴坐标。\n|getRawY()\t\t\t\t|获得触摸点在整个屏幕的 Y 轴坐标。\n\n#### 多点触控\n\n多点触控获取事件类型请使用 getActionMasked() 。\n追踪事件流请使用 PointId。\n\n##### index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\n\nindex\n1、从 0 开始，自动增长。\n2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。\n3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。\n4、对 move 事件无效\n\npointId\n1. 从 0 开始，自动增长。\n2. 落下手指时优先填补空缺(填补之前抬起手指的编号)。\n\n\n","source":"_posts/android-touch.md","raw":"---\ntitle: android_touch\ndate: 2017-09-23 15:22:41\ncategories: android\ntags: touch\n---\n\n# android 事件机制全解\n\n一个点击事件产生后，传递顺序是：Activity（Window） -> ViewGroup -> View\n\n默认情况下（没有自己重写派发拦截）从Activity A—->ViewGroup B—>View C，从上往下调用dispatchTouchEvent()\n再由View C—>ViewGroup B —>Activity A，从下往上调用onTouchEvent()\n\n<!-- more -->\n\n![](http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 事件传递方法 （执行顺序如下）\n\n### 事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\n\n当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用\n\n返回值\nsuper：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）\n\n|对象\t\t\t|返回方法\t\t\t\t\t\t|说明\t\n| --------  \t| \t-----:   \t\t\t\t\t| :----: |\n|Activity\t\t|super.dispatchTouchEvent()\t\t|即调用父类ViewGroup的dispatchTouchEvent()\t\n|ViewGroup\t\t|onIntercepTouchEvent()\t\t\t|即调用自身的onIntercepTouchEvent()\t\n|View\t\t\t|onTouchEvent（）\t\t\t\t|即调用自身的onTouchEvent（）\t\n\t\ntrue：消费事件，即事件不继续往下传递\nfalse：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理\n\n### 事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\n\n调用时刻 在ViewGroup的dispatchTouchEvent()内部调用\n\n返回值\nture ：调用自身的onTouchEvent（）\nsuper | false : 调用子类的dispatchTouchEvent()\n\n### 事件处理 onTouchEvent()\n\n| 事件  \t\t\t\t| 简介\t | \n| --------  \t\t\t| :----: |\n|ACTION_DOWN\t\t\t|手指 初次接触到屏幕 时触发。\n|ACTION_MOVE    \t\t|\t手指 在屏幕上滑动 时触发，会多次触发。\n|ACTION_UP      \t\t|\t手指 离开屏幕 时触发。\n|ACTION_CANCEL\t\t\t|事件 被上层拦截 时触发。\n|ACTION_OUTSIDE\t\t\t|手指 不在控件区域 时触发。\n|ACTION_POINTER_DOWN\t|有非主要的手指按下(即按下之前已经有手指在屏幕上)。\n|ACTION_POINTER_UP\t\t|有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。\n|getAction()\t\t\t|获取事件类型。\n|getX()\t\t\t\t\t|获得触摸点在当前 View 的 X 轴坐标。\n|getY()\t\t\t\t\t|获得触摸点在当前 View 的 Y 轴坐标。\n|getRawX()\t\t\t\t|获得触摸点在整个屏幕的 X 轴坐标。\n|getRawY()\t\t\t\t|获得触摸点在整个屏幕的 Y 轴坐标。\n\n#### 多点触控\n\n多点触控获取事件类型请使用 getActionMasked() 。\n追踪事件流请使用 PointId。\n\n##### index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\n\nindex\n1、从 0 开始，自动增长。\n2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。\n3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。\n4、对 move 事件无效\n\npointId\n1. 从 0 开始，自动增长。\n2. 落下手指时优先填补空缺(填补之前抬起手指的编号)。\n\n\n","slug":"android-touch","published":1,"updated":"2017-12-14T07:26:23.332Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awcz0005kku0unw1g4va","content":"<h1 id=\"android-事件机制全解\"><a href=\"#android-事件机制全解\" class=\"headerlink\" title=\"android 事件机制全解\"></a>android 事件机制全解</h1><p>一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; View</p>\n<p>默认情况下（没有自己重写派发拦截）从Activity A—-&gt;ViewGroup B—&gt;View C，从上往下调用dispatchTouchEvent()<br>再由View C—&gt;ViewGroup B —&gt;Activity A，从下往上调用onTouchEvent()</p>\n<a id=\"more\"></a>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"事件传递方法-（执行顺序如下）\"><a href=\"#事件传递方法-（执行顺序如下）\" class=\"headerlink\" title=\"事件传递方法 （执行顺序如下）\"></a>事件传递方法 （执行顺序如下）</h2><h3 id=\"事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\"><a href=\"#事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\" class=\"headerlink\" title=\"事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\"></a>事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View</h3><p>当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用</p>\n<p>返回值<br>super：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th style=\"text-align:right\">返回方法</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Activity</td>\n<td style=\"text-align:right\">super.dispatchTouchEvent()</td>\n<td style=\"text-align:center\">即调用父类ViewGroup的dispatchTouchEvent()    </td>\n</tr>\n<tr>\n<td>ViewGroup</td>\n<td style=\"text-align:right\">onIntercepTouchEvent()</td>\n<td style=\"text-align:center\">即调用自身的onIntercepTouchEvent()    </td>\n</tr>\n<tr>\n<td>View</td>\n<td style=\"text-align:right\">onTouchEvent（）</td>\n<td style=\"text-align:center\">即调用自身的onTouchEvent（）    </td>\n</tr>\n</tbody>\n</table>\n<p>true：消费事件，即事件不继续往下传递<br>false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理</p>\n<h3 id=\"事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\"><a href=\"#事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\" class=\"headerlink\" title=\"事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\"></a>事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）</h3><p>调用时刻 在ViewGroup的dispatchTouchEvent()内部调用</p>\n<p>返回值<br>ture ：调用自身的onTouchEvent（）<br>super | false : 调用子类的dispatchTouchEvent()</p>\n<h3 id=\"事件处理-onTouchEvent\"><a href=\"#事件处理-onTouchEvent\" class=\"headerlink\" title=\"事件处理 onTouchEvent()\"></a>事件处理 onTouchEvent()</h3><table>\n<thead>\n<tr>\n<th>事件</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACTION_DOWN</td>\n<td style=\"text-align:center\">手指 初次接触到屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_MOVE</td>\n<td style=\"text-align:center\">手指 在屏幕上滑动 时触发，会多次触发。</td>\n</tr>\n<tr>\n<td>ACTION_UP</td>\n<td style=\"text-align:center\">手指 离开屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_CANCEL</td>\n<td style=\"text-align:center\">事件 被上层拦截 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_OUTSIDE</td>\n<td style=\"text-align:center\">手指 不在控件区域 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_DOWN</td>\n<td style=\"text-align:center\">有非主要的手指按下(即按下之前已经有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_UP</td>\n<td style=\"text-align:center\">有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>getAction()</td>\n<td style=\"text-align:center\">获取事件类型。</td>\n</tr>\n<tr>\n<td>getX()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getY()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 Y 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawX()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawY()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 Y 轴坐标。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"多点触控\"><a href=\"#多点触控\" class=\"headerlink\" title=\"多点触控\"></a>多点触控</h4><p>多点触控获取事件类型请使用 getActionMasked() 。<br>追踪事件流请使用 PointId。</p>\n<h5 id=\"index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\"><a href=\"#index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\" class=\"headerlink\" title=\"index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\"></a>index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)</h5><p>index<br>1、从 0 开始，自动增长。<br>2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。<br>3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。<br>4、对 move 事件无效</p>\n<p>pointId</p>\n<ol>\n<li>从 0 开始，自动增长。</li>\n<li>落下手指时优先填补空缺(填补之前抬起手指的编号)。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h1 id=\"android-事件机制全解\"><a href=\"#android-事件机制全解\" class=\"headerlink\" title=\"android 事件机制全解\"></a>android 事件机制全解</h1><p>一个点击事件产生后，传递顺序是：Activity（Window） -&gt; ViewGroup -&gt; View</p>\n<p>默认情况下（没有自己重写派发拦截）从Activity A—-&gt;ViewGroup B—&gt;View C，从上往下调用dispatchTouchEvent()<br>再由View C—&gt;ViewGroup B —&gt;Activity A，从下往上调用onTouchEvent()</p>","more":"<p><img src=\"http://upload-images.jianshu.io/upload_images/944365-aa8416fc6d2e5ecd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"\"></p>\n<h2 id=\"事件传递方法-（执行顺序如下）\"><a href=\"#事件传递方法-（执行顺序如下）\" class=\"headerlink\" title=\"事件传递方法 （执行顺序如下）\"></a>事件传递方法 （执行顺序如下）</h2><h3 id=\"事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\"><a href=\"#事件派发-dispatchTouchEvent-使用对象-Activity、ViewGroup、View\" class=\"headerlink\" title=\"事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View\"></a>事件派发 dispatchTouchEvent() 使用对象 Activity、ViewGroup、View</h3><p>当点击事件能够传递给当前View时，该方法就会被调用，也就是该view（viewGroup）首先要有注册事件否则不会调用</p>\n<p>返回值<br>super：根据当前对象的不同而返回方法不同 （建议使用 ，不要随便返回true 或者 false）</p>\n<table>\n<thead>\n<tr>\n<th>对象</th>\n<th style=\"text-align:right\">返回方法</th>\n<th style=\"text-align:center\">说明    </th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Activity</td>\n<td style=\"text-align:right\">super.dispatchTouchEvent()</td>\n<td style=\"text-align:center\">即调用父类ViewGroup的dispatchTouchEvent()    </td>\n</tr>\n<tr>\n<td>ViewGroup</td>\n<td style=\"text-align:right\">onIntercepTouchEvent()</td>\n<td style=\"text-align:center\">即调用自身的onIntercepTouchEvent()    </td>\n</tr>\n<tr>\n<td>View</td>\n<td style=\"text-align:right\">onTouchEvent（）</td>\n<td style=\"text-align:center\">即调用自身的onTouchEvent（）    </td>\n</tr>\n</tbody>\n</table>\n<p>true：消费事件，即事件不继续往下传递<br>false：不消费事件，事件也不继续往下传递 / 交由给父控件onTouchEvent（）处理</p>\n<h3 id=\"事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\"><a href=\"#事件拦截-onInterceptTouchEvent-使用对象-ViewGroup（注：Activity、View都没该方法）\" class=\"headerlink\" title=\"事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）\"></a>事件拦截 onInterceptTouchEvent() 使用对象 ViewGroup（注：Activity、View都没该方法）</h3><p>调用时刻 在ViewGroup的dispatchTouchEvent()内部调用</p>\n<p>返回值<br>ture ：调用自身的onTouchEvent（）<br>super | false : 调用子类的dispatchTouchEvent()</p>\n<h3 id=\"事件处理-onTouchEvent\"><a href=\"#事件处理-onTouchEvent\" class=\"headerlink\" title=\"事件处理 onTouchEvent()\"></a>事件处理 onTouchEvent()</h3><table>\n<thead>\n<tr>\n<th>事件</th>\n<th style=\"text-align:center\">简介</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ACTION_DOWN</td>\n<td style=\"text-align:center\">手指 初次接触到屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_MOVE</td>\n<td style=\"text-align:center\">手指 在屏幕上滑动 时触发，会多次触发。</td>\n</tr>\n<tr>\n<td>ACTION_UP</td>\n<td style=\"text-align:center\">手指 离开屏幕 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_CANCEL</td>\n<td style=\"text-align:center\">事件 被上层拦截 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_OUTSIDE</td>\n<td style=\"text-align:center\">手指 不在控件区域 时触发。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_DOWN</td>\n<td style=\"text-align:center\">有非主要的手指按下(即按下之前已经有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>ACTION_POINTER_UP</td>\n<td style=\"text-align:center\">有非主要的手指抬起(即抬起之后仍然有手指在屏幕上)。</td>\n</tr>\n<tr>\n<td>getAction()</td>\n<td style=\"text-align:center\">获取事件类型。</td>\n</tr>\n<tr>\n<td>getX()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getY()</td>\n<td style=\"text-align:center\">获得触摸点在当前 View 的 Y 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawX()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 X 轴坐标。</td>\n</tr>\n<tr>\n<td>getRawY()</td>\n<td style=\"text-align:center\">获得触摸点在整个屏幕的 Y 轴坐标。</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"多点触控\"><a href=\"#多点触控\" class=\"headerlink\" title=\"多点触控\"></a>多点触控</h4><p>多点触控获取事件类型请使用 getActionMasked() 。<br>追踪事件流请使用 PointId。</p>\n<h5 id=\"index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\"><a href=\"#index-和-pointId-的变化规则-Index-会变化，pointId-始终不变。\" class=\"headerlink\" title=\"index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)\"></a>index 和 pointId 的变化规则 (Index 会变化，pointId 始终不变。)</h5><p>index<br>1、从 0 开始，自动增长。<br>2、如果之前落下的手指抬起，后面手指的 Index 会随之减小。<br>3、Index 变化趋向于第一次落下的数值(落下手指时，前面有空缺会优先填补空缺)。<br>4、对 move 事件无效</p>\n<p>pointId</p>\n<ol>\n<li>从 0 开始，自动增长。</li>\n<li>落下手指时优先填补空缺(填补之前抬起手指的编号)。</li>\n</ol>"},{"title":"canvas 启动","date":"2017-05-14T06:57:55.000Z","_content":"\n## 基本api\n|操作类型\t \t\t|相关API\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|备注\n| -----------   \t| -----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n|绘制颜色\t \t\t|drawColor, drawRGB, drawARGB\t|使用单一颜色填充整个画布\n|绘制基本形状\t\t|drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc\t|依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n|绘制图片\t\t\t|drawBitmap, drawPicture\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制位图和图片\n|绘制文本\t\t\t|drawText, drawPosText, drawTextOnPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n|绘制路径\t\t\t|drawPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制路径，绘制贝塞尔曲线时也需要用到该函数\n|顶点操作\t\t\t|drawVertices, drawBitmapMesh\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n|画布剪裁\t\t\t|clipPath, clipRect\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|设置画布的显示区域\n|画布快照\t\t\t|save, restore, saveLayerXxx, restoreToCount, getSaveCount\t\t\t\t\t\t\t\t\t\t\t|依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n|画布变换\t\t\t|translate, scale, rotate, skew\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 位移、缩放、 旋转、错切\n|Matrix(矩阵)\t\t|getMatrix, setMatrix, concat\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n\n<!-- more -->\n\n## save and restore\n\nsave方法用于临时保存画布坐标系统的状态\nrestore方法可以用来恢复save之后设置的状态\n可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，\n但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。\n\n## translate, scale, rotate\n通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,-400,400,0);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.scale(-0.5f,-0.5f);              // 画布缩放  图1\n// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  <-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2\n\n//canvas.rotate(180);                     // 旋转180度 <-- 默认旋转中心为原点 图3\n// canvas.rotate(180,200,0);            // 旋转180度 <-- 旋转中心向右偏移200个单位 图4\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![图1](http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg)\n\n![图2](http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg)\n\n![图3](http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg)\n\n## skew \nskew这里翻译为错切，错切是特殊类型的线性变换。\n\n错切只提供了一种方法：\n\npublic void skew (float sx, float sy)\n参数含义：\nfloat sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，\nfloat sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,0,200,200);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.skew(1,0);                       // 水平错切 <- 45度\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![](https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf)\n\n\n","source":"_posts/canvas.md","raw":"---\ntitle: canvas 启动\ndate: 2017-05-14 14:57:55\ncategories: android\ntags: [自定义view,canvas]\n---\n\n## 基本api\n|操作类型\t \t\t|相关API\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|备注\n| -----------   \t| -----:   \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t| :----: |\n|绘制颜色\t \t\t|drawColor, drawRGB, drawARGB\t|使用单一颜色填充整个画布\n|绘制基本形状\t\t|drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc\t|依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧\n|绘制图片\t\t\t|drawBitmap, drawPicture\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制位图和图片\n|绘制文本\t\t\t|drawText, drawPosText, drawTextOnPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字\n|绘制路径\t\t\t|drawPath\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|绘制路径，绘制贝塞尔曲线时也需要用到该函数\n|顶点操作\t\t\t|drawVertices, drawBitmapMesh\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用\n|画布剪裁\t\t\t|clipPath, clipRect\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|设置画布的显示区域\n|画布快照\t\t\t|save, restore, saveLayerXxx, restoreToCount, getSaveCount\t\t\t\t\t\t\t\t\t\t\t|依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数\n|画布变换\t\t\t|translate, scale, rotate, skew\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|依次为 位移、缩放、 旋转、错切\n|Matrix(矩阵)\t\t|getMatrix, setMatrix, concat\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。\n\n<!-- more -->\n\n## save and restore\n\nsave方法用于临时保存画布坐标系统的状态\nrestore方法可以用来恢复save之后设置的状态\n可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，\n但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。\n\n## translate, scale, rotate\n通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,-400,400,0);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.scale(-0.5f,-0.5f);              // 画布缩放  图1\n// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  <-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2\n\n//canvas.rotate(180);                     // 旋转180度 <-- 默认旋转中心为原点 图3\n// canvas.rotate(180,200,0);            // 旋转180度 <-- 旋转中心向右偏移200个单位 图4\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![图1](http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg)\n\n![图2](http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg)\n\n![图3](http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg)\n\n## skew \nskew这里翻译为错切，错切是特殊类型的线性变换。\n\n错切只提供了一种方法：\n\npublic void skew (float sx, float sy)\n参数含义：\nfloat sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，\nfloat sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.\n``` bash\n// 将坐标系原点移动到画布正中心\ncanvas.translate(mWidth / 2, mHeight / 2);\n\nRectF rect = new RectF(0,0,200,200);   // 矩形区域\n\nmPaint.setColor(Color.BLACK);           // 绘制黑色矩形\ncanvas.drawRect(rect,mPaint);\n\ncanvas.skew(1,0);                       // 水平错切 <- 45度\n\nmPaint.setColor(Color.BLUE);            // 绘制蓝色矩形\ncanvas.drawRect(rect,mPaint);\n```\n![](https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf)\n\n\n","slug":"canvas","published":1,"updated":"2017-12-14T07:26:23.334Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awd00006kku0z46wr3uu","content":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>操作类型</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>绘制颜色</td>\n<td style=\"text-align:right\">drawColor, drawRGB, drawARGB</td>\n<td style=\"text-align:center\">使用单一颜色填充整个画布</td>\n</tr>\n<tr>\n<td>绘制基本形状</td>\n<td style=\"text-align:right\">drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td>\n<td style=\"text-align:center\">依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧</td>\n</tr>\n<tr>\n<td>绘制图片</td>\n<td style=\"text-align:right\">drawBitmap, drawPicture</td>\n<td style=\"text-align:center\">绘制位图和图片</td>\n</tr>\n<tr>\n<td>绘制文本</td>\n<td style=\"text-align:right\">drawText, drawPosText, drawTextOnPath</td>\n<td style=\"text-align:center\">依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字</td>\n</tr>\n<tr>\n<td>绘制路径</td>\n<td style=\"text-align:right\">drawPath</td>\n<td style=\"text-align:center\">绘制路径，绘制贝塞尔曲线时也需要用到该函数</td>\n</tr>\n<tr>\n<td>顶点操作</td>\n<td style=\"text-align:right\">drawVertices, drawBitmapMesh</td>\n<td style=\"text-align:center\">通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用</td>\n</tr>\n<tr>\n<td>画布剪裁</td>\n<td style=\"text-align:right\">clipPath, clipRect</td>\n<td style=\"text-align:center\">设置画布的显示区域</td>\n</tr>\n<tr>\n<td>画布快照</td>\n<td style=\"text-align:right\">save, restore, saveLayerXxx, restoreToCount, getSaveCount</td>\n<td style=\"text-align:center\">依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数</td>\n</tr>\n<tr>\n<td>画布变换</td>\n<td style=\"text-align:right\">translate, scale, rotate, skew</td>\n<td style=\"text-align:center\">依次为 位移、缩放、 旋转、错切</td>\n</tr>\n<tr>\n<td>Matrix(矩阵)</td>\n<td style=\"text-align:right\">getMatrix, setMatrix, concat</td>\n<td style=\"text-align:center\">实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"save-and-restore\"><a href=\"#save-and-restore\" class=\"headerlink\" title=\"save and restore\"></a>save and restore</h2><p>save方法用于临时保存画布坐标系统的状态<br>restore方法可以用来恢复save之后设置的状态<br>可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，<br>但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。</p>\n<h2 id=\"translate-scale-rotate\"><a href=\"#translate-scale-rotate\" class=\"headerlink\" title=\"translate, scale, rotate\"></a>translate, scale, rotate</h2><p>通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,-400,400,0);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.scale(-0.5f,-0.5f);              // 画布缩放  图1</div><div class=\"line\">// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  &lt;-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2</div><div class=\"line\"></div><div class=\"line\">//canvas.rotate(180);                     // 旋转180度 &lt;-- 默认旋转中心为原点 图3</div><div class=\"line\">// canvas.rotate(180,200,0);            // 旋转180度 &lt;-- 旋转中心向右偏移200个单位 图4</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg\" alt=\"图1\"></p>\n<p><img src=\"http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg\" alt=\"图2\"></p>\n<p><img src=\"http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg\" alt=\"图3\"></p>\n<h2 id=\"skew\"><a href=\"#skew\" class=\"headerlink\" title=\"skew\"></a>skew</h2><p>skew这里翻译为错切，错切是特殊类型的线性变换。</p>\n<p>错切只提供了一种方法：</p>\n<p>public void skew (float sx, float sy)<br>参数含义：<br>float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，<br>float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,0,200,200);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.skew(1,0);                       // 水平错切 &lt;- 45度</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf\" alt=\"\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>操作类型</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>绘制颜色</td>\n<td style=\"text-align:right\">drawColor, drawRGB, drawARGB</td>\n<td style=\"text-align:center\">使用单一颜色填充整个画布</td>\n</tr>\n<tr>\n<td>绘制基本形状</td>\n<td style=\"text-align:right\">drawPoint, drawPoints, drawLine, drawLines, drawRect, drawRoundRect, drawOval, drawCircle, drawArc</td>\n<td style=\"text-align:center\">依次为 点、线、矩形、圆角矩形、椭圆、圆、圆弧</td>\n</tr>\n<tr>\n<td>绘制图片</td>\n<td style=\"text-align:right\">drawBitmap, drawPicture</td>\n<td style=\"text-align:center\">绘制位图和图片</td>\n</tr>\n<tr>\n<td>绘制文本</td>\n<td style=\"text-align:right\">drawText, drawPosText, drawTextOnPath</td>\n<td style=\"text-align:center\">依次为 绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字</td>\n</tr>\n<tr>\n<td>绘制路径</td>\n<td style=\"text-align:right\">drawPath</td>\n<td style=\"text-align:center\">绘制路径，绘制贝塞尔曲线时也需要用到该函数</td>\n</tr>\n<tr>\n<td>顶点操作</td>\n<td style=\"text-align:right\">drawVertices, drawBitmapMesh</td>\n<td style=\"text-align:center\">通过对顶点操作可以使图像形变，drawVertices直接对画布作用、 drawBitmapMesh只对绘制的Bitmap作用</td>\n</tr>\n<tr>\n<td>画布剪裁</td>\n<td style=\"text-align:right\">clipPath, clipRect</td>\n<td style=\"text-align:center\">设置画布的显示区域</td>\n</tr>\n<tr>\n<td>画布快照</td>\n<td style=\"text-align:right\">save, restore, saveLayerXxx, restoreToCount, getSaveCount</td>\n<td style=\"text-align:center\">依次为 保存当前状态、 回滚到上一次保存的状态、 保存图层状态、 回滚到指定状态、 获取保存次数</td>\n</tr>\n<tr>\n<td>画布变换</td>\n<td style=\"text-align:right\">translate, scale, rotate, skew</td>\n<td style=\"text-align:center\">依次为 位移、缩放、 旋转、错切</td>\n</tr>\n<tr>\n<td>Matrix(矩阵)</td>\n<td style=\"text-align:right\">getMatrix, setMatrix, concat</td>\n<td style=\"text-align:center\">实际上画布的位移，缩放等操作的都是图像矩阵Matrix， 只不过Matrix比较难以理解和使用，故封装了一些常用的方法。</td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"save-and-restore\"><a href=\"#save-and-restore\" class=\"headerlink\" title=\"save and restore\"></a>save and restore</h2><p>save方法用于临时保存画布坐标系统的状态<br>restore方法可以用来恢复save之后设置的状态<br>可以简单理解为调用restore之后，restore方法前调用的rotate/translate/scale方法全部就还原了，画布的坐标系统恢复到save方法之前，<br>但是这里要注意的是，restore方法的调用只影响restore之后绘制的内容，对restore之前已经绘制到屏幕上的图形不会产生任何影响。</p>\n<h2 id=\"translate-scale-rotate\"><a href=\"#translate-scale-rotate\" class=\"headerlink\" title=\"translate, scale, rotate\"></a>translate, scale, rotate</h2><p>通过代码来简单了解(值得注意的是当缩放比例为负数的时候会根据缩放中心轴进行翻转)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,-400,400,0);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.scale(-0.5f,-0.5f);              // 画布缩放  图1</div><div class=\"line\">// canvas.scale(-0.5f,-0.5f,200,0);     // 画布缩放  &lt;-- 缩放中心向右偏移了200个单位,本次对缩放中心点y轴坐标进行了偏移，故中心轴也向右偏移了,图2</div><div class=\"line\"></div><div class=\"line\">//canvas.rotate(180);                     // 旋转180度 &lt;-- 默认旋转中心为原点 图3</div><div class=\"line\">// canvas.rotate(180,200,0);            // 旋转180度 &lt;-- 旋转中心向右偏移200个单位 图4</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://img2.ph.126.net/xnLkJXCCaNwDUOAwSJRxig==/6632403672327370448.jpg\" alt=\"图1\"></p>\n<p><img src=\"http://img0.ph.126.net/GClAkrn36_HGx36y7QBwxQ==/6632269531908790611.jpg\" alt=\"图2\"></p>\n<p><img src=\"http://img1.ph.126.net/ZMbhakNpxk-9JdH0oUKiYg==/6631961668655680492.jpg\" alt=\"图3\"></p>\n<h2 id=\"skew\"><a href=\"#skew\" class=\"headerlink\" title=\"skew\"></a>skew</h2><p>skew这里翻译为错切，错切是特殊类型的线性变换。</p>\n<p>错切只提供了一种方法：</p>\n<p>public void skew (float sx, float sy)<br>参数含义：<br>float sx:将画布在x方向上倾斜相应的角度，sx倾斜角度的tan值，<br>float sy:将画布在y轴方向上倾斜相应的角度，sy为倾斜角度的tan值.<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 将坐标系原点移动到画布正中心</div><div class=\"line\">canvas.translate(mWidth / 2, mHeight / 2);</div><div class=\"line\"></div><div class=\"line\">RectF rect = new RectF(0,0,200,200);   // 矩形区域</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLACK);           // 绘制黑色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div><div class=\"line\"></div><div class=\"line\">canvas.skew(1,0);                       // 水平错切 &lt;- 45度</div><div class=\"line\"></div><div class=\"line\">mPaint.setColor(Color.BLUE);            // 绘制蓝色矩形</div><div class=\"line\">canvas.drawRect(rect,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"https://ws3.sinaimg.cn/large/cf673337jw1f8mjhvhfluj208c0etjrf\" alt=\"\"></p>"},{"title":"hellow world","date":"2017-05-09T09:04:24.000Z","_content":"``` bash\n    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么\n可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说\n错了是我，没有们，没有听众依然飞舞着 my paint）\n```","source":"_posts/fdbook.md","raw":"---\ntitle: hellow world\ndate: 2017-05-09 17:04:24\ncategories: fdbook\ntags:\n---\n``` bash\n    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么\n可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说\n错了是我，没有们，没有听众依然飞舞着 my paint）\n```","slug":"fdbook","published":1,"updated":"2017-12-14T07:26:23.336Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awd20009kku0fl68m2l1","content":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么</div><div class=\"line\">可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说</div><div class=\"line\">错了是我，没有们，没有听众依然飞舞着 my paint）</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">    已经忘了有多久没有动笔了！也忘了多久没有加墨了，生锈的笔，生锈的我，不知道自己还能写出什么，或许是个笑话，毕竟我这么</div><div class=\"line\">可笑，哦不，搞笑，以前的我喜欢把开心不开心的写到故事里，回忆太过放肆，一笔一段人生，now，让我们开始新的旅程吧（ps 说</div><div class=\"line\">错了是我，没有们，没有听众依然飞舞着 my paint）</div></pre></td></tr></table></figure>"},{"title":"canvas 基本绘制","date":"2017-05-22T15:26:00.000Z","_content":"\n## drawText\n``` bash\n/** \n* text:要绘制的文字 \n* x：绘制原点x坐标 \n* y：绘制原点y坐标 \n* paint:用来做画的画笔 \n*/  \npublic void drawText(String text, float x, float y, Paint paint)\n```\n<!-- more -->\n\n值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！\n![](http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg)\n还有就是x的位置会被Paint影响,x是相对位置\n paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT\n 比如设置CENTER\n![](http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png)\n\n``` bash\n//计算各线在位置  \nPaint.FontMetrics fm = paint.getFontMetrics();  \nfloat ascent = baseLineY + fm.ascent;  \nfloat descent = baseLineY + fm.descent;  \nfloat top = baseLineY + fm.top;  \nfloat bottom = baseLineY + fm.bottom; \n```\n\n## drawRoundRect\n``` bash\n// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRoundRect(rectF,30,30,mPaint);\n// 第二种\ncanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n\n多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图\n```\n![](http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png)\n\n## drawArc 绘制圆弧\n``` bash\n// 第一种\npublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint){}\n    \n// 第二种\npublic void drawArc(float left, float top, float right, float bottom, float startAngle,\n            float sweepAngle, boolean useCenter, @NonNull Paint paint) {}\n\n// 开始角度 startAngle\n// 扫过角度 sweepAngle\n// 是否使用中心 useCenter\n```\n用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下\n``` bash\nRectF rectF = new RectF(100,100,800,400);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF,0,90,false,mPaint);\n\n//-------------------------------------\n\nRectF rectF2 = new RectF(100,600,800,900);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF2,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF2,0,90,true,mPaint);\n```\n![](http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg)\n\n## drawPicture\nPicture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容\n\n``` bash \n// 1.创建Picture\nprivate Picture mPicture = new Picture();\n\n---------------------------------------------------------------\n\n// 2.录制内容方法\nprivate void recording() {\n    // 开始录制 (接收返回值Canvas)\n    Canvas canvas = mPicture.beginRecording(500, 500);\n    // 创建一个画笔\n    Paint paint = new Paint();\n    paint.setColor(Color.BLUE);\n    paint.setStyle(Paint.Style.FILL);\n\n    // 在Canvas中具体操作\n    // 位移\n    canvas.translate(250,250);\n    // 绘制一个圆\n    canvas.drawCircle(0,0,100,paint);\n\n    mPicture.endRecording();\n}\n\n---------------------------------------------------------------\n\n// 3.在使用前调用(我在构造函数中调用了)\n  public Canvas3(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    \n    recording();    // 调用录制\n}\n```\n\n具体使用:\n\n``` bash\n1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);\n2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));\n3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制\n// 包装成为Drawable\nPictureDrawable drawable = new PictureDrawable(mPicture);\n// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\ndrawable.setBounds(0,0,250,mPicture.getHeight());\n// 绘制\ndrawable.draw(canvas);\n```\n\n","source":"_posts/canvas_1.md","raw":"---\ntitle: canvas 基本绘制\ndate: 2017-05-22 23:26:00\ncategories: android\ntags: [自定义view,canvas]\n---\n\n## drawText\n``` bash\n/** \n* text:要绘制的文字 \n* x：绘制原点x坐标 \n* y：绘制原点y坐标 \n* paint:用来做画的画笔 \n*/  \npublic void drawText(String text, float x, float y, Paint paint)\n```\n<!-- more -->\n\n值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！\n![](http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg)\n还有就是x的位置会被Paint影响,x是相对位置\n paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT\n 比如设置CENTER\n![](http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png)\n\n``` bash\n//计算各线在位置  \nPaint.FontMetrics fm = paint.getFontMetrics();  \nfloat ascent = baseLineY + fm.ascent;  \nfloat descent = baseLineY + fm.descent;  \nfloat top = baseLineY + fm.top;  \nfloat bottom = baseLineY + fm.bottom; \n```\n\n## drawRoundRect\n``` bash\n// 第一种\nRectF rectF = new RectF(100,100,800,400);\ncanvas.drawRoundRect(rectF,30,30,mPaint);\n// 第二种\ncanvas.drawRoundRect(100,100,800,400,30,30,mPaint);\n\n多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图\n```\n![](http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png)\n\n## drawArc 绘制圆弧\n``` bash\n// 第一种\npublic void drawArc(@NonNull RectF oval, float startAngle, float sweepAngle, boolean useCenter, @NonNull Paint paint){}\n    \n// 第二种\npublic void drawArc(float left, float top, float right, float bottom, float startAngle,\n            float sweepAngle, boolean useCenter, @NonNull Paint paint) {}\n\n// 开始角度 startAngle\n// 扫过角度 sweepAngle\n// 是否使用中心 useCenter\n```\n用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下\n``` bash\nRectF rectF = new RectF(100,100,800,400);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF,0,90,false,mPaint);\n\n//-------------------------------------\n\nRectF rectF2 = new RectF(100,600,800,900);\n// 绘制背景矩形\nmPaint.setColor(Color.GRAY);\ncanvas.drawRect(rectF2,mPaint);\n\n// 绘制圆弧\nmPaint.setColor(Color.BLUE);\ncanvas.drawArc(rectF2,0,90,true,mPaint);\n```\n![](http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg)\n\n## drawPicture\nPicture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容\n\n``` bash \n// 1.创建Picture\nprivate Picture mPicture = new Picture();\n\n---------------------------------------------------------------\n\n// 2.录制内容方法\nprivate void recording() {\n    // 开始录制 (接收返回值Canvas)\n    Canvas canvas = mPicture.beginRecording(500, 500);\n    // 创建一个画笔\n    Paint paint = new Paint();\n    paint.setColor(Color.BLUE);\n    paint.setStyle(Paint.Style.FILL);\n\n    // 在Canvas中具体操作\n    // 位移\n    canvas.translate(250,250);\n    // 绘制一个圆\n    canvas.drawCircle(0,0,100,paint);\n\n    mPicture.endRecording();\n}\n\n---------------------------------------------------------------\n\n// 3.在使用前调用(我在构造函数中调用了)\n  public Canvas3(Context context, AttributeSet attrs) {\n    super(context, attrs);\n    \n    recording();    // 调用录制\n}\n```\n\n具体使用:\n\n``` bash\n1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);\n2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));\n3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制\n// 包装成为Drawable\nPictureDrawable drawable = new PictureDrawable(mPicture);\n// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放\ndrawable.setBounds(0,0,250,mPicture.getHeight());\n// 绘制\ndrawable.draw(canvas);\n```\n\n","slug":"canvas_1","published":1,"updated":"2017-12-14T07:26:23.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awd4000bkku06p8i1nrg","content":"<h2 id=\"drawText\"><a href=\"#drawText\" class=\"headerlink\" title=\"drawText\"></a>drawText</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\">* text:要绘制的文字 </div><div class=\"line\">* x：绘制原点x坐标 </div><div class=\"line\">* y：绘制原点y坐标 </div><div class=\"line\">* paint:用来做画的画笔 </div><div class=\"line\">*/  </div><div class=\"line\">public void drawText(String text, <span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, Paint paint)</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！<br><img src=\"http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg\" alt=\"\"><br>还有就是x的位置会被Paint影响,x是相对位置<br> paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT<br> 比如设置CENTER<br><img src=\"http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png\" alt=\"\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//计算各线在位置  </div><div class=\"line\">Paint.FontMetrics fm = paint.getFontMetrics();  </div><div class=\"line\"><span class=\"built_in\">float</span> ascent = baseLineY + fm.ascent;  </div><div class=\"line\"><span class=\"built_in\">float</span> descent = baseLineY + fm.descent;  </div><div class=\"line\"><span class=\"built_in\">float</span> top = baseLineY + fm.top;  </div><div class=\"line\"><span class=\"built_in\">float</span> bottom = baseLineY + fm.bottom;</div></pre></td></tr></table></figure>\n<h2 id=\"drawRoundRect\"><a href=\"#drawRoundRect\" class=\"headerlink\" title=\"drawRoundRect\"></a>drawRoundRect</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">canvas.drawRoundRect(rectF,30,30,mPaint);</div><div class=\"line\">// 第二种</div><div class=\"line\">canvas.drawRoundRect(100,100,800,400,30,30,mPaint);</div><div class=\"line\"></div><div class=\"line\">多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图</div></pre></td></tr></table></figure>\n<p><img src=\"http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png\" alt=\"\"></p>\n<h2 id=\"drawArc-绘制圆弧\"><a href=\"#drawArc-绘制圆弧\" class=\"headerlink\" title=\"drawArc 绘制圆弧\"></a>drawArc 绘制圆弧</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">public void drawArc(@NonNull RectF oval, <span class=\"built_in\">float</span> startAngle, <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint)&#123;&#125;</div><div class=\"line\">    </div><div class=\"line\">// 第二种</div><div class=\"line\">public void drawArc(<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, <span class=\"built_in\">float</span> startAngle,</div><div class=\"line\">            <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">// 开始角度 startAngle</div><div class=\"line\">// 扫过角度 sweepAngle</div><div class=\"line\">// 是否使用中心 useCenter</div></pre></td></tr></table></figure>\n<p>用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF,0,90,<span class=\"literal\">false</span>,mPaint);</div><div class=\"line\"></div><div class=\"line\">//-------------------------------------</div><div class=\"line\"></div><div class=\"line\">RectF rectF2 = new RectF(100,600,800,900);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF2,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF2,0,90,<span class=\"literal\">true</span>,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg\" alt=\"\"></p>\n<h2 id=\"drawPicture\"><a href=\"#drawPicture\" class=\"headerlink\" title=\"drawPicture\"></a>drawPicture</h2><p>Picture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建Picture</div><div class=\"line\">private Picture mPicture = new Picture();</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 2.录制内容方法</div><div class=\"line\">private void <span class=\"function\"><span class=\"title\">recording</span></span>() &#123;</div><div class=\"line\">    // 开始录制 (接收返回值Canvas)</div><div class=\"line\">    Canvas canvas = mPicture.beginRecording(500, 500);</div><div class=\"line\">    // 创建一个画笔</div><div class=\"line\">    Paint paint = new Paint();</div><div class=\"line\">    paint.setColor(Color.BLUE);</div><div class=\"line\">    paint.setStyle(Paint.Style.FILL);</div><div class=\"line\"></div><div class=\"line\">    // 在Canvas中具体操作</div><div class=\"line\">    // 位移</div><div class=\"line\">    canvas.translate(250,250);</div><div class=\"line\">    // 绘制一个圆</div><div class=\"line\">    canvas.drawCircle(0,0,100,paint);</div><div class=\"line\"></div><div class=\"line\">    mPicture.endRecording();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 3.在使用前调用(我在构造函数中调用了)</div><div class=\"line\">  public Canvas3(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    super(context, attrs);</div><div class=\"line\">    </div><div class=\"line\">    recording();    // 调用录制</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体使用:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);</div><div class=\"line\">2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));</div><div class=\"line\">3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制</div><div class=\"line\">// 包装成为Drawable</div><div class=\"line\">PictureDrawable drawable = new PictureDrawable(mPicture);</div><div class=\"line\">// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放</div><div class=\"line\">drawable.setBounds(0,0,250,mPicture.getHeight());</div><div class=\"line\">// 绘制</div><div class=\"line\">drawable.draw(canvas);</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"drawText\"><a href=\"#drawText\" class=\"headerlink\" title=\"drawText\"></a>drawText</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">/** </div><div class=\"line\">* text:要绘制的文字 </div><div class=\"line\">* x：绘制原点x坐标 </div><div class=\"line\">* y：绘制原点y坐标 </div><div class=\"line\">* paint:用来做画的画笔 </div><div class=\"line\">*/  </div><div class=\"line\">public void drawText(String text, <span class=\"built_in\">float</span> x, <span class=\"built_in\">float</span> y, Paint paint)</div></pre></td></tr></table></figure>","more":"<p>值得注意的是在drawText中是非常例外的，y所代表的是基线的位置！<br><img src=\"http://img2.ph.126.net/FG_IL21IqoAowpXxQNGOeg==/6632257437280879751.jpg\" alt=\"\"><br>还有就是x的位置会被Paint影响,x是相对位置<br> paint.setTextAlign(Paint.Align.LEFT);// Panit.Align.LEFT,Paint.Align.CENTER,Paint.Align.RIGHT<br> 比如设置CENTER<br><img src=\"http://img2.ph.126.net/TdkmsfzuPc_7AhALo4364g==/6632509225443640256.png\" alt=\"\"></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">//计算各线在位置  </div><div class=\"line\">Paint.FontMetrics fm = paint.getFontMetrics();  </div><div class=\"line\"><span class=\"built_in\">float</span> ascent = baseLineY + fm.ascent;  </div><div class=\"line\"><span class=\"built_in\">float</span> descent = baseLineY + fm.descent;  </div><div class=\"line\"><span class=\"built_in\">float</span> top = baseLineY + fm.top;  </div><div class=\"line\"><span class=\"built_in\">float</span> bottom = baseLineY + fm.bottom;</div></pre></td></tr></table></figure>\n<h2 id=\"drawRoundRect\"><a href=\"#drawRoundRect\" class=\"headerlink\" title=\"drawRoundRect\"></a>drawRoundRect</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">canvas.drawRoundRect(rectF,30,30,mPaint);</div><div class=\"line\">// 第二种</div><div class=\"line\">canvas.drawRoundRect(100,100,800,400,30,30,mPaint);</div><div class=\"line\"></div><div class=\"line\">多出来了两个参数rx 和 ry，这里圆角矩形的角实际上不是一个正圆的圆弧，而是椭圆的圆弧，这里的两个参数实际上是椭圆的两个半径，他们看起来个如下图</div></pre></td></tr></table></figure>\n<p><img src=\"http://img0.ph.126.net/bY-vUOCI2jSs4okFYMLkVw==/6632270631420417891.png\" alt=\"\"></p>\n<h2 id=\"drawArc-绘制圆弧\"><a href=\"#drawArc-绘制圆弧\" class=\"headerlink\" title=\"drawArc 绘制圆弧\"></a>drawArc 绘制圆弧</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 第一种</div><div class=\"line\">public void drawArc(@NonNull RectF oval, <span class=\"built_in\">float</span> startAngle, <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint)&#123;&#125;</div><div class=\"line\">    </div><div class=\"line\">// 第二种</div><div class=\"line\">public void drawArc(<span class=\"built_in\">float</span> left, <span class=\"built_in\">float</span> top, <span class=\"built_in\">float</span> right, <span class=\"built_in\">float</span> bottom, <span class=\"built_in\">float</span> startAngle,</div><div class=\"line\">            <span class=\"built_in\">float</span> sweepAngle, boolean useCenter, @NonNull Paint paint) &#123;&#125;</div><div class=\"line\"></div><div class=\"line\">// 开始角度 startAngle</div><div class=\"line\">// 扫过角度 sweepAngle</div><div class=\"line\">// 是否使用中心 useCenter</div></pre></td></tr></table></figure>\n<p>用法：先确定一个Rect，起始角度是Rect中心水平向右，顺时针画，例子如下<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">RectF rectF = new RectF(100,100,800,400);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF,0,90,<span class=\"literal\">false</span>,mPaint);</div><div class=\"line\"></div><div class=\"line\">//-------------------------------------</div><div class=\"line\"></div><div class=\"line\">RectF rectF2 = new RectF(100,600,800,900);</div><div class=\"line\">// 绘制背景矩形</div><div class=\"line\">mPaint.setColor(Color.GRAY);</div><div class=\"line\">canvas.drawRect(rectF2,mPaint);</div><div class=\"line\"></div><div class=\"line\">// 绘制圆弧</div><div class=\"line\">mPaint.setColor(Color.BLUE);</div><div class=\"line\">canvas.drawArc(rectF2,0,90,<span class=\"literal\">true</span>,mPaint);</div></pre></td></tr></table></figure></p>\n<p><img src=\"http://ww1.sinaimg.cn/large/005Xtdi2jw1f8f0ijg8pvj308c0ett8m.jpg\" alt=\"\"></p>\n<h2 id=\"drawPicture\"><a href=\"#drawPicture\" class=\"headerlink\" title=\"drawPicture\"></a>drawPicture</h2><p>Picture看作是一个录制Canvas操作的录像机，录的是Canvas中绘制的内容</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">// 1.创建Picture</div><div class=\"line\">private Picture mPicture = new Picture();</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 2.录制内容方法</div><div class=\"line\">private void <span class=\"function\"><span class=\"title\">recording</span></span>() &#123;</div><div class=\"line\">    // 开始录制 (接收返回值Canvas)</div><div class=\"line\">    Canvas canvas = mPicture.beginRecording(500, 500);</div><div class=\"line\">    // 创建一个画笔</div><div class=\"line\">    Paint paint = new Paint();</div><div class=\"line\">    paint.setColor(Color.BLUE);</div><div class=\"line\">    paint.setStyle(Paint.Style.FILL);</div><div class=\"line\"></div><div class=\"line\">    // 在Canvas中具体操作</div><div class=\"line\">    // 位移</div><div class=\"line\">    canvas.translate(250,250);</div><div class=\"line\">    // 绘制一个圆</div><div class=\"line\">    canvas.drawCircle(0,0,100,paint);</div><div class=\"line\"></div><div class=\"line\">    mPicture.endRecording();</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">---------------------------------------------------------------</div><div class=\"line\"></div><div class=\"line\">// 3.在使用前调用(我在构造函数中调用了)</div><div class=\"line\">  public Canvas3(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    super(context, attrs);</div><div class=\"line\">    </div><div class=\"line\">    recording();    // 调用录制</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>具体使用:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">1. 使用Picture提供的draw方法绘制  \t\t\t\t\t\t\t\t\t\tmPicture.draw(canvas);</div><div class=\"line\">2. 使用Canvas提供的drawPicture方法绘制      \t\t\t\t\t\t\tcanvas.drawPicture(mPicture,new RectF(0,0,mPicture.getWidth(),200));</div><div class=\"line\">3.将Picture包装成为PictureDrawable，使用PictureDrawable的draw方法绘制</div><div class=\"line\">// 包装成为Drawable</div><div class=\"line\">PictureDrawable drawable = new PictureDrawable(mPicture);</div><div class=\"line\">// 设置绘制区域 -- 注意此处所绘制的实际内容不会缩放</div><div class=\"line\">drawable.setBounds(0,0,250,mPicture.getHeight());</div><div class=\"line\">// 绘制</div><div class=\"line\">drawable.draw(canvas);</div></pre></td></tr></table></figure>"},{"title":"Hello Hexo","date":"2017-05-08T16:00:00.000Z","_content":"\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.下载安装[Node.js](https://nodejs.org/en/)（一路next）\n3.下载hexo： 命令行 输入\n``` bash\n$ npm install -g hexo-cli\n```\n<!-- more -->\n\n4.验证软件是否成功安装\n``` bash\n$ git --version\n$ node -v\n$ npm -v\n$ hexo –v\n```\n5.新建GitHub版本库 \n注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名\n\n6.配置ssh\n（1）设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n（2）生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n7.初始化hexo\n（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开\ngit bash，输入\n``` bash\n$ hexo init\n```\n安装生成器 ：\n``` bash\n$ npm install\n```\n然后就可以新建文章了\n``` bash\n$ hexo new name\n```\n8.运行和部署hexo\n（1）本地查看 ：\n``` bash\n$ hexo g && hexo s –p 5000\n```\n浏览器输入localhost:5000,就可以在本地看到你的个人博客了 \n（2）上传git：\n下载插件：\n``` bash\n$ npm install hexo-deployer-git --save\n```\n修改工程目录下的_config.yml文件\n#发布设置\ndeploy: \n \t\ttype: git\n  \t\trepository: git@github.com:chenbaowu/chenbaowu.github.io.git\n  \t\tbranch: master\n运行 ：\n``` bash\n$ hexo g && hexo d\n```\n浏览器输入 http://chenbaowu.github.io/  就可以访问了\n\n9.主题更换\n（1）在工程目录下载主题 $ git clone https://github.com/litten/hexo-theme-yilia.git    themes/yilia\n（2）修改工程目录下的_config.yml文件 ：      theme:   yilia\n\n10.添加分类和标签\nmd文章头直接加就可以了\ncategories: fdbook\ntags: fdbook\n\n11.如何显示图片\n``` bash\n（1）本地：在工程目录下的source下新建文件夹images，使用例子： ![](/images/fd.jpg) \n（2）网络：![图片描叙](网路地址)\n```\n\n12.修改网站小图标\n在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg\n\n13.截取文章显示\n（1）在主题目录下修改_config.yml文件 ：excerpt_link: more\n（2）在文章需要截取的地方加上 \n``` bash\n <!-- more -->\n```\n14.加访客统计和文章统计\n\n[参考链接](https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/)\n\n15.评论功能\n!index 表示非主页中才显示\n\n[参考链接](http://moxfive.xyz/2016/01/02/hexo-comments/)\n\n    \n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello Hexo\ndate: 2017-05-09 00:00:00\ncategories: 多学\ntags: hexo\n---\n\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.下载安装[Node.js](https://nodejs.org/en/)（一路next）\n3.下载hexo： 命令行 输入\n``` bash\n$ npm install -g hexo-cli\n```\n<!-- more -->\n\n4.验证软件是否成功安装\n``` bash\n$ git --version\n$ node -v\n$ npm -v\n$ hexo –v\n```\n5.新建GitHub版本库 \n注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名\n\n6.配置ssh\n（1）设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n（2）生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n7.初始化hexo\n（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开\ngit bash，输入\n``` bash\n$ hexo init\n```\n安装生成器 ：\n``` bash\n$ npm install\n```\n然后就可以新建文章了\n``` bash\n$ hexo new name\n```\n8.运行和部署hexo\n（1）本地查看 ：\n``` bash\n$ hexo g && hexo s –p 5000\n```\n浏览器输入localhost:5000,就可以在本地看到你的个人博客了 \n（2）上传git：\n下载插件：\n``` bash\n$ npm install hexo-deployer-git --save\n```\n修改工程目录下的_config.yml文件\n#发布设置\ndeploy: \n \t\ttype: git\n  \t\trepository: git@github.com:chenbaowu/chenbaowu.github.io.git\n  \t\tbranch: master\n运行 ：\n``` bash\n$ hexo g && hexo d\n```\n浏览器输入 http://chenbaowu.github.io/  就可以访问了\n\n9.主题更换\n（1）在工程目录下载主题 $ git clone https://github.com/litten/hexo-theme-yilia.git    themes/yilia\n（2）修改工程目录下的_config.yml文件 ：      theme:   yilia\n\n10.添加分类和标签\nmd文章头直接加就可以了\ncategories: fdbook\ntags: fdbook\n\n11.如何显示图片\n``` bash\n（1）本地：在工程目录下的source下新建文件夹images，使用例子： ![](/images/fd.jpg) \n（2）网络：![图片描叙](网路地址)\n```\n\n12.修改网站小图标\n在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg\n\n13.截取文章显示\n（1）在主题目录下修改_config.yml文件 ：excerpt_link: more\n（2）在文章需要截取的地方加上 \n``` bash\n <!-- more -->\n```\n14.加访客统计和文章统计\n\n[参考链接](https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/)\n\n15.评论功能\n!index 表示非主页中才显示\n\n[参考链接](http://moxfive.xyz/2016/01/02/hexo-comments/)\n\n    \n","slug":"hello-world","published":1,"updated":"2017-12-14T07:26:23.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awd7000fkku0a1jw84vx","content":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.下载安装<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js</a>（一路next）<br>3.下载hexo： 命令行 输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>4.验证软件是否成功安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git --version</div><div class=\"line\">$ node -v</div><div class=\"line\">$ npm -v</div><div class=\"line\">$ hexo –v</div></pre></td></tr></table></figure></p>\n<p>5.新建GitHub版本库<br>注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名</p>\n<p>6.配置ssh<br>（1）设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>\n<p>（2）生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>7.初始化hexo<br>（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开<br>git bash，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init</div></pre></td></tr></table></figure></p>\n<p>安装生成器 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>然后就可以新建文章了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new name</div></pre></td></tr></table></figure></p>\n<p>8.运行和部署hexo<br>（1）本地查看 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo s –p 5000</div></pre></td></tr></table></figure></p>\n<p>浏览器输入localhost:5000,就可以在本地看到你的个人博客了<br>（2）上传git：<br>下载插件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>修改工程目录下的_config.yml文件</p>\n<p>#发布设置<br>deploy:<br>         type: git<br>          repository: git@github.com:chenbaowu/chenbaowu.github.io.git<br>          branch: master<br>运行 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo d</div></pre></td></tr></table></figure></p>\n<p>浏览器输入 <a href=\"http://chenbaowu.github.io/\" target=\"_blank\" rel=\"external\">http://chenbaowu.github.io/</a>  就可以访问了</p>\n<p>9.主题更换<br>（1）在工程目录下载主题 $ git clone <a href=\"https://github.com/litten/hexo-theme-yilia.git\" target=\"_blank\" rel=\"external\">https://github.com/litten/hexo-theme-yilia.git</a>    themes/yilia<br>（2）修改工程目录下的_config.yml文件 ：      theme:   yilia</p>\n<p>10.添加分类和标签<br>md文章头直接加就可以了<br>categories: fdbook<br>tags: fdbook</p>\n<p>11.如何显示图片<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）本地：在工程目录下的<span class=\"built_in\">source</span>下新建文件夹images，使用例子： ![](/images/fd.jpg) </div><div class=\"line\">（2）网络：![图片描叙](网路地址)</div></pre></td></tr></table></figure></p>\n<p>12.修改网站小图标<br>在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg</p>\n<p>13.截取文章显示<br>（1）在主题目录下修改_config.yml文件 ：excerpt_link: more<br>（2）在文章需要截取的地方加上<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- more --&gt;</div></pre></td></tr></table></figure></p>\n<p>14.加访客统计和文章统计</p>\n<p><a href=\"https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n<p>15.评论功能<br>!index 表示非主页中才显示</p>\n<p><a href=\"http://moxfive.xyz/2016/01/02/hexo-comments/\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n","site":{"data":{}},"excerpt":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.下载安装<a href=\"https://nodejs.org/en/\" target=\"_blank\" rel=\"external\">Node.js</a>（一路next）<br>3.下载hexo： 命令行 输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install -g hexo-cli</div></pre></td></tr></table></figure></p>","more":"<p>4.验证软件是否成功安装<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git --version</div><div class=\"line\">$ node -v</div><div class=\"line\">$ npm -v</div><div class=\"line\">$ hexo –v</div></pre></td></tr></table></figure></p>\n<p>5.新建GitHub版本库<br>注意工程名字一定是你的githua的名字 + github.io，也是你博客的域名</p>\n<p>6.配置ssh<br>（1）设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>\n<p>（2）生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>7.初始化hexo<br>（1）在你的电脑新建一个文件夹用来当hexo的工程目录，在里面右键打开<br>git bash，输入<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo init</div></pre></td></tr></table></figure></p>\n<p>安装生成器 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install</div></pre></td></tr></table></figure></p>\n<p>然后就可以新建文章了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo new name</div></pre></td></tr></table></figure></p>\n<p>8.运行和部署hexo<br>（1）本地查看 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo s –p 5000</div></pre></td></tr></table></figure></p>\n<p>浏览器输入localhost:5000,就可以在本地看到你的个人博客了<br>（2）上传git：<br>下载插件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>\n<p>修改工程目录下的_config.yml文件</p>\n<p>#发布设置<br>deploy:<br>         type: git<br>          repository: git@github.com:chenbaowu/chenbaowu.github.io.git<br>          branch: master<br>运行 ：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ hexo g &amp;&amp; hexo d</div></pre></td></tr></table></figure></p>\n<p>浏览器输入 <a href=\"http://chenbaowu.github.io/\" target=\"_blank\" rel=\"external\">http://chenbaowu.github.io/</a>  就可以访问了</p>\n<p>9.主题更换<br>（1）在工程目录下载主题 $ git clone <a href=\"https://github.com/litten/hexo-theme-yilia.git\" target=\"_blank\" rel=\"external\">https://github.com/litten/hexo-theme-yilia.git</a>    themes/yilia<br>（2）修改工程目录下的_config.yml文件 ：      theme:   yilia</p>\n<p>10.添加分类和标签<br>md文章头直接加就可以了<br>categories: fdbook<br>tags: fdbook</p>\n<p>11.如何显示图片<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">（1）本地：在工程目录下的<span class=\"built_in\">source</span>下新建文件夹images，使用例子： ![](/images/fd.jpg) </div><div class=\"line\">（2）网络：![图片描叙](网路地址)</div></pre></td></tr></table></figure></p>\n<p>12.修改网站小图标<br>在主题目录下修改_config.yml文件 ：favicon: /images/favicon.jpg</p>\n<p>13.截取文章显示<br>（1）在主题目录下修改_config.yml文件 ：excerpt_link: more<br>（2）在文章需要截取的地方加上<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- more --&gt;</div></pre></td></tr></table></figure></p>\n<p>14.加访客统计和文章统计</p>\n<p><a href=\"https://crane-yuan.github.io/2016/03/25/Hexo-05-add-site-statistics/\" target=\"_blank\" rel=\"external\">参考链接</a></p>\n<p>15.评论功能<br>!index 表示非主页中才显示</p>\n<p><a href=\"http://moxfive.xyz/2016/01/02/hexo-comments/\" target=\"_blank\" rel=\"external\">参考链接</a></p>"},{"title":"git","date":"2017-05-13T06:47:06.000Z","_content":"\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n<!-- more -->\n\n3.生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088@qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n4.初始化git,创建本地仓库\n``` bash\n$ git init\n```\n5.将文件加入暂存区\n``` bash\n$ git add . //将目录下所有文件加入暂存区，可以是文件名\n$ git add my_file,other_file //将目录下所有文件加入暂存区\n```\n6.提交本地仓库\n``` bash\n$ git commit -am \"初次提交\"\n```\n7.推送到远程仓库\n``` bash\n$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin \n$ git push origin master  // 客户端首次提交 ，以后直接 git push\n```\n8.实用命令\n``` bash\n$ git clone git@github..com:用户名/项目名.git // 克隆github的代码\n$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址\n$ git remote rm 远程仓库名 //  删除远程仓库\n$ git remote -v // 查看当前远程仓库地址\n$ git fetch origin master  // 取回origin的master分支\n$ git merge origin master // 将origin merge 到 master 上\n$ git push  // 相当于 fetch 加上 merge\n& git status  // 查看状态\n```\n","source":"_posts/git.md","raw":"---\ntitle: git\ndate: 2017-05-13 14:47:06\ncategories: 多学\ntags: git\n---\n\n1.下载安装[Git](https://git-scm.com/downloads)（一路next）\n2.设置Git的user name和email：\n``` bash\n$ git config --global user.name \"chenbaowu\"\n$ git config --global user.email \"1534598088@qq.com\"\n```\n<!-- more -->\n\n3.生成密钥\n查看是否已经有了ssh密钥：cd ~/.ssh\n如果没有密钥则不会有此文件夹，有则备份删除\n生成密钥：\n``` bash\n$ ssh-keygen -t rsa -C “1534598088@qq.com”\n```\n按3个回车，密码为空。\n最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了\n\n4.初始化git,创建本地仓库\n``` bash\n$ git init\n```\n5.将文件加入暂存区\n``` bash\n$ git add . //将目录下所有文件加入暂存区，可以是文件名\n$ git add my_file,other_file //将目录下所有文件加入暂存区\n```\n6.提交本地仓库\n``` bash\n$ git commit -am \"初次提交\"\n```\n7.推送到远程仓库\n``` bash\n$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin \n$ git push origin master  // 客户端首次提交 ，以后直接 git push\n```\n8.实用命令\n``` bash\n$ git clone git@github..com:用户名/项目名.git // 克隆github的代码\n$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址\n$ git remote rm 远程仓库名 //  删除远程仓库\n$ git remote -v // 查看当前远程仓库地址\n$ git fetch origin master  // 取回origin的master分支\n$ git merge origin master // 将origin merge 到 master 上\n$ git push  // 相当于 fetch 加上 merge\n& git status  // 查看状态\n```\n","slug":"git","published":1,"updated":"2017-12-14T07:26:23.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awd8000ikku08hintxdw","content":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>3.生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088@qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>4.初始化git,创建本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git init</div></pre></td></tr></table></figure></p>\n<p>5.将文件加入暂存区<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add . //将目录下所有文件加入暂存区，可以是文件名</div><div class=\"line\">$ git add my_file,other_file //将目录下所有文件加入暂存区</div></pre></td></tr></table></figure></p>\n<p>6.提交本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git commit -am <span class=\"string\">\"初次提交\"</span></div></pre></td></tr></table></figure></p>\n<p>7.推送到远程仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin </div><div class=\"line\">$ git push origin master  // 客户端首次提交 ，以后直接 git push</div></pre></td></tr></table></figure></p>\n<p>8.实用命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git <span class=\"built_in\">clone</span> git@github..com:用户名/项目名.git // 克隆github的代码</div><div class=\"line\">$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址</div><div class=\"line\">$ git remote rm 远程仓库名 //  删除远程仓库</div><div class=\"line\">$ git remote -v // 查看当前远程仓库地址</div><div class=\"line\">$ git fetch origin master  // 取回origin的master分支</div><div class=\"line\">$ git merge origin master // 将origin merge 到 master 上</div><div class=\"line\">$ git push  // 相当于 fetch 加上 merge</div><div class=\"line\">&amp; git status  // 查看状态</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<p>1.下载安装<a href=\"https://git-scm.com/downloads\" target=\"_blank\" rel=\"external\">Git</a>（一路next）<br>2.设置Git的user name和email：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git config --global user.name <span class=\"string\">\"chenbaowu\"</span></div><div class=\"line\">$ git config --global user.email <span class=\"string\">\"1534598088@qq.com\"</span></div></pre></td></tr></table></figure></p>","more":"<p>3.生成密钥<br>查看是否已经有了ssh密钥：cd ~/.ssh<br>如果没有密钥则不会有此文件夹，有则备份删除<br>生成密钥：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ ssh-keygen -t rsa -C “1534598088@qq.com”</div></pre></td></tr></table></figure></p>\n<p>按3个回车，密码为空。<br>最后生成生成一个目录.ssh，里面有两个文件：id_rsa , id_rsa.pub；在github的Settings的SSH and GPG keys点击new ssh key 把 id_rsa.pub的内容复制进去就可以了</p>\n<p>4.初始化git,创建本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git init</div></pre></td></tr></table></figure></p>\n<p>5.将文件加入暂存区<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git add . //将目录下所有文件加入暂存区，可以是文件名</div><div class=\"line\">$ git add my_file,other_file //将目录下所有文件加入暂存区</div></pre></td></tr></table></figure></p>\n<p>6.提交本地仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git commit -am <span class=\"string\">\"初次提交\"</span></div></pre></td></tr></table></figure></p>\n<p>7.推送到远程仓库<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git remote add origin git@github.com:用户名/项目名.git  // 添加远程仓库 origin </div><div class=\"line\">$ git push origin master  // 客户端首次提交 ，以后直接 git push</div></pre></td></tr></table></figure></p>\n<p>8.实用命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ git <span class=\"built_in\">clone</span> git@github..com:用户名/项目名.git // 克隆github的代码</div><div class=\"line\">$ git remote add origin git@github.com:chenbaowu/fdBook.git // 添加远程仓库地址</div><div class=\"line\">$ git remote rm 远程仓库名 //  删除远程仓库</div><div class=\"line\">$ git remote -v // 查看当前远程仓库地址</div><div class=\"line\">$ git fetch origin master  // 取回origin的master分支</div><div class=\"line\">$ git merge origin master // 将origin merge 到 master 上</div><div class=\"line\">$ git push  // 相当于 fetch 加上 merge</div><div class=\"line\">&amp; git status  // 查看状态</div></pre></td></tr></table></figure></p>"},{"title":"android网络编程(httpurlconnect接口,httpclient接口,与socket接口)","date":"2017-05-10T09:20:11.000Z","_content":"\n## 前言\nAndroid中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。\nHttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。\n另外，在使用POST方式进行传输时，需要进行字符编码。\nManifest文件中权限的设定：Xml代码 \n< uses-permission android:name=\"android.permission.INTERNET\" /> \n\n<!-- more -->\n\n## 1.HttpURLConnection接口\n首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。\nHttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：\n``` bash\nURL url = new URL(\"http://www.51cto.com/index.jsp?par=123456\");    \nHttpURLConnection urlConn=(HttpURLConnection)url.openConnection();\n\n//设置输入和输出流    \nurlConn.setDoOutput(true);    \nurlConn.setDoInput(true);    \n//设置请求方式为POST    \nurlConn.setRequestMethod(\"POST\");    \n//POST请求不能使用缓存    \nurlConn.setUseCaches(false);   \n//关闭连接    \nurlConn.disConnection();  \n```\n具体调用\n``` bash\n//以Get方式上传参数  \npublic class Activity03 extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity03\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);    \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //得到读取的内容(流)  \n                InputStreamReader in = new InputStreamReader(urlConn.getInputStream());  \n                // 为输出创建BufferedReader  \n                BufferedReader buffer = new BufferedReader(in);  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = buffer.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                //关闭InputStreamReader  \n                in.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n}\n\n//以post方式上传参数  \npublic class Activity04  extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity04\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n          \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //因为这个是post请求,设立需要设置为true  \n                urlConn.setDoOutput(true);  \n                urlConn.setDoInput(true);  \n                // 设置以POST方式  \n                urlConn.setRequestMethod(\"POST\");  \n                // Post 请求不能使用缓存  \n                urlConn.setUseCaches(false);  \n                urlConn.setInstanceFollowRedirects(true);  \n                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  \n                urlConn.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded\");  \n                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  \n                // 要注意的是connection.getOutputStream会隐含的进行connect。  \n                urlConn.connect();  \n                //DataOutputStream流  \n                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  \n                //要上传的参数  \n                String content = \"par=\" + URLEncoder.encode(\"ABCDEFG\", \"gb2312\");  \n                //将要上传的内容写入流中  \n                out.writeBytes(content);   \n                //刷新、关闭  \n                out.flush();  \n                out.close();   \n                //获取数据  \n                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = reader.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                reader.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n    }  \n}  \n```\n##  2.HttpClient接口\n使用Apache提供的HttpClient接口同样可以进行HTTP操作。\n对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：\n``` bash\npublic class Activity02 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\";  \n        //HttpGet连接对象  \n        HttpGet httpRequest = new HttpGet(httpUrl);  \n        try  \n        {  \n            //取得HttpClient对象  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //请求HttpClient，取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //请求成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n      \n            }  \n}  \n```\n使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：\n``` bash\npublic class Activity03 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //HttpPost连接对象  \n        HttpPost httpRequest = new HttpPost(httpUrl);  \n        //使用NameValuePair来保存要传递的Post参数  \n        List<NameValuePair> params = new ArrayList<NameValuePair>();  \n        //添加要传递的参数  \n        params.add(new BasicNameValuePair(\"par\", \"HttpClient_android_Post\"));  \n        try  \n        {  \n            //设置字符集  \n            HttpEntity httpentity = new UrlEncodedFormEntity(params, \"gb2312\");  \n            //请求httpRequest  \n            httpRequest.setEntity(httpentity);  \n            //取得默认的HttpClient  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //HttpStatus.SC_OK表示连接成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n    }  \n}  \n````\n## 3 Socket编程实例：\n创建一个java 类作为服务器，android 应用程序作为客户端\n服务器端代码：\n``` bash\npackage com.server;  \n  \nimport java.io.IOException;  \nimport java.io.OutputStream;  \nimport java.net.ServerSocket;  \nimport java.net.Socket;  \nimport java.text.SimpleDateFormat;  \n  \npublic class MyServer {  \n      \n    private  static int count=0;  \n    public static void main(String[]args){  \n          \n        try {  \n            //实例化服务器套接字 设置端口号8888  \n            ServerSocket server=new ServerSocket(8888);  \n            while(true){  \n                //连接编号设置  \n                count=count+1;  \n                //时间格式  \n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");  \n                //实例化客户端  \n                Socket client=server.accept();  \n                //实例化时间  以及 id  \n                System.out.println(count+\":\"+sdf.format(System.currentTimeMillis()));  \n                //获取输出流  \n                OutputStream out=client.getOutputStream();  \n                //输出字符串  \n                String msg=\"Hello,Android!\";  \n                //写字符串  \n                out.write(msg.getBytes());  \n            }  \n        } catch (IOException e) {  \n            // TODO Auto-generated catch block  \n            e.printStackTrace();  \n        }  \n          \n          \n    }  \n}  \n```\nandroid 客户端代码：\n``` bash\npackage com.client;  \n  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.net.Socket;  \nimport java.net.UnknownHostException;  \n  \nimport android.app.Activity;  \nimport android.os.Bundle;  \nimport android.view.View;  \nimport android.view.View.OnClickListener;  \nimport android.widget.Button;  \nimport android.widget.TextView;  \n  \npublic class MyClientActivity extends Activity {  \n    /** Called when the activity is first created. */  \n    private Button rev=null;  \n    private TextView revtext=null;  \n    @Override  \n    public void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.main);  \n        rev=(Button)findViewById(R.id.rev);      \n        revtext=(TextView)findViewById(R.id.receiver);  \n        rev.setOnClickListener(new receiverlistenr());  \n    }  \n    class receiverlistenr implements OnClickListener{  \n        public void onClick(View v) {  \n            // TODO Auto-generated method stub  \n            try {  \n                //实例化Socket  \n                Socket socket=new Socket(\"169.254.202.149\",8888);  \n                //获得输入流  \n                InputStream in=socket.getInputStream();  \n                //缓冲区  \n                byte[] buffer=new byte[in.available()];  \n                //读取缓冲区  \n                in.read(buffer);  \n                //转换字符串  \n                String msg=new String(buffer);  \n                //设置文本框的字符串  \n                revtext.setText(msg);  \n            } catch (UnknownHostException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            } catch (IOException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            }  \n              \n        }  \n    }  \n}  \n```","source":"_posts/http.md","raw":"---\ntitle: android网络编程(httpurlconnect接口,httpclient接口,与socket接口)\ndate: 2017-05-10 17:20:11\ncategories: android\ntags: 网络编程\n---\n\n## 前言\nAndroid中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。\nHttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。\n另外，在使用POST方式进行传输时，需要进行字符编码。\nManifest文件中权限的设定：Xml代码 \n< uses-permission android:name=\"android.permission.INTERNET\" /> \n\n<!-- more -->\n\n## 1.HttpURLConnection接口\n首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。\nHttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：\n``` bash\nURL url = new URL(\"http://www.51cto.com/index.jsp?par=123456\");    \nHttpURLConnection urlConn=(HttpURLConnection)url.openConnection();\n\n//设置输入和输出流    \nurlConn.setDoOutput(true);    \nurlConn.setDoInput(true);    \n//设置请求方式为POST    \nurlConn.setRequestMethod(\"POST\");    \n//POST请求不能使用缓存    \nurlConn.setUseCaches(false);   \n//关闭连接    \nurlConn.disConnection();  \n```\n具体调用\n``` bash\n//以Get方式上传参数  \npublic class Activity03 extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity03\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);    \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //得到读取的内容(流)  \n                InputStreamReader in = new InputStreamReader(urlConn.getInputStream());  \n                // 为输出创建BufferedReader  \n                BufferedReader buffer = new BufferedReader(in);  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = buffer.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                //关闭InputStreamReader  \n                in.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n}\n\n//以post方式上传参数  \npublic class Activity04  extends Activity  \n{  \n    private final String DEBUG_TAG = \"Activity04\";   \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n          \n        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  \n        //http地址\"?par=abcdefg\"是我们上传的参数  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //获得的数据  \n        String resultData = \"\";  \n        URL url = null;  \n        try  \n        {  \n            //构造一个URL对象  \n            url = new URL(httpUrl);   \n        }  \n        catch (MalformedURLException e)  \n        {  \n            Log.e(DEBUG_TAG, \"MalformedURLException\");  \n        }  \n        if (url != null)  \n        {  \n            try  \n            {  \n                // 使用HttpURLConnection打开连接  \n                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  \n                //因为这个是post请求,设立需要设置为true  \n                urlConn.setDoOutput(true);  \n                urlConn.setDoInput(true);  \n                // 设置以POST方式  \n                urlConn.setRequestMethod(\"POST\");  \n                // Post 请求不能使用缓存  \n                urlConn.setUseCaches(false);  \n                urlConn.setInstanceFollowRedirects(true);  \n                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  \n                urlConn.setRequestProperty(\"Content-Type\",\"application/x-www-form-urlencoded\");  \n                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  \n                // 要注意的是connection.getOutputStream会隐含的进行connect。  \n                urlConn.connect();  \n                //DataOutputStream流  \n                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  \n                //要上传的参数  \n                String content = \"par=\" + URLEncoder.encode(\"ABCDEFG\", \"gb2312\");  \n                //将要上传的内容写入流中  \n                out.writeBytes(content);   \n                //刷新、关闭  \n                out.flush();  \n                out.close();   \n                //获取数据  \n                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  \n                String inputLine = null;  \n                //使用循环来读取获得的数据  \n                while (((inputLine = reader.readLine()) != null))  \n                {  \n                    //我们在每一行后面加上一个\"\\n\"来换行  \n                    resultData += inputLine + \"\\n\";  \n                }           \n                reader.close();  \n                //关闭http连接  \n                urlConn.disconnect();  \n                //设置显示取得的内容  \n                if ( resultData != null )  \n                {  \n                    mTextView.setText(resultData);  \n                }  \n                else   \n                {  \n                    mTextView.setText(\"读取的内容为NULL\");  \n                }  \n            }  \n            catch (IOException e)  \n            {  \n                Log.e(DEBUG_TAG, \"IOException\");  \n            }  \n        }  \n        else  \n        {  \n            Log.e(DEBUG_TAG, \"Url NULL\");  \n        }  \n    }  \n}  \n```\n##  2.HttpClient接口\n使用Apache提供的HttpClient接口同样可以进行HTTP操作。\n对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：\n``` bash\npublic class Activity02 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\";  \n        //HttpGet连接对象  \n        HttpGet httpRequest = new HttpGet(httpUrl);  \n        try  \n        {  \n            //取得HttpClient对象  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //请求HttpClient，取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //请求成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n      \n            }  \n}  \n```\n使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：\n``` bash\npublic class Activity03 extends Activity  \n{  \n    /** Called when the activity is first created. */  \n    @Override  \n    public void onCreate(Bundle savedInstanceState)  \n    {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.http);  \n        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  \n        // http地址  \n        String httpUrl = \"http://192.168.1.110:8080/httpget.jsp\";  \n        //HttpPost连接对象  \n        HttpPost httpRequest = new HttpPost(httpUrl);  \n        //使用NameValuePair来保存要传递的Post参数  \n        List<NameValuePair> params = new ArrayList<NameValuePair>();  \n        //添加要传递的参数  \n        params.add(new BasicNameValuePair(\"par\", \"HttpClient_android_Post\"));  \n        try  \n        {  \n            //设置字符集  \n            HttpEntity httpentity = new UrlEncodedFormEntity(params, \"gb2312\");  \n            //请求httpRequest  \n            httpRequest.setEntity(httpentity);  \n            //取得默认的HttpClient  \n            HttpClient httpclient = new DefaultHttpClient();  \n            //取得HttpResponse  \n            HttpResponse httpResponse = httpclient.execute(httpRequest);  \n            //HttpStatus.SC_OK表示连接成功  \n            if (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  \n            {  \n                //取得返回的字符串  \n                String strResult = EntityUtils.toString(httpResponse.getEntity());  \n                mTextView.setText(strResult);  \n            }  \n            else  \n            {  \n                mTextView.setText(\"请求错误!\");  \n            }  \n        }  \n        catch (ClientProtocolException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (IOException e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }  \n        catch (Exception e)  \n        {  \n            mTextView.setText(e.getMessage().toString());  \n        }    \n    }  \n}  \n````\n## 3 Socket编程实例：\n创建一个java 类作为服务器，android 应用程序作为客户端\n服务器端代码：\n``` bash\npackage com.server;  \n  \nimport java.io.IOException;  \nimport java.io.OutputStream;  \nimport java.net.ServerSocket;  \nimport java.net.Socket;  \nimport java.text.SimpleDateFormat;  \n  \npublic class MyServer {  \n      \n    private  static int count=0;  \n    public static void main(String[]args){  \n          \n        try {  \n            //实例化服务器套接字 设置端口号8888  \n            ServerSocket server=new ServerSocket(8888);  \n            while(true){  \n                //连接编号设置  \n                count=count+1;  \n                //时间格式  \n                SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\");  \n                //实例化客户端  \n                Socket client=server.accept();  \n                //实例化时间  以及 id  \n                System.out.println(count+\":\"+sdf.format(System.currentTimeMillis()));  \n                //获取输出流  \n                OutputStream out=client.getOutputStream();  \n                //输出字符串  \n                String msg=\"Hello,Android!\";  \n                //写字符串  \n                out.write(msg.getBytes());  \n            }  \n        } catch (IOException e) {  \n            // TODO Auto-generated catch block  \n            e.printStackTrace();  \n        }  \n          \n          \n    }  \n}  \n```\nandroid 客户端代码：\n``` bash\npackage com.client;  \n  \nimport java.io.IOException;  \nimport java.io.InputStream;  \nimport java.net.Socket;  \nimport java.net.UnknownHostException;  \n  \nimport android.app.Activity;  \nimport android.os.Bundle;  \nimport android.view.View;  \nimport android.view.View.OnClickListener;  \nimport android.widget.Button;  \nimport android.widget.TextView;  \n  \npublic class MyClientActivity extends Activity {  \n    /** Called when the activity is first created. */  \n    private Button rev=null;  \n    private TextView revtext=null;  \n    @Override  \n    public void onCreate(Bundle savedInstanceState) {  \n        super.onCreate(savedInstanceState);  \n        setContentView(R.layout.main);  \n        rev=(Button)findViewById(R.id.rev);      \n        revtext=(TextView)findViewById(R.id.receiver);  \n        rev.setOnClickListener(new receiverlistenr());  \n    }  \n    class receiverlistenr implements OnClickListener{  \n        public void onClick(View v) {  \n            // TODO Auto-generated method stub  \n            try {  \n                //实例化Socket  \n                Socket socket=new Socket(\"169.254.202.149\",8888);  \n                //获得输入流  \n                InputStream in=socket.getInputStream();  \n                //缓冲区  \n                byte[] buffer=new byte[in.available()];  \n                //读取缓冲区  \n                in.read(buffer);  \n                //转换字符串  \n                String msg=new String(buffer);  \n                //设置文本框的字符串  \n                revtext.setText(msg);  \n            } catch (UnknownHostException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            } catch (IOException e) {  \n                // TODO Auto-generated catch block  \n                e.printStackTrace();  \n            }  \n              \n        }  \n    }  \n}  \n```","slug":"http","published":1,"updated":"2017-12-14T07:26:23.340Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdb000nkku0feafa4bt","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Android中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。<br>HttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。<br>另外，在使用POST方式进行传输时，需要进行字符编码。<br>Manifest文件中权限的设定：Xml代码<br>&lt; uses-permission android:name=”android.permission.INTERNET” /&gt; </p>\n<a id=\"more\"></a>\n<h2 id=\"1-HttpURLConnection接口\"><a href=\"#1-HttpURLConnection接口\" class=\"headerlink\" title=\"1.HttpURLConnection接口\"></a>1.HttpURLConnection接口</h2><p>首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。<br>HttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = new URL(<span class=\"string\">\"http://www.51cto.com/index.jsp?par=123456\"</span>);    </div><div class=\"line\">HttpURLConnection urlConn=(HttpURLConnection)url.openConnection();</div><div class=\"line\"></div><div class=\"line\">//设置输入和输出流    </div><div class=\"line\">urlConn.setDoOutput(<span class=\"literal\">true</span>);    </div><div class=\"line\">urlConn.setDoInput(<span class=\"literal\">true</span>);    </div><div class=\"line\">//设置请求方式为POST    </div><div class=\"line\">urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);    </div><div class=\"line\">//POST请求不能使用缓存    </div><div class=\"line\">urlConn.setUseCaches(<span class=\"literal\">false</span>);   </div><div class=\"line\">//关闭连接    </div><div class=\"line\">urlConn.disConnection();</div></pre></td></tr></table></figure></p>\n<p>具体调用<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以Get方式上传参数  </div><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity03\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);    </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //得到读取的内容(流)  </div><div class=\"line\">                InputStreamReader <span class=\"keyword\">in</span> = new InputStreamReader(urlConn.getInputStream());  </div><div class=\"line\">                // 为输出创建BufferedReader  </div><div class=\"line\">                BufferedReader buffer = new BufferedReader(<span class=\"keyword\">in</span>);  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = buffer.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                //关闭InputStreamReader  </div><div class=\"line\">                in.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//以post方式上传参数  </div><div class=\"line\">public class Activity04  extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity04\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">          </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //因为这个是post请求,设立需要设置为<span class=\"literal\">true</span>  </div><div class=\"line\">                urlConn.setDoOutput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                urlConn.setDoInput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 设置以POST方式  </div><div class=\"line\">                urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);  </div><div class=\"line\">                // Post 请求不能使用缓存  </div><div class=\"line\">                urlConn.setUseCaches(<span class=\"literal\">false</span>);  </div><div class=\"line\">                urlConn.setInstanceFollowRedirects(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  </div><div class=\"line\">                urlConn.setRequestProperty(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);  </div><div class=\"line\">                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  </div><div class=\"line\">                // 要注意的是connection.getOutputStream会隐含的进行connect。  </div><div class=\"line\">                urlConn.connect();  </div><div class=\"line\">                //DataOutputStream流  </div><div class=\"line\">                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  </div><div class=\"line\">                //要上传的参数  </div><div class=\"line\">                String content = <span class=\"string\">\"par=\"</span> + URLEncoder.encode(<span class=\"string\">\"ABCDEFG\"</span>, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">                //将要上传的内容写入流中  </div><div class=\"line\">                out.writeBytes(content);   </div><div class=\"line\">                //刷新、关闭  </div><div class=\"line\">                out.flush();  </div><div class=\"line\">                out.close();   </div><div class=\"line\">                //获取数据  </div><div class=\"line\">                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = reader.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                reader.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-HttpClient接口\"><a href=\"#2-HttpClient接口\" class=\"headerlink\" title=\"2.HttpClient接口\"></a>2.HttpClient接口</h2><p>使用Apache提供的HttpClient接口同样可以进行HTTP操作。<br>对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity02 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\"</span>;  </div><div class=\"line\">        //HttpGet连接对象  </div><div class=\"line\">        HttpGet httpRequest = new HttpGet(httpUrl);  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //取得HttpClient对象  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //请求HttpClient，取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //请求成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">      </div><div class=\"line\">            &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //HttpPost连接对象  </div><div class=\"line\">        HttpPost httpRequest = new HttpPost(httpUrl);  </div><div class=\"line\">        //使用NameValuePair来保存要传递的Post参数  </div><div class=\"line\">        List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();  </div><div class=\"line\">        //添加要传递的参数  </div><div class=\"line\">        params.add(new BasicNameValuePair(<span class=\"string\">\"par\"</span>, <span class=\"string\">\"HttpClient_android_Post\"</span>));  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //设置字符集  </div><div class=\"line\">            HttpEntity httpentity = new UrlEncodedFormEntity(params, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">            //请求httpRequest  </div><div class=\"line\">            httpRequest.setEntity(httpentity);  </div><div class=\"line\">            //取得默认的HttpClient  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //HttpStatus.SC_OK表示连接成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-Socket编程实例：\"><a href=\"#3-Socket编程实例：\" class=\"headerlink\" title=\"3 Socket编程实例：\"></a>3 Socket编程实例：</h2><p>创建一个java 类作为服务器，android 应用程序作为客户端<br>服务器端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.server;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.OutputStream;  </div><div class=\"line\">import java.net.ServerSocket;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.text.SimpleDateFormat;  </div><div class=\"line\">  </div><div class=\"line\">public class MyServer &#123;  </div><div class=\"line\">      </div><div class=\"line\">    private  static int count=0;  </div><div class=\"line\">    public static void main(String[]args)&#123;  </div><div class=\"line\">          </div><div class=\"line\">        try &#123;  </div><div class=\"line\">            //实例化服务器套接字 设置端口号8888  </div><div class=\"line\">            ServerSocket server=new ServerSocket(8888);  </div><div class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;  </div><div class=\"line\">                //连接编号设置  </div><div class=\"line\">                count=count+1;  </div><div class=\"line\">                //时间格式  </div><div class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss.SSS\"</span>);  </div><div class=\"line\">                //实例化客户端  </div><div class=\"line\">                Socket client=server.accept();  </div><div class=\"line\">                //实例化时间  以及 id  </div><div class=\"line\">                System.out.println(count+<span class=\"string\">\":\"</span>+sdf.format(System.currentTimeMillis()));  </div><div class=\"line\">                //获取输出流  </div><div class=\"line\">                OutputStream out=client.getOutputStream();  </div><div class=\"line\">                //输出字符串  </div><div class=\"line\">                String msg=<span class=\"string\">\"Hello,Android!\"</span>;  </div><div class=\"line\">                //写字符串  </div><div class=\"line\">                out.write(msg.getBytes());  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125; catch (IOException e) &#123;  </div><div class=\"line\">            // TODO Auto-generated catch block  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">          </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>android 客户端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.client;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.InputStream;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.net.UnknownHostException;  </div><div class=\"line\">  </div><div class=\"line\">import android.app.Activity;  </div><div class=\"line\">import android.os.Bundle;  </div><div class=\"line\">import android.view.View;  </div><div class=\"line\">import android.view.View.OnClickListener;  </div><div class=\"line\">import android.widget.Button;  </div><div class=\"line\">import android.widget.TextView;  </div><div class=\"line\">  </div><div class=\"line\">public class MyClientActivity extends Activity &#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    private Button rev=null;  </div><div class=\"line\">    private TextView revtext=null;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.main);  </div><div class=\"line\">        rev=(Button)findViewById(R.id.rev);      </div><div class=\"line\">        revtext=(TextView)findViewById(R.id.receiver);  </div><div class=\"line\">        rev.setOnClickListener(new receiverlistenr());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    class receiverlistenr implements OnClickListener&#123;  </div><div class=\"line\">        public void onClick(View v) &#123;  </div><div class=\"line\">            // TODO Auto-generated method stub  </div><div class=\"line\">            try &#123;  </div><div class=\"line\">                //实例化Socket  </div><div class=\"line\">                Socket socket=new Socket(<span class=\"string\">\"169.254.202.149\"</span>,8888);  </div><div class=\"line\">                //获得输入流  </div><div class=\"line\">                InputStream <span class=\"keyword\">in</span>=socket.getInputStream();  </div><div class=\"line\">                //缓冲区  </div><div class=\"line\">                byte[] buffer=new byte[in.available()];  </div><div class=\"line\">                //读取缓冲区  </div><div class=\"line\">                in.read(buffer);  </div><div class=\"line\">                //转换字符串  </div><div class=\"line\">                String msg=new String(buffer);  </div><div class=\"line\">                //设置文本框的字符串  </div><div class=\"line\">                revtext.setText(msg);  </div><div class=\"line\">            &#125; catch (UnknownHostException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125; catch (IOException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">              </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>Android中提供的HttpURLConnection和HttpClient接口可以用来开发HTTP程序。<br>HttpClient实际上是对Java提供方法的一些封装，在HttpURLConnection中的输入输出流操作，在这个接口中被统一封装成了HttpPost(HttpGet)和HttpResponse，这样，就减少了操作的繁琐性。<br>另外，在使用POST方式进行传输时，需要进行字符编码。<br>Manifest文件中权限的设定：Xml代码<br>&lt; uses-permission android:name=”android.permission.INTERNET” /&gt; </p>","more":"<h2 id=\"1-HttpURLConnection接口\"><a href=\"#1-HttpURLConnection接口\" class=\"headerlink\" title=\"1.HttpURLConnection接口\"></a>1.HttpURLConnection接口</h2><p>首先需要明确的是，Http通信中的POST和GET请求方式的不同。GET可以获得静态页面，也可以把参数放在URL字符串后面，传递给服务器。而POST方法的参数是放在Http请求中。因此，在编程之前，应当首先明确使用的请求方法，然后再根据所使用的方式选择相应的编程方式。<br>HttpURLConnection是继承于URLConnection类，二者都是抽象类。其对象主要通过URL的openConnection方法获得。创建方法如下代码所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">URL url = new URL(<span class=\"string\">\"http://www.51cto.com/index.jsp?par=123456\"</span>);    </div><div class=\"line\">HttpURLConnection urlConn=(HttpURLConnection)url.openConnection();</div><div class=\"line\"></div><div class=\"line\">//设置输入和输出流    </div><div class=\"line\">urlConn.setDoOutput(<span class=\"literal\">true</span>);    </div><div class=\"line\">urlConn.setDoInput(<span class=\"literal\">true</span>);    </div><div class=\"line\">//设置请求方式为POST    </div><div class=\"line\">urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);    </div><div class=\"line\">//POST请求不能使用缓存    </div><div class=\"line\">urlConn.setUseCaches(<span class=\"literal\">false</span>);   </div><div class=\"line\">//关闭连接    </div><div class=\"line\">urlConn.disConnection();</div></pre></td></tr></table></figure></p>\n<p>具体调用<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div></pre></td><td class=\"code\"><pre><div class=\"line\">//以Get方式上传参数  </div><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity03\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);    </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=abcdefg\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //得到读取的内容(流)  </div><div class=\"line\">                InputStreamReader <span class=\"keyword\">in</span> = new InputStreamReader(urlConn.getInputStream());  </div><div class=\"line\">                // 为输出创建BufferedReader  </div><div class=\"line\">                BufferedReader buffer = new BufferedReader(<span class=\"keyword\">in</span>);  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = buffer.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                //关闭InputStreamReader  </div><div class=\"line\">                in.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">//以post方式上传参数  </div><div class=\"line\">public class Activity04  extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    private final String DEBUG_TAG = <span class=\"string\">\"Activity04\"</span>;   </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">          </div><div class=\"line\">        TextView mTextView = (TextView)this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        //http地址<span class=\"string\">\"?par=abcdefg\"</span>是我们上传的参数  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //获得的数据  </div><div class=\"line\">        String resultData = <span class=\"string\">\"\"</span>;  </div><div class=\"line\">        URL url = null;  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //构造一个URL对象  </div><div class=\"line\">            url = new URL(httpUrl);   </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (MalformedURLException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"MalformedURLException\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">if</span> (url != null)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            try  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                // 使用HttpURLConnection打开连接  </div><div class=\"line\">                HttpURLConnection urlConn = (HttpURLConnection) url.openConnection();  </div><div class=\"line\">                //因为这个是post请求,设立需要设置为<span class=\"literal\">true</span>  </div><div class=\"line\">                urlConn.setDoOutput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                urlConn.setDoInput(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 设置以POST方式  </div><div class=\"line\">                urlConn.setRequestMethod(<span class=\"string\">\"POST\"</span>);  </div><div class=\"line\">                // Post 请求不能使用缓存  </div><div class=\"line\">                urlConn.setUseCaches(<span class=\"literal\">false</span>);  </div><div class=\"line\">                urlConn.setInstanceFollowRedirects(<span class=\"literal\">true</span>);  </div><div class=\"line\">                // 配置本次连接的Content-type，配置为application/x-www-form-urlencoded的  </div><div class=\"line\">                urlConn.setRequestProperty(<span class=\"string\">\"Content-Type\"</span>,<span class=\"string\">\"application/x-www-form-urlencoded\"</span>);  </div><div class=\"line\">                // 连接，从postUrl.openConnection()至此的配置必须要在connect之前完成，  </div><div class=\"line\">                // 要注意的是connection.getOutputStream会隐含的进行connect。  </div><div class=\"line\">                urlConn.connect();  </div><div class=\"line\">                //DataOutputStream流  </div><div class=\"line\">                DataOutputStream out = new DataOutputStream(urlConn.getOutputStream());  </div><div class=\"line\">                //要上传的参数  </div><div class=\"line\">                String content = <span class=\"string\">\"par=\"</span> + URLEncoder.encode(<span class=\"string\">\"ABCDEFG\"</span>, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">                //将要上传的内容写入流中  </div><div class=\"line\">                out.writeBytes(content);   </div><div class=\"line\">                //刷新、关闭  </div><div class=\"line\">                out.flush();  </div><div class=\"line\">                out.close();   </div><div class=\"line\">                //获取数据  </div><div class=\"line\">                BufferedReader reader = new BufferedReader(new InputStreamReader(urlConn.getInputStream()));  </div><div class=\"line\">                String inputLine = null;  </div><div class=\"line\">                //使用循环来读取获得的数据  </div><div class=\"line\">                <span class=\"keyword\">while</span> (((inputLine = reader.readLine()) != null))  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    //我们在每一行后面加上一个<span class=\"string\">\"\\n\"</span>来换行  </div><div class=\"line\">                    resultData += inputLine + <span class=\"string\">\"\\n\"</span>;  </div><div class=\"line\">                &#125;           </div><div class=\"line\">                reader.close();  </div><div class=\"line\">                //关闭http连接  </div><div class=\"line\">                urlConn.disconnect();  </div><div class=\"line\">                //设置显示取得的内容  </div><div class=\"line\">                <span class=\"keyword\">if</span> ( resultData != null )  </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(resultData);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">                <span class=\"keyword\">else</span>   </div><div class=\"line\">                &#123;  </div><div class=\"line\">                    mTextView.setText(<span class=\"string\">\"读取的内容为NULL\"</span>);  </div><div class=\"line\">                &#125;  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            catch (IOException e)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                Log.e(DEBUG_TAG, <span class=\"string\">\"IOException\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        <span class=\"keyword\">else</span>  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            Log.e(DEBUG_TAG, <span class=\"string\">\"Url NULL\"</span>);  </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"2-HttpClient接口\"><a href=\"#2-HttpClient接口\" class=\"headerlink\" title=\"2.HttpClient接口\"></a>2.HttpClient接口</h2><p>使用Apache提供的HttpClient接口同样可以进行HTTP操作。<br>对于GET和POST请求方法的操作有所不同。GET方法的操作代码示例如下：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity02 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp?par=HttpClient_android_Get\"</span>;  </div><div class=\"line\">        //HttpGet连接对象  </div><div class=\"line\">        HttpGet httpRequest = new HttpGet(httpUrl);  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //取得HttpClient对象  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //请求HttpClient，取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //请求成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">      </div><div class=\"line\">            &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>使用POST方法进行参数传递时，需要使用NameValuePair来保存要传递的参数，另外，还需要设置所使用的字符集。代码如下所示：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class Activity03 extends Activity  </div><div class=\"line\">&#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState)  </div><div class=\"line\">    &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.http);  </div><div class=\"line\">        TextView mTextView = (TextView) this.findViewById(R.id.TextView_HTTP);  </div><div class=\"line\">        // http地址  </div><div class=\"line\">        String httpUrl = <span class=\"string\">\"http://192.168.1.110:8080/httpget.jsp\"</span>;  </div><div class=\"line\">        //HttpPost连接对象  </div><div class=\"line\">        HttpPost httpRequest = new HttpPost(httpUrl);  </div><div class=\"line\">        //使用NameValuePair来保存要传递的Post参数  </div><div class=\"line\">        List&lt;NameValuePair&gt; params = new ArrayList&lt;NameValuePair&gt;();  </div><div class=\"line\">        //添加要传递的参数  </div><div class=\"line\">        params.add(new BasicNameValuePair(<span class=\"string\">\"par\"</span>, <span class=\"string\">\"HttpClient_android_Post\"</span>));  </div><div class=\"line\">        try  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            //设置字符集  </div><div class=\"line\">            HttpEntity httpentity = new UrlEncodedFormEntity(params, <span class=\"string\">\"gb2312\"</span>);  </div><div class=\"line\">            //请求httpRequest  </div><div class=\"line\">            httpRequest.setEntity(httpentity);  </div><div class=\"line\">            //取得默认的HttpClient  </div><div class=\"line\">            HttpClient httpclient = new DefaultHttpClient();  </div><div class=\"line\">            //取得HttpResponse  </div><div class=\"line\">            HttpResponse httpResponse = httpclient.execute(httpRequest);  </div><div class=\"line\">            //HttpStatus.SC_OK表示连接成功  </div><div class=\"line\">            <span class=\"keyword\">if</span> (httpResponse.getStatusLine().getStatusCode() == HttpStatus.SC_OK)  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                //取得返回的字符串  </div><div class=\"line\">                String strResult = EntityUtils.toString(httpResponse.getEntity());  </div><div class=\"line\">                mTextView.setText(strResult);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">            <span class=\"keyword\">else</span>  </div><div class=\"line\">            &#123;  </div><div class=\"line\">                mTextView.setText(<span class=\"string\">\"请求错误!\"</span>);  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (ClientProtocolException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (IOException e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;  </div><div class=\"line\">        catch (Exception e)  </div><div class=\"line\">        &#123;  </div><div class=\"line\">            mTextView.setText(e.getMessage().toString());  </div><div class=\"line\">        &#125;    </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;  </div><div class=\"line\">`</div></pre></td></tr></table></figure></p>\n<h2 id=\"3-Socket编程实例：\"><a href=\"#3-Socket编程实例：\" class=\"headerlink\" title=\"3 Socket编程实例：\"></a>3 Socket编程实例：</h2><p>创建一个java 类作为服务器，android 应用程序作为客户端<br>服务器端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.server;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.OutputStream;  </div><div class=\"line\">import java.net.ServerSocket;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.text.SimpleDateFormat;  </div><div class=\"line\">  </div><div class=\"line\">public class MyServer &#123;  </div><div class=\"line\">      </div><div class=\"line\">    private  static int count=0;  </div><div class=\"line\">    public static void main(String[]args)&#123;  </div><div class=\"line\">          </div><div class=\"line\">        try &#123;  </div><div class=\"line\">            //实例化服务器套接字 设置端口号8888  </div><div class=\"line\">            ServerSocket server=new ServerSocket(8888);  </div><div class=\"line\">            <span class=\"keyword\">while</span>(<span class=\"literal\">true</span>)&#123;  </div><div class=\"line\">                //连接编号设置  </div><div class=\"line\">                count=count+1;  </div><div class=\"line\">                //时间格式  </div><div class=\"line\">                SimpleDateFormat sdf = new SimpleDateFormat(<span class=\"string\">\"yyyy-MM-dd HH:mm:ss.SSS\"</span>);  </div><div class=\"line\">                //实例化客户端  </div><div class=\"line\">                Socket client=server.accept();  </div><div class=\"line\">                //实例化时间  以及 id  </div><div class=\"line\">                System.out.println(count+<span class=\"string\">\":\"</span>+sdf.format(System.currentTimeMillis()));  </div><div class=\"line\">                //获取输出流  </div><div class=\"line\">                OutputStream out=client.getOutputStream();  </div><div class=\"line\">                //输出字符串  </div><div class=\"line\">                String msg=<span class=\"string\">\"Hello,Android!\"</span>;  </div><div class=\"line\">                //写字符串  </div><div class=\"line\">                out.write(msg.getBytes());  </div><div class=\"line\">            &#125;  </div><div class=\"line\">        &#125; catch (IOException e) &#123;  </div><div class=\"line\">            // TODO Auto-generated catch block  </div><div class=\"line\">            e.printStackTrace();  </div><div class=\"line\">        &#125;  </div><div class=\"line\">          </div><div class=\"line\">          </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>android 客户端代码：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div></pre></td><td class=\"code\"><pre><div class=\"line\">package com.client;  </div><div class=\"line\">  </div><div class=\"line\">import java.io.IOException;  </div><div class=\"line\">import java.io.InputStream;  </div><div class=\"line\">import java.net.Socket;  </div><div class=\"line\">import java.net.UnknownHostException;  </div><div class=\"line\">  </div><div class=\"line\">import android.app.Activity;  </div><div class=\"line\">import android.os.Bundle;  </div><div class=\"line\">import android.view.View;  </div><div class=\"line\">import android.view.View.OnClickListener;  </div><div class=\"line\">import android.widget.Button;  </div><div class=\"line\">import android.widget.TextView;  </div><div class=\"line\">  </div><div class=\"line\">public class MyClientActivity extends Activity &#123;  </div><div class=\"line\">    /** Called when the activity is first created. */  </div><div class=\"line\">    private Button rev=null;  </div><div class=\"line\">    private TextView revtext=null;  </div><div class=\"line\">    @Override  </div><div class=\"line\">    public void onCreate(Bundle savedInstanceState) &#123;  </div><div class=\"line\">        super.onCreate(savedInstanceState);  </div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.main);  </div><div class=\"line\">        rev=(Button)findViewById(R.id.rev);      </div><div class=\"line\">        revtext=(TextView)findViewById(R.id.receiver);  </div><div class=\"line\">        rev.setOnClickListener(new receiverlistenr());  </div><div class=\"line\">    &#125;  </div><div class=\"line\">    class receiverlistenr implements OnClickListener&#123;  </div><div class=\"line\">        public void onClick(View v) &#123;  </div><div class=\"line\">            // TODO Auto-generated method stub  </div><div class=\"line\">            try &#123;  </div><div class=\"line\">                //实例化Socket  </div><div class=\"line\">                Socket socket=new Socket(<span class=\"string\">\"169.254.202.149\"</span>,8888);  </div><div class=\"line\">                //获得输入流  </div><div class=\"line\">                InputStream <span class=\"keyword\">in</span>=socket.getInputStream();  </div><div class=\"line\">                //缓冲区  </div><div class=\"line\">                byte[] buffer=new byte[in.available()];  </div><div class=\"line\">                //读取缓冲区  </div><div class=\"line\">                in.read(buffer);  </div><div class=\"line\">                //转换字符串  </div><div class=\"line\">                String msg=new String(buffer);  </div><div class=\"line\">                //设置文本框的字符串  </div><div class=\"line\">                revtext.setText(msg);  </div><div class=\"line\">            &#125; catch (UnknownHostException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125; catch (IOException e) &#123;  </div><div class=\"line\">                // TODO Auto-generated catch block  </div><div class=\"line\">                e.printStackTrace();  </div><div class=\"line\">            &#125;  </div><div class=\"line\">              </div><div class=\"line\">        &#125;  </div><div class=\"line\">    &#125;  </div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>"},{"title":"java_reference","date":"2017-05-09T07:35:10.000Z","_content":"\n## Java四种基本引用\n\n1．强引用\n本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n2．软引用（SoftReference）\n\n如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n3．弱引用（WeakReference）\n如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n4．虚引用（PhantomReference）\n\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。\n当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n","source":"_posts/java-reference.md","raw":"---\ntitle: java_reference\ndate: 2017-05-9 15:35:10\ncategories: android\ntags: java\n---\n\n## Java四种基本引用\n\n1．强引用\n本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。\n\n2．软引用（SoftReference）\n\n如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。\n\n3．弱引用（WeakReference）\n如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。\n弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。\n\n4．虚引用（PhantomReference）\n\"虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。\n当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。\n","slug":"java-reference","published":1,"updated":"2017-12-14T07:26:23.341Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdd000qkku0txb7npp0","content":"<h2 id=\"Java四种基本引用\"><a href=\"#Java四种基本引用\" class=\"headerlink\" title=\"Java四种基本引用\"></a>Java四种基本引用</h2><p>1．强引用<br>本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n<p>2．软引用（SoftReference）</p>\n<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3．弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>4．虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。<br>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"Java四种基本引用\"><a href=\"#Java四种基本引用\" class=\"headerlink\" title=\"Java四种基本引用\"></a>Java四种基本引用</h2><p>1．强引用<br>本章前文介绍的引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就 类似于必不可少的生活用品，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p>\n<p>2．软引用（SoftReference）</p>\n<p>如果一个对象只具有软引用，那就类似于可有可物的生活用品。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。<br>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p>\n<p>3．弱引用（WeakReference）<br>如果一个对象只具有弱引用，那就类似于可有可物的生活用品。 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。<br>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>\n<p>4．虚引用（PhantomReference）<br>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。<br>当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p>\n"},{"title":"synchronized ， sleep ，wait ，notify，等的理解","date":"2017-05-10T08:30:04.000Z","_content":"\n1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。\n\n2.wait，notify以及notifyall`只能在同步控制方法或者同步控制块中使用`，而sleep可是在任何地方使用。\n\n3.sleep必须捕获异常，而其他3个则不需要。\n\n<!-- more -->\n\n4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别\n\n5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了\n\n6.Obj.wait()，与Obj.notify()`必须要与synchronized(Obj)一起使用`，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制\n\n7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。\n这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。\n    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。\n    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。\n其中wait方法有三个over load方法：\n\nwait()\n\nwait(long)\n\nwait(long,int)\n\nwait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。","source":"_posts/lock.md","raw":"---\ntitle: synchronized ， sleep ，wait ，notify，等的理解\ndate: 2017-05-10 16:30:04\ncategories: android\ntags: 多线程\n---\n\n1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。\n\n2.wait，notify以及notifyall`只能在同步控制方法或者同步控制块中使用`，而sleep可是在任何地方使用。\n\n3.sleep必须捕获异常，而其他3个则不需要。\n\n<!-- more -->\n\n4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别\n\n5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了\n\n6.Obj.wait()，与Obj.notify()`必须要与synchronized(Obj)一起使用`，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){...}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制\n\n7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。\n这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。\n    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。\n    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。\n    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。\n其中wait方法有三个over load方法：\n\nwait()\n\nwait(long)\n\nwait(long,int)\n\nwait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。","slug":"lock","published":1,"updated":"2017-12-14T07:26:23.344Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awde000ukku0459wrsph","content":"<p>1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。</p>\n<p>2.wait，notify以及notifyall<code>只能在同步控制方法或者同步控制块中使用</code>，而sleep可是在任何地方使用。</p>\n<p>3.sleep必须捕获异常，而其他3个则不需要。</p>\n<a id=\"more\"></a>\n<p>4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别</p>\n<p>5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了</p>\n<p>6.Obj.wait()，与Obj.notify()<code>必须要与synchronized(Obj)一起使用</code>，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制</p>\n<p>7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。<br>这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。<br>    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。<br>    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。<br>    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。<br>其中wait方法有三个over load方法：</p>\n<p>wait()</p>\n<p>wait(long)</p>\n<p>wait(long,int)</p>\n<p>wait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。</p>\n","site":{"data":{}},"excerpt":"<p>1.sleep是Thread类的静态方法，谁调用谁去睡觉。sleep是占用cpu去睡觉，而wait是放弃cpu去睡觉， sleep没有释放锁，而wait释放了锁，sleep不会让出cpu资源，wait是进入线程池等待，一般wait是不会使用时间参数，他必须等待别人notify他才会进入就绪队中。而sleep只要时间到了，就会自动进入就绪队列。如果等不及了，只能通过interrupt来强项打断。</p>\n<p>2.wait，notify以及notifyall<code>只能在同步控制方法或者同步控制块中使用</code>，而sleep可是在任何地方使用。</p>\n<p>3.sleep必须捕获异常，而其他3个则不需要。</p>","more":"<p>4.在JAVA中的Object类型中，都是带有一个内存锁的，在有线程获取该内存锁后，其它线程无法访问该内存，从而实现JAVA中简单的同步、互斥操作。明白这个原理，就能理解为什么synchronized(this)与synchronized(static XXX)的区别</p>\n<p>5.synchronized就是针对内存区块申请内存锁，this关键字代表类的一个对象，所以其内存锁是针对相同对象的互斥操作，而static成员属于类专有，其内存空间为该类所有成员共有，这就导致synchronized()对static成员加锁，相当于对类加锁，也就是在该类的所有成员间实现互斥，在同一时间只有一个线程可访问该类的实例。如果只是简单的想要实现在JAVA中的线程互斥，明白这些基本就已经够了。但如果需要在线程间相互唤醒的话就需要借助Object.wait(), Object.nofity()了</p>\n<p>6.Obj.wait()，与Obj.notify()<code>必须要与synchronized(Obj)一起使用</code>，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行。相应的notify()就是对对象锁的唤醒操作。但有一点需要注意的是notify()调用后，并不是马上就释放对象锁的，而是在相应的synchronized(){}语句块执行结束，自动释放锁后，JVM会在wait()对象锁的线程中随机选取一线程，赋予其对象锁，唤醒线程，继续执行。这样就提供了在线程间同步、唤醒的操作。Thread.sleep()与Object.wait()二者都可以暂停当前线程，释放CPU控制权，主要的区别在于Object.wait()在释放CPU同时，释放了对象锁的控制</p>\n<p>7.wait()、notify()、notifyAll()是三个定义在Object类里的方法，可以用来控制线程的状态。<br>这三个方法最终调用的都是jvm级的native方法。随着jvm运行平台的不同可能有些许差异。<br>    如果对象调用了wait方法就会使持有该对象的线程把该对象的控制权交出去，然后处于等待状态。<br>    如果对象调用了notify方法就会通知某个正在等待这个对象的控制权的线程可以继续运行。<br>    如果对象调用了notifyAll方法就会通知所有等待这个对象控制权的线程继续运行。<br>其中wait方法有三个over load方法：</p>\n<p>wait()</p>\n<p>wait(long)</p>\n<p>wait(long,int)</p>\n<p>wait方法通过参数可以指定等待的时长。如果没有指定参数，默认一直等待直到被通知。</p>"},{"title":"浅谈matrix","date":"2017-05-13T08:18:48.000Z","_content":"\n## 基本api\n\n| 方法类别  | \t\t\t\t相关API\t    \t\t\t\t\t\t\t|  摘要  |\n| --------  | \t\t\t\t-----:   \t\t\t\t\t\t\t\t| :----: |\n|基本方法\t|equals hashCode toString toShortString\t\t\t\t\t|比较、 获取哈希值、 转换为字符串\n|数值操作\t|set reset setValues getValues\t\t\t\t\t\t\t|设置、 重置、 设置数值、 获取数值\n|数值计算\t|mapPoints mapRadius mapRect mapVectors\t\t\t\t\t|计算变换后的数值\n|设置(set)\t|setConcat setRotate setScale setSkew setTranslate\t\t|设置变换\n|前乘(pre)\t|preConcat preRotate preScale preSkew preTranslate\t\t|前乘变换\n|后乘(post)\t|postConcat postRotate postScale postSkew postTranslate\t|后乘变换\n|特殊方法\t|setPolyToPoly setRectToRect rectStaysRect setSinCos\t|一些特殊操作\n|矩阵相关\t|invert isAffine(API21) isIdentity\t\t\t\t\t\t|求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵\n\n<!-- more -->\n\n## what is matrix\n\nMatrix是一个矩阵，主要功能是坐标映射，数值转换。\n\n![](http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg)\n\n![](http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg)\n1.缩放(Scale)\n\nx = k1 * x0\ny = k2 * y0\n\n用矩阵表示:\n[x]\t  [k1 0  0] [x0]\n[y] = [0  k2 0] [y0]\n[1]\t  [0  0  1] [1]\n\n2.错切(Skew)\n![](http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png)\n\n3.旋转(Rotate)\n![](http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png)\n\n4.平移(Translate)\n![](http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png)\n\n5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意\n\n## Matrix 常用api\n\n1.setValues getValues\n``` bash\nvoid setValues (float[] values)\nsetValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。\n\nvoid getValues (float[] values) \n```\n2.mapPoints\n``` bash\nvoid mapPoints (float[] pts)\n\nvoid mapPoints (float[] dst, float[] src)\n\nvoid mapPoints (float[] dst, int dstIndex,float[] src, int srcIndex, int pointCount)\n\n计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的float数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)\n```\n3.mapRadius\n``` bash\nfloat mapRadius (float radius)\n测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径\n```\n4.mapRect : 测量矩形变换后位置\n``` bash\nboolean mapRect (RectF rect)\n\nboolean mapRect (RectF dst, RectF src)\n```\n5.4.mapVectors : 测量向量\n``` bash\nvoid mapVectors (float[] vecs)\n\nvoid mapVectors (float[] dst, float[] src)\n\nvoid mapVectors (float[] dst, int dstIndex, float[] src, int srcIndex, int vectorCount)\n\n//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律\n\nfloat[] src = new float[]{1000, 800};\nfloat[] dst = new float[2];\n\n// 构造一个matrix\nMatrix matrix = new Matrix();\nmatrix.setScale(0.5f, 1f);\nmatrix.postTranslate(100,100);\n\n// 计算向量, 不受位移影响\nmatrix.mapVectors(dst, src);\nLog.i(TAG, \"mapVectors: \"+Arrays.toString(dst));\n\n// 计算点\nmatrix.mapPoints(dst, src);\nLog.i(TAG, \"mapPoints: \"+Arrays.toString(dst));\n\n//结果:\nmapVectors: [500.0, 800.0]\nmapPoints: [600.0, 900.0]\n```\n\n## Matrix 特殊使用\n\n1.invert\n求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍\n\n2.isAffine\n判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。\n\n3.isIdentity ：判断是否为单位矩阵\n\n4. 获取View在屏幕上的绝对位置\n``` bash\n@Override\nprotected void onDraw(Canvas canvas) {\n    float[] values = new float[9];\n    int[] location1 = new int[2];\n\n    Matrix matrix = canvas.getMatrix();\n    matrix.getValues(values);\n\n    location1[0] = (int) values[2];\n    location1[1] = (int) values[5];\n    Log.i(TAG, \"location1 = \" + Arrays.toString(location1));\n\n    int[] location2 = new int[2];\n    this.getLocationOnScreen(location2);\n    Log.i(TAG, \"location2 = \" + Arrays.toString(location2));\n}\n```\n5.setRectToRect\n``` bash\nboolean setRectToRect (RectF src,           // 源区域\n                RectF dst,                  // 目标区域\n                Matrix.ScaleToFit stf)      // 缩放适配模式\n简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定\n```\nScaleToFit 是一个枚举类型，共包含了四种模式:\n\n| 方法类别  |  摘要  |\n| --------  | :----: |\n|CENTER\t| 居中，对src等比例缩放，将其居中放置在dst中\n|START\t| 顶部，对src等比例缩放，将其放置在dst的左上角。\n|END\t| 底部，对src等比例缩放，将其放置在dst的右下角。\n|FILL\t| 充满，拉伸src的宽和高，使其完全填充满dst。\n\n6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。\n``` bash\nboolean setPolyToPoly (\n        float[] src,    // 原始数组 src [x,y]，存储内容为一组点\n        int srcIndex,   // 原始数组开始位置\n        float[] dst,    // 目标数组 dst [x,y]，存储内容为一组点\n        int dstIndex,   // 目标数组开始位置\n        int pointCount) // 测控点的数量 取值范围是: 0到4\n```\n\n从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。\n\n| pointCount  | 摘要 |\n| --------  | :----: |\n|\t  0\t    | 相当于reset\n|     1\t\t| 相当于translate\t\t\t\t\n|     2\t\t| 可以进行 缩放、旋转、平移 变换\n|     3\t\t| 可以进行 缩放、旋转、平移、错切 变换 \n|     4\t\t| 可以进行 缩放、旋转、平移、错切以及任何形变 \n``` bash\npublic class MatrixSetPolyToPolyTest extends View {\n\n    private Bitmap mBitmap;             // 要绘制的图片\n    private Matrix mPolyMatrix;         // 测试setPolyToPoly用的Matrix\n\n    public MatrixSetPolyToPolyTest(Context context) {\n        super(context);\n\n        initBitmapAndMatrix();\n    }\n\n    private void initBitmapAndMatrix() {\n        mBitmap = BitmapFactory.decodeResource(getResources(),\n                R.drawable.poly_test);\n\n        mPolyMatrix = new Matrix();\n\n\n        float[] src = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 0,                          // 右上\n                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        float[] dst = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 400,                        // 右上\n                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        // 核心要点\n        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length >> 1); // src.length >> 1 为位移运算 相当于处以2\n\n        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)\n        mPolyMatrix.postScale(0.26f, 0.26f);\n        mPolyMatrix.postTranslate(0,200);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        // 根据Matrix绘制一个变换后的图片\n        canvas.drawBitmap(mBitmap, mPolyMatrix, null);\n    }\n}\n```\n\n","source":"_posts/matrix.md","raw":"---\ntitle: 浅谈matrix\ndate: 2017-05-13 16:18:48\ncategories: android\ntags: matrix\n---\n\n## 基本api\n\n| 方法类别  | \t\t\t\t相关API\t    \t\t\t\t\t\t\t|  摘要  |\n| --------  | \t\t\t\t-----:   \t\t\t\t\t\t\t\t| :----: |\n|基本方法\t|equals hashCode toString toShortString\t\t\t\t\t|比较、 获取哈希值、 转换为字符串\n|数值操作\t|set reset setValues getValues\t\t\t\t\t\t\t|设置、 重置、 设置数值、 获取数值\n|数值计算\t|mapPoints mapRadius mapRect mapVectors\t\t\t\t\t|计算变换后的数值\n|设置(set)\t|setConcat setRotate setScale setSkew setTranslate\t\t|设置变换\n|前乘(pre)\t|preConcat preRotate preScale preSkew preTranslate\t\t|前乘变换\n|后乘(post)\t|postConcat postRotate postScale postSkew postTranslate\t|后乘变换\n|特殊方法\t|setPolyToPoly setRectToRect rectStaysRect setSinCos\t|一些特殊操作\n|矩阵相关\t|invert isAffine(API21) isIdentity\t\t\t\t\t\t|求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵\n\n<!-- more -->\n\n## what is matrix\n\nMatrix是一个矩阵，主要功能是坐标映射，数值转换。\n\n![](http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg)\n\n![](http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg)\n1.缩放(Scale)\n\nx = k1 * x0\ny = k2 * y0\n\n用矩阵表示:\n[x]\t  [k1 0  0] [x0]\n[y] = [0  k2 0] [y0]\n[1]\t  [0  0  1] [1]\n\n2.错切(Skew)\n![](http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png)\n\n3.旋转(Rotate)\n![](http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png)\n\n4.平移(Translate)\n![](http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png)\n\n5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意\n\n## Matrix 常用api\n\n1.setValues getValues\n``` bash\nvoid setValues (float[] values)\nsetValues的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。\n\nvoid getValues (float[] values) \n```\n2.mapPoints\n``` bash\nvoid mapPoints (float[] pts)\n\nvoid mapPoints (float[] dst, float[] src)\n\nvoid mapPoints (float[] dst, int dstIndex,float[] src, int srcIndex, int pointCount)\n\n计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的float数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)\n```\n3.mapRadius\n``` bash\nfloat mapRadius (float radius)\n测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径\n```\n4.mapRect : 测量矩形变换后位置\n``` bash\nboolean mapRect (RectF rect)\n\nboolean mapRect (RectF dst, RectF src)\n```\n5.4.mapVectors : 测量向量\n``` bash\nvoid mapVectors (float[] vecs)\n\nvoid mapVectors (float[] dst, float[] src)\n\nvoid mapVectors (float[] dst, int dstIndex, float[] src, int srcIndex, int vectorCount)\n\n//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律\n\nfloat[] src = new float[]{1000, 800};\nfloat[] dst = new float[2];\n\n// 构造一个matrix\nMatrix matrix = new Matrix();\nmatrix.setScale(0.5f, 1f);\nmatrix.postTranslate(100,100);\n\n// 计算向量, 不受位移影响\nmatrix.mapVectors(dst, src);\nLog.i(TAG, \"mapVectors: \"+Arrays.toString(dst));\n\n// 计算点\nmatrix.mapPoints(dst, src);\nLog.i(TAG, \"mapPoints: \"+Arrays.toString(dst));\n\n//结果:\nmapVectors: [500.0, 800.0]\nmapPoints: [600.0, 900.0]\n```\n\n## Matrix 特殊使用\n\n1.invert\n求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍\n\n2.isAffine\n判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。\n\n3.isIdentity ：判断是否为单位矩阵\n\n4. 获取View在屏幕上的绝对位置\n``` bash\n@Override\nprotected void onDraw(Canvas canvas) {\n    float[] values = new float[9];\n    int[] location1 = new int[2];\n\n    Matrix matrix = canvas.getMatrix();\n    matrix.getValues(values);\n\n    location1[0] = (int) values[2];\n    location1[1] = (int) values[5];\n    Log.i(TAG, \"location1 = \" + Arrays.toString(location1));\n\n    int[] location2 = new int[2];\n    this.getLocationOnScreen(location2);\n    Log.i(TAG, \"location2 = \" + Arrays.toString(location2));\n}\n```\n5.setRectToRect\n``` bash\nboolean setRectToRect (RectF src,           // 源区域\n                RectF dst,                  // 目标区域\n                Matrix.ScaleToFit stf)      // 缩放适配模式\n简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定\n```\nScaleToFit 是一个枚举类型，共包含了四种模式:\n\n| 方法类别  |  摘要  |\n| --------  | :----: |\n|CENTER\t| 居中，对src等比例缩放，将其居中放置在dst中\n|START\t| 顶部，对src等比例缩放，将其放置在dst的左上角。\n|END\t| 底部，对src等比例缩放，将其放置在dst的右下角。\n|FILL\t| 充满，拉伸src的宽和高，使其完全填充满dst。\n\n6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。\n``` bash\nboolean setPolyToPoly (\n        float[] src,    // 原始数组 src [x,y]，存储内容为一组点\n        int srcIndex,   // 原始数组开始位置\n        float[] dst,    // 目标数组 dst [x,y]，存储内容为一组点\n        int dstIndex,   // 目标数组开始位置\n        int pointCount) // 测控点的数量 取值范围是: 0到4\n```\n\n从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。\n\n| pointCount  | 摘要 |\n| --------  | :----: |\n|\t  0\t    | 相当于reset\n|     1\t\t| 相当于translate\t\t\t\t\n|     2\t\t| 可以进行 缩放、旋转、平移 变换\n|     3\t\t| 可以进行 缩放、旋转、平移、错切 变换 \n|     4\t\t| 可以进行 缩放、旋转、平移、错切以及任何形变 \n``` bash\npublic class MatrixSetPolyToPolyTest extends View {\n\n    private Bitmap mBitmap;             // 要绘制的图片\n    private Matrix mPolyMatrix;         // 测试setPolyToPoly用的Matrix\n\n    public MatrixSetPolyToPolyTest(Context context) {\n        super(context);\n\n        initBitmapAndMatrix();\n    }\n\n    private void initBitmapAndMatrix() {\n        mBitmap = BitmapFactory.decodeResource(getResources(),\n                R.drawable.poly_test);\n\n        mPolyMatrix = new Matrix();\n\n\n        float[] src = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 0,                          // 右上\n                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        float[] dst = {0, 0,                                    // 左上\n                mBitmap.getWidth(), 400,                        // 右上\n                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下\n                0, mBitmap.getHeight()};                        // 左下\n\n        // 核心要点\n        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length >> 1); // src.length >> 1 为位移运算 相当于处以2\n\n        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)\n        mPolyMatrix.postScale(0.26f, 0.26f);\n        mPolyMatrix.postTranslate(0,200);\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        // 根据Matrix绘制一个变换后的图片\n        canvas.drawBitmap(mBitmap, mPolyMatrix, null);\n    }\n}\n```\n\n","slug":"matrix","published":1,"updated":"2017-12-14T07:26:23.345Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdf000wkku0m8phjtcm","content":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本方法</td>\n<td style=\"text-align:right\">equals hashCode toString toShortString</td>\n<td style=\"text-align:center\">比较、 获取哈希值、 转换为字符串</td>\n</tr>\n<tr>\n<td>数值操作</td>\n<td style=\"text-align:right\">set reset setValues getValues</td>\n<td style=\"text-align:center\">设置、 重置、 设置数值、 获取数值</td>\n</tr>\n<tr>\n<td>数值计算</td>\n<td style=\"text-align:right\">mapPoints mapRadius mapRect mapVectors</td>\n<td style=\"text-align:center\">计算变换后的数值</td>\n</tr>\n<tr>\n<td>设置(set)</td>\n<td style=\"text-align:right\">setConcat setRotate setScale setSkew setTranslate</td>\n<td style=\"text-align:center\">设置变换</td>\n</tr>\n<tr>\n<td>前乘(pre)</td>\n<td style=\"text-align:right\">preConcat preRotate preScale preSkew preTranslate</td>\n<td style=\"text-align:center\">前乘变换</td>\n</tr>\n<tr>\n<td>后乘(post)</td>\n<td style=\"text-align:right\">postConcat postRotate postScale postSkew postTranslate</td>\n<td style=\"text-align:center\">后乘变换</td>\n</tr>\n<tr>\n<td>特殊方法</td>\n<td style=\"text-align:right\">setPolyToPoly setRectToRect rectStaysRect setSinCos</td>\n<td style=\"text-align:center\">一些特殊操作</td>\n</tr>\n<tr>\n<td>矩阵相关</td>\n<td style=\"text-align:right\">invert isAffine(API21) isIdentity</td>\n<td style=\"text-align:center\">求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵</td>\n</tr>\n</tbody>\n</table>\n<a id=\"more\"></a>\n<h2 id=\"what-is-matrix\"><a href=\"#what-is-matrix\" class=\"headerlink\" title=\"what is matrix\"></a>what is matrix</h2><p>Matrix是一个矩阵，主要功能是坐标映射，数值转换。</p>\n<p><img src=\"http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg\" alt=\"\"><br>1.缩放(Scale)</p>\n<p>x = k1 <em> x0<br>y = k2 </em> y0</p>\n<p>用矩阵表示:<br>[x]      [k1 0  0] [x0]<br>[y] = [0  k2 0] [y0]<br>[1]      [0  0  1] [1]</p>\n<p>2.错切(Skew)<br><img src=\"http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png\" alt=\"\"></p>\n<p>3.旋转(Rotate)<br><img src=\"http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png\" alt=\"\"></p>\n<p>4.平移(Translate)<br><img src=\"http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png\" alt=\"\"></p>\n<p>5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意</p>\n<h2 id=\"Matrix-常用api\"><a href=\"#Matrix-常用api\" class=\"headerlink\" title=\"Matrix 常用api\"></a>Matrix 常用api</h2><p>1.setValues getValues<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void <span class=\"built_in\">set</span>Values (<span class=\"built_in\">float</span>[] values)</div><div class=\"line\"><span class=\"built_in\">set</span>Values的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</div><div class=\"line\"></div><div class=\"line\">void getValues (<span class=\"built_in\">float</span>[] values)</div></pre></td></tr></table></figure></p>\n<p>2.mapPoints<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] pts)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, int dstIndex,<span class=\"built_in\">float</span>[] src, int srcIndex, int pointCount)</div><div class=\"line\"></div><div class=\"line\">计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的<span class=\"built_in\">float</span>数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)</div></pre></td></tr></table></figure></p>\n<p>3.mapRadius<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">float</span> mapRadius (<span class=\"built_in\">float</span> radius)</div><div class=\"line\">测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径</div></pre></td></tr></table></figure></p>\n<p>4.mapRect : 测量矩形变换后位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean mapRect (RectF rect)</div><div class=\"line\"></div><div class=\"line\">boolean mapRect (RectF dst, RectF src)</div></pre></td></tr></table></figure></p>\n<p>5.4.mapVectors : 测量向量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] vecs)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, int dstIndex, <span class=\"built_in\">float</span>[] src, int srcIndex, int vectorCount)</div><div class=\"line\"></div><div class=\"line\">//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">float</span>[] src = new <span class=\"built_in\">float</span>[]&#123;1000, 800&#125;;</div><div class=\"line\"><span class=\"built_in\">float</span>[] dst = new <span class=\"built_in\">float</span>[2];</div><div class=\"line\"></div><div class=\"line\">// 构造一个matrix</div><div class=\"line\">Matrix matrix = new Matrix();</div><div class=\"line\">matrix.setScale(0.5f, 1f);</div><div class=\"line\">matrix.postTranslate(100,100);</div><div class=\"line\"></div><div class=\"line\">// 计算向量, 不受位移影响</div><div class=\"line\">matrix.mapVectors(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapVectors: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">// 计算点</div><div class=\"line\">matrix.mapPoints(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapPoints: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">//结果:</div><div class=\"line\">mapVectors: [500.0, 800.0]</div><div class=\"line\">mapPoints: [600.0, 900.0]</div></pre></td></tr></table></figure></p>\n<h2 id=\"Matrix-特殊使用\"><a href=\"#Matrix-特殊使用\" class=\"headerlink\" title=\"Matrix 特殊使用\"></a>Matrix 特殊使用</h2><p>1.invert<br>求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍</p>\n<p>2.isAffine<br>判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。</p>\n<p>3.isIdentity ：判断是否为单位矩阵</p>\n<ol>\n<li>获取View在屏幕上的绝对位置<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    <span class=\"built_in\">float</span>[] values = new <span class=\"built_in\">float</span>[9];</div><div class=\"line\">    int[] location1 = new int[2];</div><div class=\"line\"></div><div class=\"line\">    Matrix matrix = canvas.getMatrix();</div><div class=\"line\">    matrix.getValues(values);</div><div class=\"line\"></div><div class=\"line\">    location1[0] = (int) values[2];</div><div class=\"line\">    location1[1] = (int) values[5];</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location1 = \"</span> + Arrays.toString(location1));</div><div class=\"line\"></div><div class=\"line\">    int[] location2 = new int[2];</div><div class=\"line\">    this.getLocationOnScreen(location2);</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location2 = \"</span> + Arrays.toString(location2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>5.setRectToRect<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>RectToRect (RectF src,           // 源区域</div><div class=\"line\">                RectF dst,                  // 目标区域</div><div class=\"line\">                Matrix.ScaleToFit stf)      // 缩放适配模式</div><div class=\"line\">简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定</div></pre></td></tr></table></figure></p>\n<p>ScaleToFit 是一个枚举类型，共包含了四种模式:</p>\n<table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CENTER</td>\n<td style=\"text-align:center\">居中，对src等比例缩放，将其居中放置在dst中</td>\n</tr>\n<tr>\n<td>START</td>\n<td style=\"text-align:center\">顶部，对src等比例缩放，将其放置在dst的左上角。</td>\n</tr>\n<tr>\n<td>END</td>\n<td style=\"text-align:center\">底部，对src等比例缩放，将其放置在dst的右下角。</td>\n</tr>\n<tr>\n<td>FILL</td>\n<td style=\"text-align:center\">充满，拉伸src的宽和高，使其完全填充满dst。</td>\n</tr>\n</tbody>\n</table>\n<p>6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>PolyToPoly (</div><div class=\"line\">        <span class=\"built_in\">float</span>[] src,    // 原始数组 src [x,y]，存储内容为一组点</div><div class=\"line\">        int srcIndex,   // 原始数组开始位置</div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst,    // 目标数组 dst [x,y]，存储内容为一组点</div><div class=\"line\">        int dstIndex,   // 目标数组开始位置</div><div class=\"line\">        int pointCount) // 测控点的数量 取值范围是: 0到4</div></pre></td></tr></table></figure></p>\n<p>从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。</p>\n<table>\n<thead>\n<tr>\n<th>pointCount</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">相当于reset</td>\n</tr>\n<tr>\n<td>1</td>\n<td style=\"text-align:center\">相当于translate                </td>\n</tr>\n<tr>\n<td>2</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移 变换</td>\n</tr>\n<tr>\n<td>3</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切 变换 </td>\n</tr>\n<tr>\n<td>4</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切以及任何形变 </td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MatrixSetPolyToPolyTest extends View &#123;</div><div class=\"line\"></div><div class=\"line\">    private Bitmap mBitmap;             // 要绘制的图片</div><div class=\"line\">    private Matrix mPolyMatrix;         // 测试<span class=\"built_in\">set</span>PolyToPoly用的Matrix</div><div class=\"line\"></div><div class=\"line\">    public MatrixSetPolyToPolyTest(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\"></div><div class=\"line\">        initBitmapAndMatrix();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void <span class=\"function\"><span class=\"title\">initBitmapAndMatrix</span></span>() &#123;</div><div class=\"line\">        mBitmap = BitmapFactory.decodeResource(getResources(),</div><div class=\"line\">                R.drawable.poly_test);</div><div class=\"line\"></div><div class=\"line\">        mPolyMatrix = new Matrix();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] src = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 0,                          // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 400,                        // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        // 核心要点</div><div class=\"line\">        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); // src.length &gt;&gt; 1 为位移运算 相当于处以2</div><div class=\"line\"></div><div class=\"line\">        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)</div><div class=\"line\">        mPolyMatrix.postScale(0.26f, 0.26f);</div><div class=\"line\">        mPolyMatrix.postTranslate(0,200);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">        super.onDraw(canvas);</div><div class=\"line\"></div><div class=\"line\">        // 根据Matrix绘制一个变换后的图片</div><div class=\"line\">        canvas.drawBitmap(mBitmap, mPolyMatrix, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h2 id=\"基本api\"><a href=\"#基本api\" class=\"headerlink\" title=\"基本api\"></a>基本api</h2><table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:right\">相关API</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>基本方法</td>\n<td style=\"text-align:right\">equals hashCode toString toShortString</td>\n<td style=\"text-align:center\">比较、 获取哈希值、 转换为字符串</td>\n</tr>\n<tr>\n<td>数值操作</td>\n<td style=\"text-align:right\">set reset setValues getValues</td>\n<td style=\"text-align:center\">设置、 重置、 设置数值、 获取数值</td>\n</tr>\n<tr>\n<td>数值计算</td>\n<td style=\"text-align:right\">mapPoints mapRadius mapRect mapVectors</td>\n<td style=\"text-align:center\">计算变换后的数值</td>\n</tr>\n<tr>\n<td>设置(set)</td>\n<td style=\"text-align:right\">setConcat setRotate setScale setSkew setTranslate</td>\n<td style=\"text-align:center\">设置变换</td>\n</tr>\n<tr>\n<td>前乘(pre)</td>\n<td style=\"text-align:right\">preConcat preRotate preScale preSkew preTranslate</td>\n<td style=\"text-align:center\">前乘变换</td>\n</tr>\n<tr>\n<td>后乘(post)</td>\n<td style=\"text-align:right\">postConcat postRotate postScale postSkew postTranslate</td>\n<td style=\"text-align:center\">后乘变换</td>\n</tr>\n<tr>\n<td>特殊方法</td>\n<td style=\"text-align:right\">setPolyToPoly setRectToRect rectStaysRect setSinCos</td>\n<td style=\"text-align:center\">一些特殊操作</td>\n</tr>\n<tr>\n<td>矩阵相关</td>\n<td style=\"text-align:right\">invert isAffine(API21) isIdentity</td>\n<td style=\"text-align:center\">求逆矩阵、 是否为仿射矩阵、 是否为单位矩阵</td>\n</tr>\n</tbody>\n</table>","more":"<h2 id=\"what-is-matrix\"><a href=\"#what-is-matrix\" class=\"headerlink\" title=\"what is matrix\"></a>what is matrix</h2><p>Matrix是一个矩阵，主要功能是坐标映射，数值转换。</p>\n<p><img src=\"http://img2.ph.126.net/lLgxenxlqDF5YxZLpzNWCA==/6631958370120993878.jpg\" alt=\"\"></p>\n<p><img src=\"http://img2.ph.126.net/vsbc2LIGtxuljuHNXf4wmw==/6632187068539571318.jpg\" alt=\"\"><br>1.缩放(Scale)</p>\n<p>x = k1 <em> x0<br>y = k2 </em> y0</p>\n<p>用矩阵表示:<br>[x]      [k1 0  0] [x0]<br>[y] = [0  k2 0] [y0]<br>[1]      [0  0  1] [1]</p>\n<p>2.错切(Skew)<br><img src=\"http://img2.ph.126.net/PX_kROAusLUUf5wlOSfXYQ==/6632148585632598953.png\" alt=\"\"></p>\n<p>3.旋转(Rotate)<br><img src=\"http://img0.ph.126.net/F_w5X6pSBGRTDgOuYLnTQQ==/6632080415911681023.png\" alt=\"\"></p>\n<p>4.平移(Translate)<br><img src=\"http://img0.ph.126.net/PD1xNmJl62omqzWRDIaxmA==/6631940777934952104.png\" alt=\"\"></p>\n<p>5.每一种操作在Matrix均有三类,前乘(pre)，后乘(post)和设置(set),设置使用的不是矩阵乘法，而是直接覆盖掉原来的数值,这点要注意</p>\n<h2 id=\"Matrix-常用api\"><a href=\"#Matrix-常用api\" class=\"headerlink\" title=\"Matrix 常用api\"></a>Matrix 常用api</h2><p>1.setValues getValues<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">void <span class=\"built_in\">set</span>Values (<span class=\"built_in\">float</span>[] values)</div><div class=\"line\"><span class=\"built_in\">set</span>Values的参数是浮点型的一维数组，长度需要大于9，拷贝数组中的前9位数值赋值给当前Matrix。</div><div class=\"line\"></div><div class=\"line\">void getValues (<span class=\"built_in\">float</span>[] values)</div></pre></td></tr></table></figure></p>\n<p>2.mapPoints<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] pts)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapPoints (<span class=\"built_in\">float</span>[] dst, int dstIndex,<span class=\"built_in\">float</span>[] src, int srcIndex, int pointCount)</div><div class=\"line\"></div><div class=\"line\">计算一组点基于当前Matrix变换后的位置，(由于是计算点，所以参数中的<span class=\"built_in\">float</span>数组长度一般都是偶数的,若为奇数，则最后一个数值不参与计算)</div></pre></td></tr></table></figure></p>\n<p>3.mapRadius<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"built_in\">float</span> mapRadius (<span class=\"built_in\">float</span> radius)</div><div class=\"line\">测量半径，由于圆可能会因为画布变换变成椭圆，所以此处测量的是平均半径</div></pre></td></tr></table></figure></p>\n<p>4.mapRect : 测量矩形变换后位置<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean mapRect (RectF rect)</div><div class=\"line\"></div><div class=\"line\">boolean mapRect (RectF dst, RectF src)</div></pre></td></tr></table></figure></p>\n<p>5.4.mapVectors : 测量向量<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] vecs)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, <span class=\"built_in\">float</span>[] src)</div><div class=\"line\"></div><div class=\"line\">void mapVectors (<span class=\"built_in\">float</span>[] dst, int dstIndex, <span class=\"built_in\">float</span>[] src, int srcIndex, int vectorCount)</div><div class=\"line\"></div><div class=\"line\">//mapVectors 与 mapPoints 基本上是相同的，可以直接参照上面的mapPoints使用方法。而两者唯一的区别就是mapVectors不会受到位移的影响，这符合向量的定律</div><div class=\"line\"></div><div class=\"line\"><span class=\"built_in\">float</span>[] src = new <span class=\"built_in\">float</span>[]&#123;1000, 800&#125;;</div><div class=\"line\"><span class=\"built_in\">float</span>[] dst = new <span class=\"built_in\">float</span>[2];</div><div class=\"line\"></div><div class=\"line\">// 构造一个matrix</div><div class=\"line\">Matrix matrix = new Matrix();</div><div class=\"line\">matrix.setScale(0.5f, 1f);</div><div class=\"line\">matrix.postTranslate(100,100);</div><div class=\"line\"></div><div class=\"line\">// 计算向量, 不受位移影响</div><div class=\"line\">matrix.mapVectors(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapVectors: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">// 计算点</div><div class=\"line\">matrix.mapPoints(dst, src);</div><div class=\"line\">Log.i(TAG, <span class=\"string\">\"mapPoints: \"</span>+Arrays.toString(dst));</div><div class=\"line\"></div><div class=\"line\">//结果:</div><div class=\"line\">mapVectors: [500.0, 800.0]</div><div class=\"line\">mapPoints: [600.0, 900.0]</div></pre></td></tr></table></figure></p>\n<h2 id=\"Matrix-特殊使用\"><a href=\"#Matrix-特殊使用\" class=\"headerlink\" title=\"Matrix 特殊使用\"></a>Matrix 特殊使用</h2><p>1.invert<br>求矩阵的逆矩阵，简而言之就是计算与之前相反的矩阵，如果之前是平移200px，则求的矩阵为反向平移200px，如果之前是缩小到0.5f，则结果是放大到2倍</p>\n<p>2.isAffine<br>判断矩阵是否是仿射矩阵, 貌似并没有太大卵用，因为你无论如何操作结果始终都为true。</p>\n<p>3.isIdentity ：判断是否为单位矩阵</p>\n<ol>\n<li>获取View在屏幕上的绝对位置<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">    <span class=\"built_in\">float</span>[] values = new <span class=\"built_in\">float</span>[9];</div><div class=\"line\">    int[] location1 = new int[2];</div><div class=\"line\"></div><div class=\"line\">    Matrix matrix = canvas.getMatrix();</div><div class=\"line\">    matrix.getValues(values);</div><div class=\"line\"></div><div class=\"line\">    location1[0] = (int) values[2];</div><div class=\"line\">    location1[1] = (int) values[5];</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location1 = \"</span> + Arrays.toString(location1));</div><div class=\"line\"></div><div class=\"line\">    int[] location2 = new int[2];</div><div class=\"line\">    this.getLocationOnScreen(location2);</div><div class=\"line\">    Log.i(TAG, <span class=\"string\">\"location2 = \"</span> + Arrays.toString(location2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>5.setRectToRect<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>RectToRect (RectF src,           // 源区域</div><div class=\"line\">                RectF dst,                  // 目标区域</div><div class=\"line\">                Matrix.ScaleToFit stf)      // 缩放适配模式</div><div class=\"line\">简单来说就是将源矩形的内容填充到目标矩形中，然而在大多数的情况下，源矩形和目标矩形的长宽比是不一致的，到底该如何填充呢，这个填充的模式就由第三个参数 stf 来确定</div></pre></td></tr></table></figure></p>\n<p>ScaleToFit 是一个枚举类型，共包含了四种模式:</p>\n<table>\n<thead>\n<tr>\n<th>方法类别</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CENTER</td>\n<td style=\"text-align:center\">居中，对src等比例缩放，将其居中放置在dst中</td>\n</tr>\n<tr>\n<td>START</td>\n<td style=\"text-align:center\">顶部，对src等比例缩放，将其放置在dst的左上角。</td>\n</tr>\n<tr>\n<td>END</td>\n<td style=\"text-align:center\">底部，对src等比例缩放，将其放置在dst的右下角。</td>\n</tr>\n<tr>\n<td>FILL</td>\n<td style=\"text-align:center\">充满，拉伸src的宽和高，使其完全填充满dst。</td>\n</tr>\n</tbody>\n</table>\n<p>6.setPolyToPoly : 可以用来做3d的效果,Poly全称是Polygon,多边形的意思,与PS中自由变换中的扭曲有点类似。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">boolean <span class=\"built_in\">set</span>PolyToPoly (</div><div class=\"line\">        <span class=\"built_in\">float</span>[] src,    // 原始数组 src [x,y]，存储内容为一组点</div><div class=\"line\">        int srcIndex,   // 原始数组开始位置</div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst,    // 目标数组 dst [x,y]，存储内容为一组点</div><div class=\"line\">        int dstIndex,   // 目标数组开始位置</div><div class=\"line\">        int pointCount) // 测控点的数量 取值范围是: 0到4</div></pre></td></tr></table></figure></p>\n<p>从参数我们可以了解到setPolyToPoly最多可以支持4个点，这四个点通常为图形的四个角，可以通过这四个角将视图从矩形变换成其他形状。</p>\n<table>\n<thead>\n<tr>\n<th>pointCount</th>\n<th style=\"text-align:center\">摘要</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>0</td>\n<td style=\"text-align:center\">相当于reset</td>\n</tr>\n<tr>\n<td>1</td>\n<td style=\"text-align:center\">相当于translate                </td>\n</tr>\n<tr>\n<td>2</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移 变换</td>\n</tr>\n<tr>\n<td>3</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切 变换 </td>\n</tr>\n<tr>\n<td>4</td>\n<td style=\"text-align:center\">可以进行 缩放、旋转、平移、错切以及任何形变 </td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MatrixSetPolyToPolyTest extends View &#123;</div><div class=\"line\"></div><div class=\"line\">    private Bitmap mBitmap;             // 要绘制的图片</div><div class=\"line\">    private Matrix mPolyMatrix;         // 测试<span class=\"built_in\">set</span>PolyToPoly用的Matrix</div><div class=\"line\"></div><div class=\"line\">    public MatrixSetPolyToPolyTest(Context context) &#123;</div><div class=\"line\">        super(context);</div><div class=\"line\"></div><div class=\"line\">        initBitmapAndMatrix();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private void <span class=\"function\"><span class=\"title\">initBitmapAndMatrix</span></span>() &#123;</div><div class=\"line\">        mBitmap = BitmapFactory.decodeResource(getResources(),</div><div class=\"line\">                R.drawable.poly_test);</div><div class=\"line\"></div><div class=\"line\">        mPolyMatrix = new Matrix();</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] src = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 0,                          // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight(),        // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">float</span>[] dst = &#123;0, 0,                                    // 左上</div><div class=\"line\">                mBitmap.getWidth(), 400,                        // 右上</div><div class=\"line\">                mBitmap.getWidth(), mBitmap.getHeight() - 200,  // 右下</div><div class=\"line\">                0, mBitmap.getHeight()&#125;;                        // 左下</div><div class=\"line\"></div><div class=\"line\">        // 核心要点</div><div class=\"line\">        mPolyMatrix.setPolyToPoly(src, 0, dst, 0, src.length &gt;&gt; 1); // src.length &gt;&gt; 1 为位移运算 相当于处以2</div><div class=\"line\"></div><div class=\"line\">        // 此处为了更好的显示对图片进行了等比缩放和平移(图片本身有点大)</div><div class=\"line\">        mPolyMatrix.postScale(0.26f, 0.26f);</div><div class=\"line\">        mPolyMatrix.postTranslate(0,200);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onDraw(Canvas canvas) &#123;</div><div class=\"line\">        super.onDraw(canvas);</div><div class=\"line\"></div><div class=\"line\">        // 根据Matrix绘制一个变换后的图片</div><div class=\"line\">        canvas.drawBitmap(mBitmap, mPolyMatrix, null);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>"},{"title":"optimization_ui","date":"2017-08-27T06:33:03.000Z","_content":"\n## android ui 优化\n\nAndroid UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。\n\nandroid每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。\n\n<!-- more -->\n\n渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。\n\nAndroid的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。\n\n绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。\n\n在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。\n\n在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。\n\n硬件加速的3个缺陷：\n1. 兼容新，部分绘制方式不支持或者不完全支持硬件方式；\n2. 内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。\n3. 电量消耗，GPU耗电较多。\n\n显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。\n\n引发掉帧的原因：\n1）大量的重绘\n2）过度绘制，在在绘制用户看不到的对象上花太多时间\n3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源\n4）频繁地触发垃圾回收\n5）ViewGroup树太深\n所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。\n\n界面开发优化的Advice：\n1. 优化布局的结构\n1）避免复杂的View层次\n2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout\n3）布局层级一样的情况下，用LinearLayout代替RelativeLayout\n4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级\n5）不使用AbsoluteLayout\n6）尽量比曼使用LayoutWeight\n7）合理的布局应该是宽而浅，而非窄而深\n2. 优化处理逻辑\n1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载\n2）避免在UI线程中进行耗时操作\n3. 使用Android自带的性能测试工具进行优化\n\nRelativeLayout与LinearLayout性能比较\n1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）\n2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin\n3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout\n4） 在复杂布局下，用RelativeLayout减少布局层级","source":"_posts/optimization-ui.md","raw":"---\ntitle: optimization_ui\ndate: 2017-08-27 14:33:03\ntags: 优化\n---\n\n## android ui 优化\n\nAndroid UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。\n\nandroid每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。\n\n<!-- more -->\n\n渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。\n\nAndroid的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。\n\n绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。\n\n在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。\n\n在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。\n\n硬件加速的3个缺陷：\n1. 兼容新，部分绘制方式不支持或者不完全支持硬件方式；\n2. 内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。\n3. 电量消耗，GPU耗电较多。\n\n显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。\n\n引发掉帧的原因：\n1）大量的重绘\n2）过度绘制，在在绘制用户看不到的对象上花太多时间\n3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源\n4）频繁地触发垃圾回收\n5）ViewGroup树太深\n所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。\n\n界面开发优化的Advice：\n1. 优化布局的结构\n1）避免复杂的View层次\n2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout\n3）布局层级一样的情况下，用LinearLayout代替RelativeLayout\n4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级\n5）不使用AbsoluteLayout\n6）尽量比曼使用LayoutWeight\n7）合理的布局应该是宽而浅，而非窄而深\n2. 优化处理逻辑\n1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载\n2）避免在UI线程中进行耗时操作\n3. 使用Android自带的性能测试工具进行优化\n\nRelativeLayout与LinearLayout性能比较\n1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）\n2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin\n3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout\n4） 在复杂布局下，用RelativeLayout减少布局层级","slug":"optimization-ui","published":1,"updated":"2017-12-14T07:26:23.346Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdh0010kku03wdercrb","content":"<h2 id=\"android-ui-优化\"><a href=\"#android-ui-优化\" class=\"headerlink\" title=\"android ui 优化\"></a>android ui 优化</h2><p>Android UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。</p>\n<p>android每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。</p>\n<a id=\"more\"></a>\n<p>渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。</p>\n<p>Android的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。</p>\n<p>绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。</p>\n<p>在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。</p>\n<p>在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。</p>\n<p>硬件加速的3个缺陷：</p>\n<ol>\n<li>兼容新，部分绘制方式不支持或者不完全支持硬件方式；</li>\n<li>内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。</li>\n<li>电量消耗，GPU耗电较多。</li>\n</ol>\n<p>显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。</p>\n<p>引发掉帧的原因：<br>1）大量的重绘<br>2）过度绘制，在在绘制用户看不到的对象上花太多时间<br>3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源<br>4）频繁地触发垃圾回收<br>5）ViewGroup树太深<br>所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。</p>\n<p>界面开发优化的Advice：</p>\n<ol>\n<li>优化布局的结构<br>1）避免复杂的View层次<br>2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout<br>3）布局层级一样的情况下，用LinearLayout代替RelativeLayout<br>4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级<br>5）不使用AbsoluteLayout<br>6）尽量比曼使用LayoutWeight<br>7）合理的布局应该是宽而浅，而非窄而深</li>\n<li>优化处理逻辑<br>1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载<br>2）避免在UI线程中进行耗时操作</li>\n<li>使用Android自带的性能测试工具进行优化</li>\n</ol>\n<p>RelativeLayout与LinearLayout性能比较<br>1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）<br>2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin<br>3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout<br>4） 在复杂布局下，用RelativeLayout减少布局层级</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"android-ui-优化\"><a href=\"#android-ui-优化\" class=\"headerlink\" title=\"android ui 优化\"></a>android ui 优化</h2><p>Android UI渲染分为3个过程，分别是测量、布局和绘制，这3个都是深度优先准则，父UI在子UI之前绘制，再按顺序绘制兄弟UI。</p>\n<p>android每16ms发一次VSYNC信号触发UI渲染，只要16ms能达到一个流畅的画面，用户就不会感到卡顿。1000 / 16 ≈60Hz。</p>","more":"<p>渲染分为CPU部分与GPU部分。CPU部分包括测量、布局、记录和执行。GPU部分需要完成光栅化，计算每一个像素点的值。</p>\n<p>Android的显示过程包含两个部分，分别是应用侧绘制和系统侧渲染；采用两个机制，分别是进程侧通信机制和显示刷新机制。</p>\n<p>绘制模型分为基于软件的绘制模型和基于硬件加速的绘制模型。</p>\n<p>在基于软件的绘制模型下，CPU主导绘制，视图按照两个步骤绘制，分别是让View层次结构失效，绘制View层次结构。但是会有两个缺点，绘制了不需要重绘的区域，掩盖了一些应用的bug。</p>\n<p>在基于硬件加速的绘制模型中，GPU主导绘图，按照3个步骤绘制：1）让View层次结构失效； 2） 记录更新列表； 3） 绘制显示列表。</p>\n<p>硬件加速的3个缺陷：</p>\n<ol>\n<li>兼容新，部分绘制方式不支持或者不完全支持硬件方式；</li>\n<li>内存消耗，OPENGL API 调用就会占用8MB，而实际上会占用更多内存。</li>\n<li>电量消耗，GPU耗电较多。</li>\n</ol>\n<p>显示的两个机制，一般采用双缓冲技术，意味着要采用两个缓冲区，一个称为Front Buffer, 另一个称谓Back Buffer，UI现在Back Buffer中绘制，再和Front Buffer进行交换，最多就是三缓冲了，缓冲并不是越多越好。</p>\n<p>引发掉帧的原因：<br>1）大量的重绘<br>2）过度绘制，在在绘制用户看不到的对象上花太多时间<br>3）有一大堆重复动画重复了一遍又一遍，消耗CPU、GPU资源<br>4）频繁地触发垃圾回收<br>5）ViewGroup树太深<br>所有消耗资源的操作，如IO操作、网络操作、SQL操作，列表刷新等，都应该放在后台处理，而不是占用UI线程，以保证UI的流畅性。</p>\n<p>界面开发优化的Advice：</p>\n<ol>\n<li>优化布局的结构<br>1）避免复杂的View层次<br>2）尽量避免在顶层视图中使用RelativeLayout，尽量使用LinearLayout和FrameLayout<br>3）布局层级一样的情况下，用LinearLayout代替RelativeLayout<br>4）在复杂层级上，使用RelativeLay而非LinearLayout来尽量减少层级<br>5）不使用AbsoluteLayout<br>6）尽量比曼使用LayoutWeight<br>7）合理的布局应该是宽而浅，而非窄而深</li>\n<li>优化处理逻辑<br>1）按需载入视图，某些不怎么重用的耗资源视图，等到需要的时候再加载<br>2）避免在UI线程中进行耗时操作</li>\n<li>使用Android自带的性能测试工具进行优化</li>\n</ol>\n<p>RelativeLayout与LinearLayout性能比较<br>1） RelativeLayout会让子View调用两次Measure()。LinearLayout在有layoutWeight是调用两次onMeasure（），没有时调用一次onMeasure（）<br>2） RelativeLayout的子View如果与父View的高度不同，会引发效率问题，当布局很复杂的时候，问题会更严重，因此尽量用padding代替margin<br>3） 在相同的层级下，用LinearLayout或者FrameLayout代替RelativeLayout<br>4） 在复杂布局下，用RelativeLayout减少布局层级</p>"},{"title":"recyclerview","date":"2017-06-03T08:20:02.000Z","_content":"\n## 如何使用 RecyclerView\n\n首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。\n还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）\n\n<!-- more -->\n\n### 3种布局\n``` bash\nLinearLayoutManager ： \nLinearLayoutManager(Context context, int orientation, boolean reverseLayout)\n很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个\n\nGridLayoutManager :\nGridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)\n\nStaggeredGridLayoutManager:\nStaggeredGridLayoutManager(int spanCount, int orientation)\n```\n\n### 点击事件的实现（有两种）\n\n``` bash\n@Override\n    public void onBindViewHolder(final MyViewHolder holder, int position) {\n        loadThumb(position, holder);\n\n        if (mOnItemLitener != null) {\n            holder.itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemClick(holder.itemView, pos);\n                }\n            });\n           \n            holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {\n                @Override\n                public boolean onLongClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemLongClick(holder.itemView, pos);\n                    return false;\n                }\n            });\n        }\n    }\n\t\n\t public interface OnItemLitener {\n        void onItemClick(View view, int position);\n\n        void onItemLongClick(View view, int position);\n    }\n\n    private OnItemLitener mOnItemLitener;\n\n    public void setOnItemLitener(OnItemLitener mOnItemLitener) {\n        this.mOnItemLitener = mOnItemLitener;\n    }\n```\n另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑\n\n### ItemDecoration 间隔线 \n``` bash\npublic class DividerItemDecoration extends RecyclerView.ItemDecoration {\n\n    private static final int[] ATTRS = new int[]{android.R.attr.listDivider};\n    private Drawable mDivider;\n\n    public DividerItemDecoration(Context context) {\n        final TypedArray a = context.obtainStyledAttributes(ATTRS);\n        mDivider = a.getDrawable(0);\n        a.recycle();\n    }\n\n    @Override\n    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {\n        drawHorizontal(c, parent);\n        drawVertical(c, parent);\n    }\n\n    public int getSpanCount(RecyclerView parent) {\n        // 列数\n        int spanCount = -1;\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n\n            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            spanCount = ((StaggeredGridLayoutManager) layoutManager)\n                    .getSpanCount();\n        }\n        return spanCount;\n    }\n\n    public void drawHorizontal(Canvas c, RecyclerView parent) {\n        int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int left = child.getLeft() - params.leftMargin;\n            final int right = child.getRight() + params.rightMargin\n                    + mDivider.getIntrinsicWidth();\n            final int top = child.getBottom() + params.bottomMargin;\n            final int bottom = top + mDivider.getIntrinsicHeight();\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public void drawVertical(Canvas c, RecyclerView parent) {\n        final int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int top = child.getTop() - params.topMargin;\n            final int bottom = child.getBottom() + params.bottomMargin;\n            final int left = child.getRight() + params.rightMargin;\n            final int right = left + mDivider.getIntrinsicWidth();\n\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) { // 注意 StaggeredGridLayoutManager\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 1) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n            {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager)\n                    .getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n                {\n                    return true;\n                }\n            } else {\n                childCount = childCount - childCount % spanCount;\n                if (pos >= childCount)// 如果是最后一列，则不需要绘制右边\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) {  // 注意 StaggeredGridLayoutManager\n\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if (pos < spanCount) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            childCount = childCount - childCount % spanCount;\n            if (pos >= childCount)// 如果是最后一行，则不需要绘制底部\n                return true;\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            // StaggeredGridLayoutManager 且纵向滚动\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                childCount = childCount - childCount % spanCount;\n                // 如果是最后一行，则不需要绘制底部\n                if (pos >= childCount)\n                    return true;\n            } else\n            // StaggeredGridLayoutManager 且横向滚动\n            {\n                // 如果是最后一行，则不需要绘制底部\n                if ((pos + 1) % spanCount == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\t// 主要的绘制逻辑在这里\n    @Override\n    public void getItemOffsets(Rect outRect, int itemPosition,\n                               RecyclerView parent) {\n        int spanCount = getSpanCount(parent);\n        int childCount = parent.getAdapter().getItemCount();\n        if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部\n        {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);\n        } else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边\n        {\n            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());\n        } else {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(),\n                    mDivider.getIntrinsicHeight());\n        }\n    }\n}\n```\n\n###  ItemTouchHelper.Callback 长按拖拽功能，滑动功能 \n``` bash\n public ItemDragHelperCallback callback;\n\n    public void mAddItemDragHelperCallback() {\n\n        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);\n        callback.setOptions(true, true);\n        ItemTouchHelper helper = new ItemTouchHelper(callback);\n        helper.attachToRecyclerView(mRecyclerView);\n\n    }\n````\nItemDragHelperCallback 的代码\n``` bash\nclass ItemDragHelperCallback extends ItemTouchHelper.Callback {\n\n    private RecyclerView.Adapter mMyRecyclerViewAdapter;\n\n    public ItemDragHelperCallback(RecyclerView.Adapter adapter) {\n        mMyRecyclerViewAdapter = adapter;\n    }\n\n\t// 这里控制了拽拉拖动的实现 \n    @Override\n    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        int dragFlags, swipeFlags;\n        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();\n        if (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) {\n            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n        } else {\n            if (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) {\n                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n            } else {\n                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            }\n        }\n\n        return makeMovementFlags(dragFlags, swipeFlags);\n    }\n\n    @Override\n    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {\n        // 不同Type之间不可移动\n        if (viewHolder.getItemViewType() != target.getItemViewType()) {\n            return false;\n        }\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());\n        }\n        return true;\n    }\n\n    @Override\n    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemDelete(viewHolder.getAdapterPosition());\n        }\n    }\n\n    @Override\n    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) {\n        // 不在闲置状态\n        if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) {\n            if (viewHolder instanceof OnDragVHListener) {\n                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n                itemViewHolder.onItemSelected();\n            }\n        }\n        super.onSelectedChanged(viewHolder, actionState);\n    }\n\n    @Override\n    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        if (viewHolder instanceof OnDragVHListener) {\n            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n            itemViewHolder.onItemFinish();\n        }\n        super.clearView(recyclerView, viewHolder);\n    }\n\n    @Override\n    public boolean isLongPressDragEnabled() {\n        // 长按拖拽功能\n        return isLongPressDragEnabled;\n    }\n\n    @Override\n    public boolean isItemViewSwipeEnabled() {\n        // 滑动功能\n        return isItemViewSwipeEnabled;\n    }\n\n    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;\n\n    public void setOptions(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) {\n        this.isLongPressDragEnabled = isLongPressDragEnabled;\n        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;\n    }\n\n    interface OnDragVHListener {\n\n        // Item被选中时触发\n        void onItemSelected();\n\n        // Item在拖拽结束/滑动结束后触发\n        void onItemFinish();\n    }\n\n    interface OnItemTouchListener {\n        void onItemMove(int fromPosition, int toPosition);\n\n        void onItemDelete(int position);\n    }\n}\n```\nadapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，\nViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener\n``` bash\n  @Override\n    public void onItemMove(int fromPosition, int toPosition) {\n        Object item = m_itemInfos.get(fromPosition);\n        m_itemInfos.remove(fromPosition);\n        m_itemInfos.add(toPosition, item);\n        notifyItemMoved(fromPosition, toPosition);\n    }\n\n    @Override\n    public void onItemDelete(int position) {\n        removeItem(position);\n    }\n```\n","source":"_posts/recyclerview.md","raw":"---\ntitle: recyclerview\ndate: 2017-06-03 16:20:02\ncategories: android\ntags: recyclerview\n---\n\n## 如何使用 RecyclerView\n\n首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。\n还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）\n\n<!-- more -->\n\n### 3种布局\n``` bash\nLinearLayoutManager ： \nLinearLayoutManager(Context context, int orientation, boolean reverseLayout)\n很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个\n\nGridLayoutManager :\nGridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)\n\nStaggeredGridLayoutManager:\nStaggeredGridLayoutManager(int spanCount, int orientation)\n```\n\n### 点击事件的实现（有两种）\n\n``` bash\n@Override\n    public void onBindViewHolder(final MyViewHolder holder, int position) {\n        loadThumb(position, holder);\n\n        if (mOnItemLitener != null) {\n            holder.itemView.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemClick(holder.itemView, pos);\n                }\n            });\n           \n            holder.itemView.setOnLongClickListener(new View.OnLongClickListener() {\n                @Override\n                public boolean onLongClick(View v) {\n                    int pos = holder.getLayoutPosition();\n                    mOnItemLitener.onItemLongClick(holder.itemView, pos);\n                    return false;\n                }\n            });\n        }\n    }\n\t\n\t public interface OnItemLitener {\n        void onItemClick(View view, int position);\n\n        void onItemLongClick(View view, int position);\n    }\n\n    private OnItemLitener mOnItemLitener;\n\n    public void setOnItemLitener(OnItemLitener mOnItemLitener) {\n        this.mOnItemLitener = mOnItemLitener;\n    }\n```\n另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑\n\n### ItemDecoration 间隔线 \n``` bash\npublic class DividerItemDecoration extends RecyclerView.ItemDecoration {\n\n    private static final int[] ATTRS = new int[]{android.R.attr.listDivider};\n    private Drawable mDivider;\n\n    public DividerItemDecoration(Context context) {\n        final TypedArray a = context.obtainStyledAttributes(ATTRS);\n        mDivider = a.getDrawable(0);\n        a.recycle();\n    }\n\n    @Override\n    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) {\n        drawHorizontal(c, parent);\n        drawVertical(c, parent);\n    }\n\n    public int getSpanCount(RecyclerView parent) {\n        // 列数\n        int spanCount = -1;\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n\n            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            spanCount = ((StaggeredGridLayoutManager) layoutManager)\n                    .getSpanCount();\n        }\n        return spanCount;\n    }\n\n    public void drawHorizontal(Canvas c, RecyclerView parent) {\n        int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int left = child.getLeft() - params.leftMargin;\n            final int right = child.getRight() + params.rightMargin\n                    + mDivider.getIntrinsicWidth();\n            final int top = child.getBottom() + params.bottomMargin;\n            final int bottom = top + mDivider.getIntrinsicHeight();\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public void drawVertical(Canvas c, RecyclerView parent) {\n        final int childCount = parent.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            final View child = parent.getChildAt(i);\n\n            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child\n                    .getLayoutParams();\n            final int top = child.getTop() - params.topMargin;\n            final int bottom = child.getBottom() + params.bottomMargin;\n            final int left = child.getRight() + params.rightMargin;\n            final int right = left + mDivider.getIntrinsicWidth();\n\n            mDivider.setBounds(left, top, right, bottom);\n            mDivider.draw(c);\n        }\n    }\n\n    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) { // 注意 StaggeredGridLayoutManager\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 1) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n            {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager)\n                    .getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边\n                {\n                    return true;\n                }\n            } else {\n                childCount = childCount - childCount % spanCount;\n                if (pos >= childCount)// 如果是最后一列，则不需要绘制右边\n                    return true;\n            }\n        }\n        return false;\n    }\n\n    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) {  // 注意 StaggeredGridLayoutManager\n\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            if (pos < spanCount) {\n                return true;\n            }\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n\n            } else {\n\n            }\n        }\n        return false;\n    }\n\n    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) {\n        LayoutManager layoutManager = parent.getLayoutManager();\n        if (layoutManager instanceof GridLayoutManager) {\n            childCount = childCount - childCount % spanCount;\n            if (pos >= childCount)// 如果是最后一行，则不需要绘制底部\n                return true;\n        } else if (layoutManager instanceof StaggeredGridLayoutManager) {\n            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();\n            // StaggeredGridLayoutManager 且纵向滚动\n            if (orientation == StaggeredGridLayoutManager.VERTICAL) {\n                childCount = childCount - childCount % spanCount;\n                // 如果是最后一行，则不需要绘制底部\n                if (pos >= childCount)\n                    return true;\n            } else\n            // StaggeredGridLayoutManager 且横向滚动\n            {\n                // 如果是最后一行，则不需要绘制底部\n                if ((pos + 1) % spanCount == 0) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n\n\t// 主要的绘制逻辑在这里\n    @Override\n    public void getItemOffsets(Rect outRect, int itemPosition,\n                               RecyclerView parent) {\n        int spanCount = getSpanCount(parent);\n        int childCount = parent.getAdapter().getItemCount();\n        if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部\n        {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);\n        } else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边\n        {\n            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());\n        } else {\n            outRect.set(0, 0, mDivider.getIntrinsicWidth(),\n                    mDivider.getIntrinsicHeight());\n        }\n    }\n}\n```\n\n###  ItemTouchHelper.Callback 长按拖拽功能，滑动功能 \n``` bash\n public ItemDragHelperCallback callback;\n\n    public void mAddItemDragHelperCallback() {\n\n        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);\n        callback.setOptions(true, true);\n        ItemTouchHelper helper = new ItemTouchHelper(callback);\n        helper.attachToRecyclerView(mRecyclerView);\n\n    }\n````\nItemDragHelperCallback 的代码\n``` bash\nclass ItemDragHelperCallback extends ItemTouchHelper.Callback {\n\n    private RecyclerView.Adapter mMyRecyclerViewAdapter;\n\n    public ItemDragHelperCallback(RecyclerView.Adapter adapter) {\n        mMyRecyclerViewAdapter = adapter;\n    }\n\n\t// 这里控制了拽拉拖动的实现 \n    @Override\n    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        int dragFlags, swipeFlags;\n        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();\n        if (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) {\n            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n        } else {\n            if (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) {\n                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n            } else {\n                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;\n                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;\n            }\n        }\n\n        return makeMovementFlags(dragFlags, swipeFlags);\n    }\n\n    @Override\n    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) {\n        // 不同Type之间不可移动\n        if (viewHolder.getItemViewType() != target.getItemViewType()) {\n            return false;\n        }\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());\n        }\n        return true;\n    }\n\n    @Override\n    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) {\n        if (mMyRecyclerViewAdapter instanceof OnItemTouchListener) {\n            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);\n            listener.onItemDelete(viewHolder.getAdapterPosition());\n        }\n    }\n\n    @Override\n    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) {\n        // 不在闲置状态\n        if (actionState != ItemTouchHelper.ACTION_STATE_IDLE) {\n            if (viewHolder instanceof OnDragVHListener) {\n                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n                itemViewHolder.onItemSelected();\n            }\n        }\n        super.onSelectedChanged(viewHolder, actionState);\n    }\n\n    @Override\n    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) {\n        if (viewHolder instanceof OnDragVHListener) {\n            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;\n            itemViewHolder.onItemFinish();\n        }\n        super.clearView(recyclerView, viewHolder);\n    }\n\n    @Override\n    public boolean isLongPressDragEnabled() {\n        // 长按拖拽功能\n        return isLongPressDragEnabled;\n    }\n\n    @Override\n    public boolean isItemViewSwipeEnabled() {\n        // 滑动功能\n        return isItemViewSwipeEnabled;\n    }\n\n    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;\n\n    public void setOptions(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) {\n        this.isLongPressDragEnabled = isLongPressDragEnabled;\n        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;\n    }\n\n    interface OnDragVHListener {\n\n        // Item被选中时触发\n        void onItemSelected();\n\n        // Item在拖拽结束/滑动结束后触发\n        void onItemFinish();\n    }\n\n    interface OnItemTouchListener {\n        void onItemMove(int fromPosition, int toPosition);\n\n        void onItemDelete(int position);\n    }\n}\n```\nadapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，\nViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener\n``` bash\n  @Override\n    public void onItemMove(int fromPosition, int toPosition) {\n        Object item = m_itemInfos.get(fromPosition);\n        m_itemInfos.remove(fromPosition);\n        m_itemInfos.add(toPosition, item);\n        notifyItemMoved(fromPosition, toPosition);\n    }\n\n    @Override\n    public void onItemDelete(int position) {\n        removeItem(position);\n    }\n```\n","slug":"recyclerview","published":1,"updated":"2017-12-14T07:26:23.348Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdi0013kku0fkcm4u5a","content":"<h2 id=\"如何使用-RecyclerView\"><a href=\"#如何使用-RecyclerView\" class=\"headerlink\" title=\"如何使用 RecyclerView\"></a>如何使用 RecyclerView</h2><p>首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。<br>还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）</p>\n<a id=\"more\"></a>\n<h3 id=\"3种布局\"><a href=\"#3种布局\" class=\"headerlink\" title=\"3种布局\"></a>3种布局</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">LinearLayoutManager ： </div><div class=\"line\">LinearLayoutManager(Context context, int orientation, boolean reverseLayout)</div><div class=\"line\">很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个</div><div class=\"line\"></div><div class=\"line\">GridLayoutManager :</div><div class=\"line\">GridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)</div><div class=\"line\"></div><div class=\"line\">StaggeredGridLayoutManager:</div><div class=\"line\">StaggeredGridLayoutManager(int spanCount, int orientation)</div></pre></td></tr></table></figure>\n<h3 id=\"点击事件的实现（有两种）\"><a href=\"#点击事件的实现（有两种）\" class=\"headerlink\" title=\"点击事件的实现（有两种）\"></a>点击事件的实现（有两种）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void onBindViewHolder(final MyViewHolder holder, int position) &#123;</div><div class=\"line\">        loadThumb(position, holder);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mOnItemLitener != null) &#123;</div><div class=\"line\">            holder.itemView.setOnClickListener(new View.<span class=\"function\"><span class=\"title\">OnClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void onClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemClick(holder.itemView, pos);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">           </div><div class=\"line\">            holder.itemView.setOnLongClickListener(new View.<span class=\"function\"><span class=\"title\">OnLongClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public boolean onLongClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemLongClick(holder.itemView, pos);</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t public interface OnItemLitener &#123;</div><div class=\"line\">        void onItemClick(View view, int position);</div><div class=\"line\"></div><div class=\"line\">        void onItemLongClick(View view, int position);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private OnItemLitener mOnItemLitener;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>OnItemLitener(OnItemLitener mOnItemLitener) &#123;</div><div class=\"line\">        this.mOnItemLitener = mOnItemLitener;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑</p>\n<h3 id=\"ItemDecoration-间隔线\"><a href=\"#ItemDecoration-间隔线\" class=\"headerlink\" title=\"ItemDecoration 间隔线\"></a>ItemDecoration 间隔线</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final int[] ATTRS = new int[]&#123;android.R.attr.listDivider&#125;;</div><div class=\"line\">    private Drawable mDivider;</div><div class=\"line\"></div><div class=\"line\">    public DividerItemDecoration(Context context) &#123;</div><div class=\"line\">        final TypedArray a = context.obtainStyledAttributes(ATTRS);</div><div class=\"line\">        mDivider = a.getDrawable(0);</div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</div><div class=\"line\">        drawHorizontal(c, parent);</div><div class=\"line\">        drawVertical(c, parent);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getSpanCount(RecyclerView parent) &#123;</div><div class=\"line\">        // 列数</div><div class=\"line\">        int spanCount = -1;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\"></div><div class=\"line\">            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            spanCount = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getSpanCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> spanCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawHorizontal(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int left = child.getLeft() - params.leftMargin;</div><div class=\"line\">            final int right = child.getRight() + params.rightMargin</div><div class=\"line\">                    + mDivider.getIntrinsicWidth();</div><div class=\"line\">            final int top = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int bottom = top + mDivider.getIntrinsicHeight();</div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawVertical(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        final int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\"></div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int top = child.getTop() - params.topMargin;</div><div class=\"line\">            final int bottom = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int left = child.getRight() + params.rightMargin;</div><div class=\"line\">            final int right = left + mDivider.getIntrinsicWidth();</div><div class=\"line\"></div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; // 注意 StaggeredGridLayoutManager</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 1) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;  // 注意 StaggeredGridLayoutManager</div><div class=\"line\"></div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &lt; spanCount) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            childCount = childCount - childCount % spanCount;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            // StaggeredGridLayoutManager 且纵向滚动</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span></div><div class=\"line\">            // StaggeredGridLayoutManager 且横向滚动</div><div class=\"line\">            &#123;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0) &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 主要的绘制逻辑在这里</div><div class=\"line\">    @Override</div><div class=\"line\">    public void getItemOffsets(Rect outRect, int itemPosition,</div><div class=\"line\">                               RecyclerView parent) &#123;</div><div class=\"line\">        int spanCount = getSpanCount(parent);</div><div class=\"line\">        int childCount = parent.getAdapter().getItemCount();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(),</div><div class=\"line\">                    mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ItemTouchHelper-Callback-长按拖拽功能，滑动功能\"><a href=\"#ItemTouchHelper-Callback-长按拖拽功能，滑动功能\" class=\"headerlink\" title=\"ItemTouchHelper.Callback 长按拖拽功能，滑动功能\"></a>ItemTouchHelper.Callback 长按拖拽功能，滑动功能</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public ItemDragHelperCallback callback;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">mAddItemDragHelperCallback</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);</div><div class=\"line\">        callback.setOptions(<span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">        ItemTouchHelper helper = new ItemTouchHelper(callback);</div><div class=\"line\">        helper.attachToRecyclerView(mRecyclerView);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p>ItemDragHelperCallback 的代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ItemDragHelperCallback extends ItemTouchHelper.Callback &#123;</div><div class=\"line\"></div><div class=\"line\">    private RecyclerView.Adapter mMyRecyclerViewAdapter;</div><div class=\"line\"></div><div class=\"line\">    public ItemDragHelperCallback(RecyclerView.Adapter adapter) &#123;</div><div class=\"line\">        mMyRecyclerViewAdapter = adapter;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 这里控制了拽拉拖动的实现 </div><div class=\"line\">    @Override</div><div class=\"line\">    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        int dragFlags, swipeFlags;</div><div class=\"line\">        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">return</span> makeMovementFlags(dragFlags, swipeFlags);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123;</div><div class=\"line\">        // 不同Type之间不可移动</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder.getItemViewType() != target.getItemViewType()) &#123;</div><div class=\"line\">            <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemDelete(viewHolder.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123;</div><div class=\"line\">        // 不在闲置状态</div><div class=\"line\">        <span class=\"keyword\">if</span> (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">                itemViewHolder.onItemSelected();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.onSelectedChanged(viewHolder, actionState);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">            itemViewHolder.onItemFinish();</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.clearView(recyclerView, viewHolder);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isLongPressDragEnabled</span></span>() &#123;</div><div class=\"line\">        // 长按拖拽功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isLongPressDragEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isItemViewSwipeEnabled</span></span>() &#123;</div><div class=\"line\">        // 滑动功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>Options(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) &#123;</div><div class=\"line\">        this.isLongPressDragEnabled = isLongPressDragEnabled;</div><div class=\"line\">        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnDragVHListener &#123;</div><div class=\"line\"></div><div class=\"line\">        // Item被选中时触发</div><div class=\"line\">        void onItemSelected();</div><div class=\"line\"></div><div class=\"line\">        // Item在拖拽结束/滑动结束后触发</div><div class=\"line\">        void onItemFinish();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnItemTouchListener &#123;</div><div class=\"line\">        void onItemMove(int fromPosition, int toPosition);</div><div class=\"line\"></div><div class=\"line\">        void onItemDelete(int position);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>adapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，<br>ViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  public void onItemMove(int fromPosition, int toPosition) &#123;</div><div class=\"line\">      Object item = m_itemInfos.get(fromPosition);</div><div class=\"line\">      m_itemInfos.remove(fromPosition);</div><div class=\"line\">      m_itemInfos.add(toPosition, item);</div><div class=\"line\">      notifyItemMoved(fromPosition, toPosition);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onItemDelete(int position) &#123;</div><div class=\"line\">      removeItem(position);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何使用-RecyclerView\"><a href=\"#如何使用-RecyclerView\" class=\"headerlink\" title=\"如何使用 RecyclerView\"></a>如何使用 RecyclerView</h2><p>首先是recyclerview的配置问题，recyclerview是要导入android.support.v7.widget.RecyclerView的包。<br>还要在Gradle Scripts中添加 compile ‘com.android.support:recyclerview-v7:23.4.0’，然后同步。（23.4.0是版本号记得改成自己有的）</p>","more":"<h3 id=\"3种布局\"><a href=\"#3种布局\" class=\"headerlink\" title=\"3种布局\"></a>3种布局</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">LinearLayoutManager ： </div><div class=\"line\">LinearLayoutManager(Context context, int orientation, boolean reverseLayout)</div><div class=\"line\">很浅显线性布局，水平或者垂直，第三个参数的意思是：是否倒置数据，就是数据源最后面的显示在第一个，倒数第二显示在第二个</div><div class=\"line\"></div><div class=\"line\">GridLayoutManager :</div><div class=\"line\">GridLayoutManager(Context context, int spanCount, int orientation,boolean reverseLayout)</div><div class=\"line\"></div><div class=\"line\">StaggeredGridLayoutManager:</div><div class=\"line\">StaggeredGridLayoutManager(int spanCount, int orientation)</div></pre></td></tr></table></figure>\n<h3 id=\"点击事件的实现（有两种）\"><a href=\"#点击事件的实现（有两种）\" class=\"headerlink\" title=\"点击事件的实现（有两种）\"></a>点击事件的实现（有两种）</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">    public void onBindViewHolder(final MyViewHolder holder, int position) &#123;</div><div class=\"line\">        loadThumb(position, holder);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (mOnItemLitener != null) &#123;</div><div class=\"line\">            holder.itemView.setOnClickListener(new View.<span class=\"function\"><span class=\"title\">OnClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public void onClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemClick(holder.itemView, pos);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">           </div><div class=\"line\">            holder.itemView.setOnLongClickListener(new View.<span class=\"function\"><span class=\"title\">OnLongClickListener</span></span>() &#123;</div><div class=\"line\">                @Override</div><div class=\"line\">                public boolean onLongClick(View v) &#123;</div><div class=\"line\">                    int pos = holder.getLayoutPosition();</div><div class=\"line\">                    mOnItemLitener.onItemLongClick(holder.itemView, pos);</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">\t</div><div class=\"line\">\t public interface OnItemLitener &#123;</div><div class=\"line\">        void onItemClick(View view, int position);</div><div class=\"line\"></div><div class=\"line\">        void onItemLongClick(View view, int position);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    private OnItemLitener mOnItemLitener;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>OnItemLitener(OnItemLitener mOnItemLitener) &#123;</div><div class=\"line\">        this.mOnItemLitener = mOnItemLitener;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n<p>另外一种通过addOnItemTouchListener自己去实现计算位置的逻辑</p>\n<h3 id=\"ItemDecoration-间隔线\"><a href=\"#ItemDecoration-间隔线\" class=\"headerlink\" title=\"ItemDecoration 间隔线\"></a>ItemDecoration 间隔线</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div><div class=\"line\">106</div><div class=\"line\">107</div><div class=\"line\">108</div><div class=\"line\">109</div><div class=\"line\">110</div><div class=\"line\">111</div><div class=\"line\">112</div><div class=\"line\">113</div><div class=\"line\">114</div><div class=\"line\">115</div><div class=\"line\">116</div><div class=\"line\">117</div><div class=\"line\">118</div><div class=\"line\">119</div><div class=\"line\">120</div><div class=\"line\">121</div><div class=\"line\">122</div><div class=\"line\">123</div><div class=\"line\">124</div><div class=\"line\">125</div><div class=\"line\">126</div><div class=\"line\">127</div><div class=\"line\">128</div><div class=\"line\">129</div><div class=\"line\">130</div><div class=\"line\">131</div><div class=\"line\">132</div><div class=\"line\">133</div><div class=\"line\">134</div><div class=\"line\">135</div><div class=\"line\">136</div><div class=\"line\">137</div><div class=\"line\">138</div><div class=\"line\">139</div><div class=\"line\">140</div><div class=\"line\">141</div><div class=\"line\">142</div><div class=\"line\">143</div><div class=\"line\">144</div><div class=\"line\">145</div><div class=\"line\">146</div><div class=\"line\">147</div><div class=\"line\">148</div><div class=\"line\">149</div><div class=\"line\">150</div><div class=\"line\">151</div><div class=\"line\">152</div><div class=\"line\">153</div><div class=\"line\">154</div><div class=\"line\">155</div><div class=\"line\">156</div><div class=\"line\">157</div><div class=\"line\">158</div><div class=\"line\">159</div><div class=\"line\">160</div><div class=\"line\">161</div><div class=\"line\">162</div><div class=\"line\">163</div><div class=\"line\">164</div><div class=\"line\">165</div><div class=\"line\">166</div><div class=\"line\">167</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class DividerItemDecoration extends RecyclerView.ItemDecoration &#123;</div><div class=\"line\"></div><div class=\"line\">    private static final int[] ATTRS = new int[]&#123;android.R.attr.listDivider&#125;;</div><div class=\"line\">    private Drawable mDivider;</div><div class=\"line\"></div><div class=\"line\">    public DividerItemDecoration(Context context) &#123;</div><div class=\"line\">        final TypedArray a = context.obtainStyledAttributes(ATTRS);</div><div class=\"line\">        mDivider = a.getDrawable(0);</div><div class=\"line\">        a.recycle();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123;</div><div class=\"line\">        drawHorizontal(c, parent);</div><div class=\"line\">        drawVertical(c, parent);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public int getSpanCount(RecyclerView parent) &#123;</div><div class=\"line\">        // 列数</div><div class=\"line\">        int spanCount = -1;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\"></div><div class=\"line\">            spanCount = ((GridLayoutManager) layoutManager).getSpanCount();</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            spanCount = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getSpanCount();</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> spanCount;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawHorizontal(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int left = child.getLeft() - params.leftMargin;</div><div class=\"line\">            final int right = child.getRight() + params.rightMargin</div><div class=\"line\">                    + mDivider.getIntrinsicWidth();</div><div class=\"line\">            final int top = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int bottom = top + mDivider.getIntrinsicHeight();</div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public void drawVertical(Canvas c, RecyclerView parent) &#123;</div><div class=\"line\">        final int childCount = parent.getChildCount();</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; childCount; i++) &#123;</div><div class=\"line\">            final View child = parent.getChildAt(i);</div><div class=\"line\"></div><div class=\"line\">            final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child</div><div class=\"line\">                    .getLayoutParams();</div><div class=\"line\">            final int top = child.getTop() - params.topMargin;</div><div class=\"line\">            final int bottom = child.getBottom() + params.bottomMargin;</div><div class=\"line\">            final int left = child.getRight() + params.rightMargin;</div><div class=\"line\">            final int right = left + mDivider.getIntrinsicWidth();</div><div class=\"line\"></div><div class=\"line\">            mDivider.setBounds(left, top, right, bottom);</div><div class=\"line\">            mDivider.draw(c);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; // 注意 StaggeredGridLayoutManager</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 1) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">            &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager)</div><div class=\"line\">                    .getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isFirstRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;  // 注意 StaggeredGridLayoutManager</div><div class=\"line\"></div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &lt; spanCount) &#123;</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123;</div><div class=\"line\">        LayoutManager layoutManager = parent.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (layoutManager instanceof GridLayoutManager) &#123;</div><div class=\"line\">            childCount = childCount - childCount % spanCount;</div><div class=\"line\">            <span class=\"keyword\">if</span> (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (layoutManager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            int orientation = ((StaggeredGridLayoutManager) layoutManager).getOrientation();</div><div class=\"line\">            // StaggeredGridLayoutManager 且纵向滚动</div><div class=\"line\">            <span class=\"keyword\">if</span> (orientation == StaggeredGridLayoutManager.VERTICAL) &#123;</div><div class=\"line\">                childCount = childCount - childCount % spanCount;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> (pos &gt;= childCount)</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span></div><div class=\"line\">            // StaggeredGridLayoutManager 且横向滚动</div><div class=\"line\">            &#123;</div><div class=\"line\">                // 如果是最后一行，则不需要绘制底部</div><div class=\"line\">                <span class=\"keyword\">if</span> ((pos + 1) % spanCount == 0) &#123;</div><div class=\"line\">                    <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 主要的绘制逻辑在这里</div><div class=\"line\">    @Override</div><div class=\"line\">    public void getItemOffsets(Rect outRect, int itemPosition,</div><div class=\"line\">                               RecyclerView parent) &#123;</div><div class=\"line\">        int spanCount = getSpanCount(parent);</div><div class=\"line\">        int childCount = parent.getAdapter().getItemCount();</div><div class=\"line\">        <span class=\"keyword\">if</span> (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0);</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边</div><div class=\"line\">        &#123;</div><div class=\"line\">            outRect.set(0, 0, 0, mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            outRect.set(0, 0, mDivider.getIntrinsicWidth(),</div><div class=\"line\">                    mDivider.getIntrinsicHeight());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"ItemTouchHelper-Callback-长按拖拽功能，滑动功能\"><a href=\"#ItemTouchHelper-Callback-长按拖拽功能，滑动功能\" class=\"headerlink\" title=\"ItemTouchHelper.Callback 长按拖拽功能，滑动功能\"></a>ItemTouchHelper.Callback 长按拖拽功能，滑动功能</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public ItemDragHelperCallback callback;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">mAddItemDragHelperCallback</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">        callback = new ItemDragHelperCallback(mMyRecyclerViewAdapter);</div><div class=\"line\">        callback.setOptions(<span class=\"literal\">true</span>, <span class=\"literal\">true</span>);</div><div class=\"line\">        ItemTouchHelper helper = new ItemTouchHelper(callback);</div><div class=\"line\">        helper.attachToRecyclerView(mRecyclerView);</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">`</div></pre></td></tr></table></figure>\n<p>ItemDragHelperCallback 的代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div><div class=\"line\">99</div><div class=\"line\">100</div><div class=\"line\">101</div><div class=\"line\">102</div><div class=\"line\">103</div><div class=\"line\">104</div><div class=\"line\">105</div></pre></td><td class=\"code\"><pre><div class=\"line\">class ItemDragHelperCallback extends ItemTouchHelper.Callback &#123;</div><div class=\"line\"></div><div class=\"line\">    private RecyclerView.Adapter mMyRecyclerViewAdapter;</div><div class=\"line\"></div><div class=\"line\">    public ItemDragHelperCallback(RecyclerView.Adapter adapter) &#123;</div><div class=\"line\">        mMyRecyclerViewAdapter = adapter;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">\t// 这里控制了拽拉拖动的实现 </div><div class=\"line\">    @Override</div><div class=\"line\">    public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        int dragFlags, swipeFlags;</div><div class=\"line\">        RecyclerView.LayoutManager manager = recyclerView.getLayoutManager();</div><div class=\"line\">        <span class=\"keyword\">if</span> (manager instanceof GridLayoutManager || manager instanceof StaggeredGridLayoutManager) &#123;</div><div class=\"line\">            dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN | ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (((LinearLayoutManager) manager).getOrientation() == LinearLayoutManager.HORIZONTAL) &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN;</div><div class=\"line\">                swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"built_in\">return</span> makeMovementFlags(dragFlags, swipeFlags);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) &#123;</div><div class=\"line\">        // 不同Type之间不可移动</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder.getItemViewType() != target.getItemViewType()) &#123;</div><div class=\"line\">            <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemMove(viewHolder.getAdapterPosition(), target.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">true</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (mMyRecyclerViewAdapter instanceof OnItemTouchListener) &#123;</div><div class=\"line\">            OnItemTouchListener listener = ((OnItemTouchListener) mMyRecyclerViewAdapter);</div><div class=\"line\">            listener.onItemDelete(viewHolder.getAdapterPosition());</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState) &#123;</div><div class=\"line\">        // 不在闲置状态</div><div class=\"line\">        <span class=\"keyword\">if</span> (actionState != ItemTouchHelper.ACTION_STATE_IDLE) &#123;</div><div class=\"line\">            <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">                OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">                itemViewHolder.onItemSelected();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.onSelectedChanged(viewHolder, actionState);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (viewHolder instanceof OnDragVHListener) &#123;</div><div class=\"line\">            OnDragVHListener itemViewHolder = (OnDragVHListener) viewHolder;</div><div class=\"line\">            itemViewHolder.onItemFinish();</div><div class=\"line\">        &#125;</div><div class=\"line\">        super.clearView(recyclerView, viewHolder);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isLongPressDragEnabled</span></span>() &#123;</div><div class=\"line\">        // 长按拖拽功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isLongPressDragEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isItemViewSwipeEnabled</span></span>() &#123;</div><div class=\"line\">        // 滑动功能</div><div class=\"line\">        <span class=\"built_in\">return</span> isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    public boolean isLongPressDragEnabled, isItemViewSwipeEnabled;</div><div class=\"line\"></div><div class=\"line\">    public void <span class=\"built_in\">set</span>Options(boolean isLongPressDragEnabled, boolean isItemViewSwipeEnabled) &#123;</div><div class=\"line\">        this.isLongPressDragEnabled = isLongPressDragEnabled;</div><div class=\"line\">        this.isItemViewSwipeEnabled = isItemViewSwipeEnabled;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnDragVHListener &#123;</div><div class=\"line\"></div><div class=\"line\">        // Item被选中时触发</div><div class=\"line\">        void onItemSelected();</div><div class=\"line\"></div><div class=\"line\">        // Item在拖拽结束/滑动结束后触发</div><div class=\"line\">        void onItemFinish();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    interface OnItemTouchListener &#123;</div><div class=\"line\">        void onItemMove(int fromPosition, int toPosition);</div><div class=\"line\"></div><div class=\"line\">        void onItemDelete(int position);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>adapter 相应的实现,要implements ItemDragHelperCallback.OnItemTouchListener，<br>ViewHolder 要 implements ItemDragHelperCallback.OnDragVHListener<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">  public void onItemMove(int fromPosition, int toPosition) &#123;</div><div class=\"line\">      Object item = m_itemInfos.get(fromPosition);</div><div class=\"line\">      m_itemInfos.remove(fromPosition);</div><div class=\"line\">      m_itemInfos.add(toPosition, item);</div><div class=\"line\">      notifyItemMoved(fromPosition, toPosition);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  @Override</div><div class=\"line\">  public void onItemDelete(int position) &#123;</div><div class=\"line\">      removeItem(position);</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure></p>"},{"title":"recyclerview 自定义动画","date":"2017-06-04T08:19:42.000Z","_content":"\n## DefaultItemAnimator \n\nRecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画\nDefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析\n\n``` bash\n public class BaseItemAnimator extends SimpleItemAnimator {\n    //Item移除回调\n    @Override\n    public boolean animateRemove(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n    //Item添加回调\n    @Override\n    public boolean animateAdd(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n\n    //用于控制添加，移动更新时，其它Item的动画执行\n    @Override\n    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) {\n        return false;\n    }\n\n    //Item更新回调\n    @Override\n    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) {\n        return false;\n    }\n\n    //真正控制执行动画的地方\n    @Override\n    public void runPendingAnimations() {\n\n    }\n\n    //停止某个Item的动画\n    @Override\n    public void endAnimation(RecyclerView.ViewHolder item) {\n\n    }\n\n    //停止所有动画\n    @Override\n    public void endAnimations() {\n\n    }\n\n    @Override\n    public boolean isRunning() {\n        return false;\n    }\n}\n```\n\n<!-- more -->\n\n具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add\n``` bash\n\t\t// Next, add stuff\n        if (additionsPending) {\n            final ArrayList<ViewHolder> additions = new ArrayList<>();\n            additions.addAll(mPendingAdditions);\n            mAdditionsList.add(additions);\n            mPendingAdditions.clear();\n            Runnable adder = new Runnable() {\n                @Override\n                public void run() {\n                    for (ViewHolder holder : additions) {\n                        animateAddImpl(holder);\n                    }\n                    additions.clear();\n                    mAdditionsList.remove(additions);\n                }\n            };\n            if (removalsPending || movesPending || changesPending) {\n                long removeDuration = removalsPending ? getRemoveDuration() : 0;\n                long moveDuration = movesPending ? getMoveDuration() : 0;\n                long changeDuration = changesPending ? getChangeDuration() : 0;\n                long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);\n                View view = additions.get(0).itemView;\n                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算\n            } else {\n                adder.run();\n            }\n        }\n```\n\n## ViewPropertyAnimatorCompat\n\nDefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说\n``` bash\n private void animateRemoveImpl(final ViewHolder holder) {\n        final View view = holder.itemView;\n        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);\n        mRemoveAnimations.add(holder);\n        animation.setDuration(getRemoveDuration())\n                .alpha(0).setListener(new VpaListenerAdapter() {\n            @Override\n            public void onAnimationStart(View view) {\n                dispatchRemoveStarting(holder);\n            }\n\n            @Override\n            public void onAnimationEnd(View view) {\n                animation.setListener(null);\n                ViewCompat.setAlpha(view, 1);\n                dispatchRemoveFinished(holder);\n                mRemoveAnimations.remove(holder);\n                dispatchFinishedWhenDone();\n            }\n        }).start();\n    }\n```\n这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画\n``` bash\n    interface ViewPropertyAnimatorCompatImpl {\n        public void setDuration(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getDuration(ViewPropertyAnimatorCompat vpa, View view);\n        public void setInterpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);\n        public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);\n        public void setStartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);\n        public void alpha(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotation(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void cancel(ViewPropertyAnimatorCompat vpa, View view);\n        public void x(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void xBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void y(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void yBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void z(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void zBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZ(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void start(ViewPropertyAnimatorCompat vpa, View view);\n        public void withLayer(ViewPropertyAnimatorCompat vpa, View view);\n        public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void setListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorListener listener);\n        public void setUpdateListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorUpdateListener listener);\n    };\n```","source":"_posts/recyclerviewANM.md","raw":"---\ntitle: recyclerview 自定义动画\ndate: 2017-06-04 16:19:42\ncategories: android\ntags: recyclerview\n---\n\n## DefaultItemAnimator \n\nRecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画\nDefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析\n\n``` bash\n public class BaseItemAnimator extends SimpleItemAnimator {\n    //Item移除回调\n    @Override\n    public boolean animateRemove(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n    //Item添加回调\n    @Override\n    public boolean animateAdd(RecyclerView.ViewHolder holder) {\n        return false;\n    }\n\n\n    //用于控制添加，移动更新时，其它Item的动画执行\n    @Override\n    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) {\n        return false;\n    }\n\n    //Item更新回调\n    @Override\n    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) {\n        return false;\n    }\n\n    //真正控制执行动画的地方\n    @Override\n    public void runPendingAnimations() {\n\n    }\n\n    //停止某个Item的动画\n    @Override\n    public void endAnimation(RecyclerView.ViewHolder item) {\n\n    }\n\n    //停止所有动画\n    @Override\n    public void endAnimations() {\n\n    }\n\n    @Override\n    public boolean isRunning() {\n        return false;\n    }\n}\n```\n\n<!-- more -->\n\n具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add\n``` bash\n\t\t// Next, add stuff\n        if (additionsPending) {\n            final ArrayList<ViewHolder> additions = new ArrayList<>();\n            additions.addAll(mPendingAdditions);\n            mAdditionsList.add(additions);\n            mPendingAdditions.clear();\n            Runnable adder = new Runnable() {\n                @Override\n                public void run() {\n                    for (ViewHolder holder : additions) {\n                        animateAddImpl(holder);\n                    }\n                    additions.clear();\n                    mAdditionsList.remove(additions);\n                }\n            };\n            if (removalsPending || movesPending || changesPending) {\n                long removeDuration = removalsPending ? getRemoveDuration() : 0;\n                long moveDuration = movesPending ? getMoveDuration() : 0;\n                long changeDuration = changesPending ? getChangeDuration() : 0;\n                long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);\n                View view = additions.get(0).itemView;\n                ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算\n            } else {\n                adder.run();\n            }\n        }\n```\n\n## ViewPropertyAnimatorCompat\n\nDefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说\n``` bash\n private void animateRemoveImpl(final ViewHolder holder) {\n        final View view = holder.itemView;\n        final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);\n        mRemoveAnimations.add(holder);\n        animation.setDuration(getRemoveDuration())\n                .alpha(0).setListener(new VpaListenerAdapter() {\n            @Override\n            public void onAnimationStart(View view) {\n                dispatchRemoveStarting(holder);\n            }\n\n            @Override\n            public void onAnimationEnd(View view) {\n                animation.setListener(null);\n                ViewCompat.setAlpha(view, 1);\n                dispatchRemoveFinished(holder);\n                mRemoveAnimations.remove(holder);\n                dispatchFinishedWhenDone();\n            }\n        }).start();\n    }\n```\n这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画\n``` bash\n    interface ViewPropertyAnimatorCompatImpl {\n        public void setDuration(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getDuration(ViewPropertyAnimatorCompat vpa, View view);\n        public void setInterpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);\n        public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);\n        public void setStartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);\n        public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);\n        public void alpha(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotation(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void cancel(ViewPropertyAnimatorCompat vpa, View view);\n        public void x(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void xBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void y(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void yBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void z(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void zBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationX(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationY(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZ(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, float value);\n        public void start(ViewPropertyAnimatorCompat vpa, View view);\n        public void withLayer(ViewPropertyAnimatorCompat vpa, View view);\n        public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);\n        public void setListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorListener listener);\n        public void setUpdateListener(ViewPropertyAnimatorCompat vpa, View view,\n                ViewPropertyAnimatorUpdateListener listener);\n    };\n```","slug":"recyclerviewANM","published":1,"updated":"2017-12-14T07:26:23.349Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdj0017kku0mei27vyf","content":"<h2 id=\"DefaultItemAnimator\"><a href=\"#DefaultItemAnimator\" class=\"headerlink\" title=\"DefaultItemAnimator\"></a>DefaultItemAnimator</h2><p>RecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画<br>DefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class BaseItemAnimator extends SimpleItemAnimator &#123;</div><div class=\"line\">    //Item移除回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateRemove(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item添加回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateAdd(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    //用于控制添加，移动更新时，其它Item的动画执行</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item更新回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //真正控制执行动画的地方</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">runPendingAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止某个Item的动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void endAnimation(RecyclerView.ViewHolder item) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止所有动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">endAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isRunning</span></span>() &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Next, add stuff</div><div class=\"line\">      <span class=\"keyword\">if</span> (additionsPending) &#123;</div><div class=\"line\">          final ArrayList&lt;ViewHolder&gt; additions = new ArrayList&lt;&gt;();</div><div class=\"line\">          additions.addAll(mPendingAdditions);</div><div class=\"line\">          mAdditionsList.add(additions);</div><div class=\"line\">          mPendingAdditions.clear();</div><div class=\"line\">          Runnable adder = new <span class=\"function\"><span class=\"title\">Runnable</span></span>() &#123;</div><div class=\"line\">              @Override</div><div class=\"line\">              public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">                  <span class=\"keyword\">for</span> (ViewHolder holder : additions) &#123;</div><div class=\"line\">                      animateAddImpl(holder);</div><div class=\"line\">                  &#125;</div><div class=\"line\">                  additions.clear();</div><div class=\"line\">                  mAdditionsList.remove(additions);</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;;</div><div class=\"line\">          <span class=\"keyword\">if</span> (removalsPending || movesPending || changesPending) &#123;</div><div class=\"line\">              long removeDuration = removalsPending ? getRemoveDuration() : 0;</div><div class=\"line\">              long moveDuration = movesPending ? getMoveDuration() : 0;</div><div class=\"line\">              long changeDuration = changesPending ? getChangeDuration() : 0;</div><div class=\"line\">              long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</div><div class=\"line\">              View view = additions.get(0).itemView;</div><div class=\"line\">              ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              adder.run();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"ViewPropertyAnimatorCompat\"><a href=\"#ViewPropertyAnimatorCompat\" class=\"headerlink\" title=\"ViewPropertyAnimatorCompat\"></a>ViewPropertyAnimatorCompat</h2><p>DefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void animateRemoveImpl(final ViewHolder holder) &#123;</div><div class=\"line\">       final View view = holder.itemView;</div><div class=\"line\">       final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class=\"line\">       mRemoveAnimations.add(holder);</div><div class=\"line\">       animation.setDuration(getRemoveDuration())</div><div class=\"line\">               .alpha(0).setListener(new <span class=\"function\"><span class=\"title\">VpaListenerAdapter</span></span>() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationStart(View view) &#123;</div><div class=\"line\">               dispatchRemoveStarting(holder);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationEnd(View view) &#123;</div><div class=\"line\">               animation.setListener(null);</div><div class=\"line\">               ViewCompat.setAlpha(view, 1);</div><div class=\"line\">               dispatchRemoveFinished(holder);</div><div class=\"line\">               mRemoveAnimations.remove(holder);</div><div class=\"line\">               dispatchFinishedWhenDone();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;).start();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface ViewPropertyAnimatorCompatImpl &#123;</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Duration(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getDuration(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Interpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);</div><div class=\"line\">    public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>StartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void alpha(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotation(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void cancel(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void x(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void xBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void y(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void yBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void z(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void zBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZ(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void start(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withLayer(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Listener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorListener listener);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>UpdateListener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorUpdateListener listener);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"DefaultItemAnimator\"><a href=\"#DefaultItemAnimator\" class=\"headerlink\" title=\"DefaultItemAnimator\"></a>DefaultItemAnimator</h2><p>RecyclerView 默认设置了这个动画的，看源码如果不设置动画就默认使用这个动画<br>DefaultItemAnimator 是自带的动画效果，我们自定义动画也是参考它的实现,下面一起来分析</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"> public class BaseItemAnimator extends SimpleItemAnimator &#123;</div><div class=\"line\">    //Item移除回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateRemove(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item添加回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateAdd(RecyclerView.ViewHolder holder) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">    //用于控制添加，移动更新时，其它Item的动画执行</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateMove(RecyclerView.ViewHolder holder, int fromX, int fromY, int toX, int toY) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //Item更新回调</div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean animateChange(RecyclerView.ViewHolder oldHolder, RecyclerView.ViewHolder newHolder, int fromLeft, int fromTop, int toLeft, int toTop) &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //真正控制执行动画的地方</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">runPendingAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止某个Item的动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void endAnimation(RecyclerView.ViewHolder item) &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    //停止所有动画</div><div class=\"line\">    @Override</div><div class=\"line\">    public void <span class=\"function\"><span class=\"title\">endAnimations</span></span>() &#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    @Override</div><div class=\"line\">    public boolean <span class=\"function\"><span class=\"title\">isRunning</span></span>() &#123;</div><div class=\"line\">        <span class=\"built_in\">return</span> <span class=\"literal\">false</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<p>具体可以直接看源码，你会发现它的动画执行是这样的，先removed，再move，再change，最后再add<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Next, add stuff</div><div class=\"line\">      <span class=\"keyword\">if</span> (additionsPending) &#123;</div><div class=\"line\">          final ArrayList&lt;ViewHolder&gt; additions = new ArrayList&lt;&gt;();</div><div class=\"line\">          additions.addAll(mPendingAdditions);</div><div class=\"line\">          mAdditionsList.add(additions);</div><div class=\"line\">          mPendingAdditions.clear();</div><div class=\"line\">          Runnable adder = new <span class=\"function\"><span class=\"title\">Runnable</span></span>() &#123;</div><div class=\"line\">              @Override</div><div class=\"line\">              public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">                  <span class=\"keyword\">for</span> (ViewHolder holder : additions) &#123;</div><div class=\"line\">                      animateAddImpl(holder);</div><div class=\"line\">                  &#125;</div><div class=\"line\">                  additions.clear();</div><div class=\"line\">                  mAdditionsList.remove(additions);</div><div class=\"line\">              &#125;</div><div class=\"line\">          &#125;;</div><div class=\"line\">          <span class=\"keyword\">if</span> (removalsPending || movesPending || changesPending) &#123;</div><div class=\"line\">              long removeDuration = removalsPending ? getRemoveDuration() : 0;</div><div class=\"line\">              long moveDuration = movesPending ? getMoveDuration() : 0;</div><div class=\"line\">              long changeDuration = changesPending ? getChangeDuration() : 0;</div><div class=\"line\">              long totalDelay = removeDuration + Math.max(moveDuration, changeDuration);</div><div class=\"line\">              View view = additions.get(0).itemView;</div><div class=\"line\">              ViewCompat.postOnAnimationDelayed(view, adder, totalDelay); // 看到没这个延迟时间的计算</div><div class=\"line\">          &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">              adder.run();</div><div class=\"line\">          &#125;</div><div class=\"line\">      &#125;</div></pre></td></tr></table></figure></p>\n<h2 id=\"ViewPropertyAnimatorCompat\"><a href=\"#ViewPropertyAnimatorCompat\" class=\"headerlink\" title=\"ViewPropertyAnimatorCompat\"></a>ViewPropertyAnimatorCompat</h2><p>DefaultItemAnimator 的动画效果都是基于 ViewPropertyAnimatorCompat，拿个例子说说<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">private void animateRemoveImpl(final ViewHolder holder) &#123;</div><div class=\"line\">       final View view = holder.itemView;</div><div class=\"line\">       final ViewPropertyAnimatorCompat animation = ViewCompat.animate(view);</div><div class=\"line\">       mRemoveAnimations.add(holder);</div><div class=\"line\">       animation.setDuration(getRemoveDuration())</div><div class=\"line\">               .alpha(0).setListener(new <span class=\"function\"><span class=\"title\">VpaListenerAdapter</span></span>() &#123;</div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationStart(View view) &#123;</div><div class=\"line\">               dispatchRemoveStarting(holder);</div><div class=\"line\">           &#125;</div><div class=\"line\"></div><div class=\"line\">           @Override</div><div class=\"line\">           public void onAnimationEnd(View view) &#123;</div><div class=\"line\">               animation.setListener(null);</div><div class=\"line\">               ViewCompat.setAlpha(view, 1);</div><div class=\"line\">               dispatchRemoveFinished(holder);</div><div class=\"line\">               mRemoveAnimations.remove(holder);</div><div class=\"line\">               dispatchFinishedWhenDone();</div><div class=\"line\">           &#125;</div><div class=\"line\">       &#125;).start();</div><div class=\"line\">   &#125;</div></pre></td></tr></table></figure></p>\n<p>这里表示的是透明度从1到0变化，你看下add那个是这样的.alpha(1)，ViewPropertyAnimatorCompat里面还有很多动画<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">interface ViewPropertyAnimatorCompatImpl &#123;</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Duration(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getDuration(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Interpolator(ViewPropertyAnimatorCompat vpa, View view, Interpolator value);</div><div class=\"line\">    public Interpolator getInterpolator(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>StartDelay(ViewPropertyAnimatorCompat vpa, View view, long value);</div><div class=\"line\">    public long getStartDelay(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void alpha(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void alphaBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotation(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void rotationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void scaleYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void cancel(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void x(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void xBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void y(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void yBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void z(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void zBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationX(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationXBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationY(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationYBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZ(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void translationZBy(ViewPropertyAnimatorCompat vpa, View view, <span class=\"built_in\">float</span> value);</div><div class=\"line\">    public void start(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withLayer(ViewPropertyAnimatorCompat vpa, View view);</div><div class=\"line\">    public void withStartAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void withEndAction(ViewPropertyAnimatorCompat vpa, View view, Runnable runnable);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>Listener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorListener listener);</div><div class=\"line\">    public void <span class=\"built_in\">set</span>UpdateListener(ViewPropertyAnimatorCompat vpa, View view,</div><div class=\"line\">            ViewPropertyAnimatorUpdateListener listener);</div><div class=\"line\">&#125;;</div></pre></td></tr></table></figure></p>"},{"title":"线程池ThreadPoolExecutor","date":"2017-05-10T08:58:30.000Z","_content":"\n1.ThreadPoolExecutor参数\n\njdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。 \nThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler) \ncorePoolSize: 核心线程数，能够同时执行的任务数量； \nmaximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）； \nkeepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间； \nunit：时间单位； \nworkQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满； \nthreadFactory：创建线程的工厂，使用系统默认的类； \nhandler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；\n\n<!-- more -->\n\n2.阻塞队列\n\n队列用于排队，避免一瞬间出现大量请求的问题。 \n阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。\n\n3.执行流程\n\n当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。 \n下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。\n\n4.代码\n``` bash\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        /**\n         * 创建九个任务\n         */\n        for (int i = 0; i < 9; i++) {\n            ThreadPoolManager.getInstance().execute(new DownloadTask(i));\n        }\n    }\n    /**\n     * 模仿下载任务，实现Runnable\n     */\n    class DownloadTask implements Runnable{\n        private int num;\n        public DownloadTask(int num) {\n            super();\n            this.num = num;\n            Log.d(\"JAVA\", \"task - \"+num + \" 等待中...\");\n        }\n        @Override\n        public void run() {\n            Log.d(\"JAVA\", \"task - \"+num + \" 开始执行了...开始执行了...\");\n            SystemClock.sleep(5000); //模拟延时执行的时间\n            Log.e(\"JAVA\", \"task - \"+num + \" 结束了...\");\n        }\n    }\n}\n```\n运行结果\n![运行结果](http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg)","source":"_posts/threadPoolExecutor.md","raw":"---\ntitle: 线程池ThreadPoolExecutor\ndate: 2017-05-10 16:58:30\ncategories: android\ntags: 多线程\n---\n\n1.ThreadPoolExecutor参数\n\njdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。 \nThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler) \ncorePoolSize: 核心线程数，能够同时执行的任务数量； \nmaximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）； \nkeepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间； \nunit：时间单位； \nworkQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满； \nthreadFactory：创建线程的工厂，使用系统默认的类； \nhandler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；\n\n<!-- more -->\n\n2.阻塞队列\n\n队列用于排队，避免一瞬间出现大量请求的问题。 \n阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。\n\n3.执行流程\n\n当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。 \n下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。\n\n4.代码\n``` bash\npublic class MainActivity extends AppCompatActivity {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        /**\n         * 创建九个任务\n         */\n        for (int i = 0; i < 9; i++) {\n            ThreadPoolManager.getInstance().execute(new DownloadTask(i));\n        }\n    }\n    /**\n     * 模仿下载任务，实现Runnable\n     */\n    class DownloadTask implements Runnable{\n        private int num;\n        public DownloadTask(int num) {\n            super();\n            this.num = num;\n            Log.d(\"JAVA\", \"task - \"+num + \" 等待中...\");\n        }\n        @Override\n        public void run() {\n            Log.d(\"JAVA\", \"task - \"+num + \" 开始执行了...开始执行了...\");\n            SystemClock.sleep(5000); //模拟延时执行的时间\n            Log.e(\"JAVA\", \"task - \"+num + \" 结束了...\");\n        }\n    }\n}\n```\n运行结果\n![运行结果](http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg)","slug":"threadPoolExecutor","published":1,"updated":"2017-12-14T07:26:23.351Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdk001akku075jx242g","content":"<p>1.ThreadPoolExecutor参数</p>\n<p>jdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。<br>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler)<br>corePoolSize: 核心线程数，能够同时执行的任务数量；<br>maximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）；<br>keepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间；<br>unit：时间单位；<br>workQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满；<br>threadFactory：创建线程的工厂，使用系统默认的类；<br>handler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；</p>\n<a id=\"more\"></a>\n<p>2.阻塞队列</p>\n<p>队列用于排队，避免一瞬间出现大量请求的问题。<br>阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。</p>\n<p>3.执行流程</p>\n<p>当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。<br>下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。</p>\n<p>4.代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends AppCompatActivity &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">        super.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.activity_main);</div><div class=\"line\">        /**</div><div class=\"line\">         * 创建九个任务</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 9; i++) &#123;</div><div class=\"line\">            ThreadPoolManager.getInstance().execute(new DownloadTask(i));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /**</div><div class=\"line\">     * 模仿下载任务，实现Runnable</div><div class=\"line\">     */</div><div class=\"line\">    class DownloadTask implements Runnable&#123;</div><div class=\"line\">        private int num;</div><div class=\"line\">        public DownloadTask(int num) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            this.num = num;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 等待中...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 开始执行了...开始执行了...\"</span>);</div><div class=\"line\">            SystemClock.sleep(5000); //模拟延时执行的时间</div><div class=\"line\">            Log.e(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 结束了...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果<br><img src=\"http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg\" alt=\"运行结果\"></p>\n","site":{"data":{}},"excerpt":"<p>1.ThreadPoolExecutor参数</p>\n<p>jdk自身带有线程池的实现类ThreadPoolExecutor，使用ThreadPoolExecutor，了解其每个参数的意义是必不可少的。<br>ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, handler)<br>corePoolSize: 核心线程数，能够同时执行的任务数量；<br>maximumPoolSize：除去缓冲队列中等待的任务，最大能容纳的任务数（其实是包括了核心线程池数量）；<br>keepAliveTime：超出workQueue的等待任务的存活时间，就是指maximumPoolSize里面的等待任务的存活时间；<br>unit：时间单位；<br>workQueue:阻塞等待线程的队列，一般使用new LinkedBlockingQueue()这个，如果不指定容量，会一直往里边添加，没有限制,workQueue永远不会满；<br>threadFactory：创建线程的工厂，使用系统默认的类；<br>handler：当任务数超过maximumPoolSize时，对任务的处理策略，默认策略是拒绝添加；</p>","more":"<p>2.阻塞队列</p>\n<p>队列用于排队，避免一瞬间出现大量请求的问题。<br>阻塞队列分为 有限队列（SynchronousQueue、ArrayBlockingQueue）和 无限队列（LinkedBloackingQueue）。</p>\n<p>3.执行流程</p>\n<p>当线程数小于corePoolSize时，每添加一个任务，则立即开启线程执行；当corePoolSize满的时候，后面添加的任务将放入缓冲队列workQueue等待；当workQueue也满的时候，看是否超过maximumPoolSize线程数，如果超过，默认拒绝执行。<br>下面我们看个例子：假如corePoolSize=2，maximumPoolSize=3，workQueue容量为8;最开始，执行的任务A，B，此时corePoolSize已用完，再次执行任务C，则C将被放入缓冲队列workQueue中等待着，如果后来又添加了7个任务，此时workQueue已满，则后面再来的任务将会和maximumPoolSize比较，由于maximumPoolSize为3，所以只能容纳1个了，因为有2个在corePoolSize中运行了，所以后面来的任务默认都会被拒绝。</p>\n<p>4.代码<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\">public class MainActivity extends AppCompatActivity &#123;</div><div class=\"line\">    @Override</div><div class=\"line\">    protected void onCreate(Bundle savedInstanceState) &#123;</div><div class=\"line\">        super.onCreate(savedInstanceState);</div><div class=\"line\">        <span class=\"built_in\">set</span>ContentView(R.layout.activity_main);</div><div class=\"line\">        /**</div><div class=\"line\">         * 创建九个任务</div><div class=\"line\">         */</div><div class=\"line\">        <span class=\"keyword\">for</span> (int i = 0; i &lt; 9; i++) &#123;</div><div class=\"line\">            ThreadPoolManager.getInstance().execute(new DownloadTask(i));</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    /**</div><div class=\"line\">     * 模仿下载任务，实现Runnable</div><div class=\"line\">     */</div><div class=\"line\">    class DownloadTask implements Runnable&#123;</div><div class=\"line\">        private int num;</div><div class=\"line\">        public DownloadTask(int num) &#123;</div><div class=\"line\">            super();</div><div class=\"line\">            this.num = num;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 等待中...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        @Override</div><div class=\"line\">        public void <span class=\"function\"><span class=\"title\">run</span></span>() &#123;</div><div class=\"line\">            Log.d(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 开始执行了...开始执行了...\"</span>);</div><div class=\"line\">            SystemClock.sleep(5000); //模拟延时执行的时间</div><div class=\"line\">            Log.e(<span class=\"string\">\"JAVA\"</span>, <span class=\"string\">\"task - \"</span>+num + <span class=\"string\">\" 结束了...\"</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>运行结果<br><img src=\"http://img1.ph.126.net/nPxfEyrfw0dgATkDbB6iLA==/6632146386609030268.jpg\" alt=\"运行结果\"></p>"},{"title":"初识 android View","date":"2017-05-14T05:57:51.000Z","_content":"\n## View的坐标系\n![](http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg)\n\n<!-- more -->\n## 从构造函数开始\n``` bash\npublic void SloopView(Context context) {} // 一般在直接New一个View的时候调用。\n// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。\npublic void SloopView(Context context, AttributeSet attrs) {} \npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr) {}\npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {} // 有四个参数的构造函数在API21的时候才添加上\n```\n有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，\n且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：\n``` bash\npublic ImageButton(Context context, AttributeSet attrs) {\n    //调用了三个参数的构造函数，明确指定第三个参数\n    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);\n}\n\npublic ImageButton(Context context, AttributeSet attrs, int defStyleAttr) {\n    //此处调了四个参数的构造函数，无视即可\n    this(context, attrs, defStyleAttr, 0); \n}\n//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数\n```\n\n## view 的绘制过程 (注意不要在里面做ui更新操作)\n![](http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg)\nonMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。\n``` bash\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值\n    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式\n    \n    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值\n    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式\n}\n```\n测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：\n\n|  模式\t\t\t|二进制数值\t\t|描述\n| --------  | \t-----:   \t\t| :----: |\n|UNSPECIFIED\t|00\t|\t\t\t默认值，父控件没有给子view任何限制，子View可以设置为任意大小。\n|EXACTLY\t\t|01\t|\t\t\t表示父控件已经确切的指定了子View的大小。\n|AT_MOST\t\t|10\t|\t\t\t表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。\n\n注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数\n\nonSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度\n\nonLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的\n\n## 实用api\n``` bash\nevent.getX();       //触摸点相对于其所在组件坐标系的坐标\nevent.getY();\n\nevent.getRawX();    //触摸点相对于屏幕默认坐标系的坐标\nevent.getRawY();\n\ngetTop();       //获取子View左上角距父View顶部的距离\ngetLeft();      //获取子View左上角距父View左侧的距离\ngetBottom();    //获取子View右下角距父View顶部的距离\ngetRight();     //获取子View右下角距父View左侧的距离\n```","source":"_posts/view.md","raw":"---\ntitle: 初识 android View\ndate: 2017-05-14 13:57:51\ncategories: android\ntags: 自定义view\n---\n\n## View的坐标系\n![](http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg)\n\n<!-- more -->\n## 从构造函数开始\n``` bash\npublic void SloopView(Context context) {} // 一般在直接New一个View的时候调用。\n// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。\npublic void SloopView(Context context, AttributeSet attrs) {} \npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr) {}\npublic void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {} // 有四个参数的构造函数在API21的时候才添加上\n```\n有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，\n且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：\n``` bash\npublic ImageButton(Context context, AttributeSet attrs) {\n    //调用了三个参数的构造函数，明确指定第三个参数\n    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);\n}\n\npublic ImageButton(Context context, AttributeSet attrs, int defStyleAttr) {\n    //此处调了四个参数的构造函数，无视即可\n    this(context, attrs, defStyleAttr, 0); \n}\n//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数\n```\n\n## view 的绘制过程 (注意不要在里面做ui更新操作)\n![](http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg)\nonMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。\n``` bash\n@Override\nprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值\n    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式\n    \n    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值\n    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式\n}\n```\n测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：\n\n|  模式\t\t\t|二进制数值\t\t|描述\n| --------  | \t-----:   \t\t| :----: |\n|UNSPECIFIED\t|00\t|\t\t\t默认值，父控件没有给子view任何限制，子View可以设置为任意大小。\n|EXACTLY\t\t|01\t|\t\t\t表示父控件已经确切的指定了子View的大小。\n|AT_MOST\t\t|10\t|\t\t\t表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。\n\n注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数\n\nonSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度\n\nonLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的\n\n## 实用api\n``` bash\nevent.getX();       //触摸点相对于其所在组件坐标系的坐标\nevent.getY();\n\nevent.getRawX();    //触摸点相对于屏幕默认坐标系的坐标\nevent.getRawY();\n\ngetTop();       //获取子View左上角距父View顶部的距离\ngetLeft();      //获取子View左上角距父View左侧的距离\ngetBottom();    //获取子View右下角距父View顶部的距离\ngetRight();     //获取子View右下角距父View左侧的距离\n```","slug":"view","published":1,"updated":"2017-12-14T07:26:23.353Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdm001dkku0kybxg2i5","content":"<h2 id=\"View的坐标系\"><a href=\"#View的坐标系\" class=\"headerlink\" title=\"View的坐标系\"></a>View的坐标系</h2><p><img src=\"http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg\" alt=\"\"></p>\n<a id=\"more\"></a>\n<h2 id=\"从构造函数开始\"><a href=\"#从构造函数开始\" class=\"headerlink\" title=\"从构造函数开始\"></a>从构造函数开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void SloopView(Context context) &#123;&#125; // 一般在直接New一个View的时候调用。</div><div class=\"line\">// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs) &#123;&#125; </div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr) &#123;&#125;</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;&#125; // 有四个参数的构造函数在API21的时候才添加上</div></pre></td></tr></table></figure>\n<p>有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，<br>且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ImageButton(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    //调用了三个参数的构造函数，明确指定第三个参数</div><div class=\"line\">    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public ImageButton(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class=\"line\">    //此处调了四个参数的构造函数，无视即可</div><div class=\"line\">    this(context, attrs, defStyleAttr, 0); </div><div class=\"line\">&#125;</div><div class=\"line\">//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数</div></pre></td></tr></table></figure></p>\n<h2 id=\"view-的绘制过程-注意不要在里面做ui更新操作\"><a href=\"#view-的绘制过程-注意不要在里面做ui更新操作\" class=\"headerlink\" title=\"view 的绘制过程 (注意不要在里面做ui更新操作)\"></a>view 的绘制过程 (注意不要在里面做ui更新操作)</h2><p><img src=\"http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg\" alt=\"\"><br>onMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值</div><div class=\"line\">    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式</div><div class=\"line\">    </div><div class=\"line\">    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值</div><div class=\"line\">    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:right\">二进制数值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UNSPECIFIED</td>\n<td style=\"text-align:right\">00</td>\n<td style=\"text-align:center\">默认值，父控件没有给子view任何限制，子View可以设置为任意大小。</td>\n</tr>\n<tr>\n<td>EXACTLY</td>\n<td style=\"text-align:right\">01</td>\n<td style=\"text-align:center\">表示父控件已经确切的指定了子View的大小。</td>\n</tr>\n<tr>\n<td>AT_MOST</td>\n<td style=\"text-align:right\">10</td>\n<td style=\"text-align:center\">表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数</p>\n<p>onSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度</p>\n<p>onLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的</p>\n<h2 id=\"实用api\"><a href=\"#实用api\" class=\"headerlink\" title=\"实用api\"></a>实用api</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">event.getX();       //触摸点相对于其所在组件坐标系的坐标</div><div class=\"line\">event.getY();</div><div class=\"line\"></div><div class=\"line\">event.getRawX();    //触摸点相对于屏幕默认坐标系的坐标</div><div class=\"line\">event.getRawY();</div><div class=\"line\"></div><div class=\"line\">getTop();       //获取子View左上角距父View顶部的距离</div><div class=\"line\">getLeft();      //获取子View左上角距父View左侧的距离</div><div class=\"line\">getBottom();    //获取子View右下角距父View顶部的距离</div><div class=\"line\">getRight();     //获取子View右下角距父View左侧的距离</div></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h2 id=\"View的坐标系\"><a href=\"#View的坐标系\" class=\"headerlink\" title=\"View的坐标系\"></a>View的坐标系</h2><p><img src=\"http://img2.ph.126.net/xkg-KtxNMPdvkVHUtntDiA==/6631898996492790587.jpg\" alt=\"\"></p>","more":"<h2 id=\"从构造函数开始\"><a href=\"#从构造函数开始\" class=\"headerlink\" title=\"从构造函数开始\"></a>从构造函数开始</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">public void SloopView(Context context) &#123;&#125; // 一般在直接New一个View的时候调用。</div><div class=\"line\">// 一般在layout文件中使用的时候会调用，关于它的所有属性(包括自定义属性)都会包含在attrs中传递进来。</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs) &#123;&#125; </div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr) &#123;&#125;</div><div class=\"line\">public void SloopView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) &#123;&#125; // 有四个参数的构造函数在API21的时候才添加上</div></pre></td></tr></table></figure>\n<p>有三个参数的构造函数中第三个参数是默认的Style，这里的默认的Style是指它在当前Application或Activity所用的Theme中的默认Style，<br>且只有在明确调用的时候才会生效，以系统中的ImageButton为例说明：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">public ImageButton(Context context, AttributeSet attrs) &#123;</div><div class=\"line\">    //调用了三个参数的构造函数，明确指定第三个参数</div><div class=\"line\">    this(context, attrs, com.android.internal.R.attr.imageButtonStyle);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">public ImageButton(Context context, AttributeSet attrs, int defStyleAttr) &#123;</div><div class=\"line\">    //此处调了四个参数的构造函数，无视即可</div><div class=\"line\">    this(context, attrs, defStyleAttr, 0); </div><div class=\"line\">&#125;</div><div class=\"line\">//注意：即使你在View中使用了Style这个属性也不会调用三个参数的构造函数，所调用的依旧是两个参数的构造函数</div></pre></td></tr></table></figure></p>\n<h2 id=\"view-的绘制过程-注意不要在里面做ui更新操作\"><a href=\"#view-的绘制过程-注意不要在里面做ui更新操作\" class=\"headerlink\" title=\"view 的绘制过程 (注意不要在里面做ui更新操作)\"></a>view 的绘制过程 (注意不要在里面做ui更新操作)</h2><p><img src=\"http://img0.ph.126.net/EMLvPoL268zzoNuT0hAfkg==/6632319009931934028.jpg\" alt=\"\"><br>onMeasure: 测量View大小, View的大小不仅由自身所决定，同时也会受到父控件的影响，为了我们的控件能更好的适应各种情况，一般会自己进行测量。<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">@Override</div><div class=\"line\">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</div><div class=\"line\">    int widthsize  MeasureSpec.getSize(widthMeasureSpec);      //取出宽度的确切数值</div><div class=\"line\">    int widthmode  MeasureSpec.getMode(widthMeasureSpec);      //取出宽度的测量模式</div><div class=\"line\">    </div><div class=\"line\">    int heightsize  MeasureSpec.getSize(heightMeasureSpec);    //取出高度的确切数值</div><div class=\"line\">    int heightmode  MeasureSpec.getMode(heightMeasureSpec);    //取出高度的测量模式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>测量模式一共有三种， 被定义在 Android 中的 View 类的一个内部类View.MeasureSpec中：</p>\n<table>\n<thead>\n<tr>\n<th>模式</th>\n<th style=\"text-align:right\">二进制数值</th>\n<th style=\"text-align:center\">描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>UNSPECIFIED</td>\n<td style=\"text-align:right\">00</td>\n<td style=\"text-align:center\">默认值，父控件没有给子view任何限制，子View可以设置为任意大小。</td>\n</tr>\n<tr>\n<td>EXACTLY</td>\n<td style=\"text-align:right\">01</td>\n<td style=\"text-align:center\">表示父控件已经确切的指定了子View的大小。</td>\n</tr>\n<tr>\n<td>AT_MOST</td>\n<td style=\"text-align:right\">10</td>\n<td style=\"text-align:center\">表示子View具体大小没有尺寸限制，但是存在上限，上限一般为父View大小。</td>\n</tr>\n</tbody>\n</table>\n<p>注意：如果对View的宽高进行修改了，不要调用 super.onMeasure( widthMeasureSpec, heightMeasureSpec); 要调用 setMeasuredDimension( widthsize, heightsize); 这个函数</p>\n<p>onSizeChanged: 界面大小变化系统自动调,onSizeChanged(w, h, oldw, oldh)四个参,分别为 宽度,高度，上一次宽度，上一次高度</p>\n<p>onLayout: 确定子View布局位置,child.layout(l, t, r, b); // 注意都是相对父布局的</p>\n<h2 id=\"实用api\"><a href=\"#实用api\" class=\"headerlink\" title=\"实用api\"></a>实用api</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">event.getX();       //触摸点相对于其所在组件坐标系的坐标</div><div class=\"line\">event.getY();</div><div class=\"line\"></div><div class=\"line\">event.getRawX();    //触摸点相对于屏幕默认坐标系的坐标</div><div class=\"line\">event.getRawY();</div><div class=\"line\"></div><div class=\"line\">getTop();       //获取子View左上角距父View顶部的距离</div><div class=\"line\">getLeft();      //获取子View左上角距父View左侧的距离</div><div class=\"line\">getBottom();    //获取子View右下角距父View顶部的距离</div><div class=\"line\">getRight();     //获取子View右下角距父View左侧的距离</div></pre></td></tr></table></figure>"},{"title":"tip","date":"2017-09-17T12:20:20.000Z","_content":"\n## 坑与提示\n\n### 记得吃药\n\n<!-- more -->\n\n### Today is a special one ， hand in hand ！\n\n### other\n\n旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置","source":"_posts/tip.md","raw":"---\ntitle: tip\ndate: 2017-09-17 20:20:20\ncategories: fdbook\ntags: tip\n---\n\n## 坑与提示\n\n### 记得吃药\n\n<!-- more -->\n\n### Today is a special one ， hand in hand ！\n\n### other\n\n旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置","slug":"tip","published":1,"updated":"2017-12-14T07:26:23.352Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdn001gkku0eyxznr3c","content":"<h2 id=\"坑与提示\"><a href=\"#坑与提示\" class=\"headerlink\" title=\"坑与提示\"></a>坑与提示</h2><h3 id=\"记得吃药\"><a href=\"#记得吃药\" class=\"headerlink\" title=\"记得吃药\"></a>记得吃药</h3><a id=\"more\"></a>\n<h3 id=\"Today-is-a-special-one-，-hand-in-hand-！\"><a href=\"#Today-is-a-special-one-，-hand-in-hand-！\" class=\"headerlink\" title=\"Today is a special one ， hand in hand ！\"></a>Today is a special one ， hand in hand ！</h3><h3 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h3><p>旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"坑与提示\"><a href=\"#坑与提示\" class=\"headerlink\" title=\"坑与提示\"></a>坑与提示</h2><h3 id=\"记得吃药\"><a href=\"#记得吃药\" class=\"headerlink\" title=\"记得吃药\"></a>记得吃药</h3>","more":"<h3 id=\"Today-is-a-special-one-，-hand-in-hand-！\"><a href=\"#Today-is-a-special-one-，-hand-in-hand-！\" class=\"headerlink\" title=\"Today is a special one ， hand in hand ！\"></a>Today is a special one ， hand in hand ！</h3><h3 id=\"other\"><a href=\"#other\" class=\"headerlink\" title=\"other\"></a>other</h3><p>旋转缩放默认是坐标原点为中心点，对于图片来说就是左上角的位置</p>"},{"title":"volatitle 关键字","date":"2017-05-10T07:35:10.000Z","_content":"\n## 首先先普及下内存模型的概念\n  \n大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n\n<!-- more -->\n\n## 并发编程中的三个概念\n1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值\n3.有序性：即程序执行的顺序按照代码的先后顺序执行\n\n## volatitle的作用\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n3）不保證原子性\n\n### [参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\n\n","source":"_posts/volatitle.md","raw":"---\ntitle: volatitle 关键字\ndate: 2017-05-10 15:35:10\ncategories: android\ntags: java\n---\n\n## 首先先普及下内存模型的概念\n  \n大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。\n也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。\n\n<!-- more -->\n\n## 并发编程中的三个概念\n1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行\n2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值\n3.有序性：即程序执行的顺序按照代码的先后顺序执行\n\n## volatitle的作用\n一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：\n1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。\n2）禁止进行指令重排序。\n3）不保證原子性\n\n### [参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\n\n","slug":"volatitle","published":1,"updated":"2017-12-14T07:26:23.355Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjb66awdp001kkku0xwp5njky","content":"<h2 id=\"首先先普及下内存模型的概念\"><a href=\"#首先先普及下内存模型的概念\" class=\"headerlink\" title=\"首先先普及下内存模型的概念\"></a>首先先普及下内存模型的概念</h2><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。<br>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>\n<a id=\"more\"></a>\n<h2 id=\"并发编程中的三个概念\"><a href=\"#并发编程中的三个概念\" class=\"headerlink\" title=\"并发编程中的三个概念\"></a>并发编程中的三个概念</h2><p>1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行<br>2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值<br>3.有序性：即程序执行的顺序按照代码的先后顺序执行</p>\n<h2 id=\"volatitle的作用\"><a href=\"#volatitle的作用\" class=\"headerlink\" title=\"volatitle的作用\"></a>volatitle的作用</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。<br>3）不保證原子性</p>\n<h3 id=\"参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\"><a href=\"#参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\" class=\"headerlink\" title=\"[参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\"></a>[参考链接] (<a href=\"http://blog.csdn.net/victor_cindy1/article/details/44310195\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/victor_cindy1/article/details/44310195</a>)</h3>","site":{"data":{}},"excerpt":"<h2 id=\"首先先普及下内存模型的概念\"><a href=\"#首先先普及下内存模型的概念\" class=\"headerlink\" title=\"首先先普及下内存模型的概念\"></a>首先先普及下内存模型的概念</h2><p>大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。<br>也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。</p>","more":"<h2 id=\"并发编程中的三个概念\"><a href=\"#并发编程中的三个概念\" class=\"headerlink\" title=\"并发编程中的三个概念\"></a>并发编程中的三个概念</h2><p>1.原子性 ：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行<br>2.可見性 ：可见性是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值<br>3.有序性：即程序执行的顺序按照代码的先后顺序执行</p>\n<h2 id=\"volatitle的作用\"><a href=\"#volatitle的作用\" class=\"headerlink\" title=\"volatitle的作用\"></a>volatitle的作用</h2><p>一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义：<br>1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。<br>2）禁止进行指令重排序。<br>3）不保證原子性</p>\n<h3 id=\"参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\"><a href=\"#参考链接-http-blog-csdn-net-victor-cindy1-article-details-44310195\" class=\"headerlink\" title=\"[参考链接] (http://blog.csdn.net/victor_cindy1/article/details/44310195)\"></a>[参考链接] (<a href=\"http://blog.csdn.net/victor_cindy1/article/details/44310195\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/victor_cindy1/article/details/44310195</a>)</h3>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjb66awcz0005kku0unw1g4va","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awd4000akku0pdue63ij"},{"post_id":"cjb66awcm0000kku04qubdsaw","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awd6000ekku0xcfami9c"},{"post_id":"cjb66awd00006kku0z46wr3uu","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awd8000hkku0vxf2wr9w"},{"post_id":"cjb66awct0001kku0phqip7q5","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdb000mkku0zzlfpk7o"},{"post_id":"cjb66awd4000bkku06p8i1nrg","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdd000pkku0dtxbkpqv"},{"post_id":"cjb66awcx0004kku0rhglqwaf","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awde000tkku0mej26m6j"},{"post_id":"cjb66awdb000nkku0feafa4bt","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdf000vkku0ptyi1ijr"},{"post_id":"cjb66awd20009kku0fl68m2l1","category_id":"cjb66awda000jkku05rsdatt6","_id":"cjb66awdg000zkku0x0gk429t"},{"post_id":"cjb66awdd000qkku0txb7npp0","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdi0012kku0d617qpp3"},{"post_id":"cjb66awde000ukku0459wrsph","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdj0016kku010o5st0f"},{"post_id":"cjb66awd7000fkku0a1jw84vx","category_id":"cjb66awdd000rkku0nbsm76hj","_id":"cjb66awdk0019kku08e2vp7xk"},{"post_id":"cjb66awdf000wkku0m8phjtcm","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdl001bkku0epz967ex"},{"post_id":"cjb66awd8000ikku08hintxdw","category_id":"cjb66awdd000rkku0nbsm76hj","_id":"cjb66awdn001fkku0bcair2q4"},{"post_id":"cjb66awdi0013kku0fkcm4u5a","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdo001ikku044ufowh4"},{"post_id":"cjb66awdj0017kku0mei27vyf","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdq001mkku0au6dmlf8"},{"post_id":"cjb66awdk001akku075jx242g","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdr001okku04txe5u2f"},{"post_id":"cjb66awdm001dkku0kybxg2i5","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awds001rkku0oldmy03q"},{"post_id":"cjb66awdn001gkku0eyxznr3c","category_id":"cjb66awda000jkku05rsdatt6","_id":"cjb66awds001tkku03y5s8m90"},{"post_id":"cjb66awdp001kkku0xwp5njky","category_id":"cjb66awcv0002kku00505utbh","_id":"cjb66awdt001vkku0nw5qvdpe"}],"PostTag":[{"post_id":"cjb66awcm0000kku04qubdsaw","tag_id":"cjb66awcx0003kku0rgmbhrd2","_id":"cjb66awd7000gkku060ark0fs"},{"post_id":"cjb66awcm0000kku04qubdsaw","tag_id":"cjb66awd10008kku0cfd4n9vz","_id":"cjb66awda000kkku0u0kwixpc"},{"post_id":"cjb66awct0001kku0phqip7q5","tag_id":"cjb66awcx0003kku0rgmbhrd2","_id":"cjb66awdb000okku0pxbksko9"},{"post_id":"cjb66awcx0004kku0rhglqwaf","tag_id":"cjb66awcx0003kku0rgmbhrd2","_id":"cjb66awdh0011kku0sk1bb7mb"},{"post_id":"cjb66awcx0004kku0rhglqwaf","tag_id":"cjb66awd10008kku0cfd4n9vz","_id":"cjb66awdj0014kku0nuawtkme"},{"post_id":"cjb66awcz0005kku0unw1g4va","tag_id":"cjb66awdg000xkku04ngsb3k7","_id":"cjb66awdk0018kku0xtltqomz"},{"post_id":"cjb66awd00006kku0z46wr3uu","tag_id":"cjb66awcx0003kku0rgmbhrd2","_id":"cjb66awdm001ekku0pfdofckn"},{"post_id":"cjb66awd00006kku0z46wr3uu","tag_id":"cjb66awdj0015kku0s8nm040z","_id":"cjb66awdo001hkku0wg6aqct5"},{"post_id":"cjb66awdm001dkku0kybxg2i5","tag_id":"cjb66awcx0003kku0rgmbhrd2","_id":"cjb66awdq001lkku0lx3zmgit"},{"post_id":"cjb66awd4000bkku06p8i1nrg","tag_id":"cjb66awcx0003kku0rgmbhrd2","_id":"cjb66awdr001nkku08eomjw9i"},{"post_id":"cjb66awd4000bkku06p8i1nrg","tag_id":"cjb66awdj0015kku0s8nm040z","_id":"cjb66awds001qkku0413tmzma"},{"post_id":"cjb66awd7000fkku0a1jw84vx","tag_id":"cjb66awdo001jkku0ajbxxn2h","_id":"cjb66awds001skku0hnbfl87s"},{"post_id":"cjb66awd8000ikku08hintxdw","tag_id":"cjb66awds001pkku0pmpn8tj9","_id":"cjb66awdt001wkku0nbq7z1xd"},{"post_id":"cjb66awdb000nkku0feafa4bt","tag_id":"cjb66awdt001ukku0stuful1d","_id":"cjb66awdu001ykku0yvbm272l"},{"post_id":"cjb66awdd000qkku0txb7npp0","tag_id":"cjb66awdt001xkku02rv8ct7h","_id":"cjb66awdu0020kku0f7dlemnq"},{"post_id":"cjb66awde000ukku0459wrsph","tag_id":"cjb66awdu001zkku0qjfnqzdb","_id":"cjb66awdu0022kku0wdo8aldd"},{"post_id":"cjb66awdf000wkku0m8phjtcm","tag_id":"cjb66awdu0021kku0wchmkwez","_id":"cjb66awdv0024kku0z0bewh3u"},{"post_id":"cjb66awdh0010kku03wdercrb","tag_id":"cjb66awdv0023kku0ehfapfgu","_id":"cjb66awdv0026kku019mf39oy"},{"post_id":"cjb66awdi0013kku0fkcm4u5a","tag_id":"cjb66awdv0025kku0qksc4j0b","_id":"cjb66awdw0028kku0je4kx0du"},{"post_id":"cjb66awdj0017kku0mei27vyf","tag_id":"cjb66awdv0025kku0qksc4j0b","_id":"cjb66awdw002akku0njqj5djc"},{"post_id":"cjb66awdk001akku075jx242g","tag_id":"cjb66awdu001zkku0qjfnqzdb","_id":"cjb66awdx002ckku0l3rnu6z0"},{"post_id":"cjb66awdn001gkku0eyxznr3c","tag_id":"cjb66awdx002bkku0l8yuzofc","_id":"cjb66awdx002ekku0mnxqkvgm"},{"post_id":"cjb66awdp001kkku0xwp5njky","tag_id":"cjb66awdt001xkku02rv8ct7h","_id":"cjb66awdy002fkku0c28uci0j"}],"Tag":[{"name":"自定义view","_id":"cjb66awcx0003kku0rgmbhrd2"},{"name":"paint","_id":"cjb66awd10008kku0cfd4n9vz"},{"name":"touch","_id":"cjb66awdg000xkku04ngsb3k7"},{"name":"canvas","_id":"cjb66awdj0015kku0s8nm040z"},{"name":"hexo","_id":"cjb66awdo001jkku0ajbxxn2h"},{"name":"git","_id":"cjb66awds001pkku0pmpn8tj9"},{"name":"网络编程","_id":"cjb66awdt001ukku0stuful1d"},{"name":"java","_id":"cjb66awdt001xkku02rv8ct7h"},{"name":"多线程","_id":"cjb66awdu001zkku0qjfnqzdb"},{"name":"matrix","_id":"cjb66awdu0021kku0wchmkwez"},{"name":"优化","_id":"cjb66awdv0023kku0ehfapfgu"},{"name":"recyclerview","_id":"cjb66awdv0025kku0qksc4j0b"},{"name":"tip","_id":"cjb66awdx002bkku0l8yuzofc"}]}}